/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import * as tf from '../index';
import { CHROME_ENVS, describeWithFlags, runWithLock } from '../jasmine_util';
import { deleteDatabase } from './indexed_db';
import { purgeLocalStorageArtifacts } from './local_storage';
// Disabled for non-Chrome browsers due to:
// https://github.com/tensorflow/tfjs/issues/427
describeWithFlags('ModelManagement', CHROME_ENVS, () => {
    // Test data.
    const modelTopology1 = {
        'class_name': 'Sequential',
        'keras_version': '2.1.4',
        'config': [{
                'class_name': 'Dense',
                'config': {
                    'kernel_initializer': {
                        'class_name': 'VarianceScaling',
                        'config': {
                            'distribution': 'uniform',
                            'scale': 1.0,
                            'seed': null,
                            'mode': 'fan_avg'
                        }
                    },
                    'name': 'dense',
                    'kernel_constraint': null,
                    'bias_regularizer': null,
                    'bias_constraint': null,
                    'dtype': 'float32',
                    'activation': 'linear',
                    'trainable': true,
                    'kernel_regularizer': null,
                    'bias_initializer': { 'class_name': 'Zeros', 'config': {} },
                    'units': 1,
                    'batch_input_shape': [null, 3],
                    'use_bias': true,
                    'activity_regularizer': null
                }
            }],
        'backend': 'tensorflow'
    };
    const weightSpecs1 = [
        {
            name: 'dense/kernel',
            shape: [3, 1],
            dtype: 'float32',
        },
        {
            name: 'dense/bias',
            shape: [1],
            dtype: 'float32',
        }
    ];
    const weightData1 = new ArrayBuffer(16);
    const artifacts1 = {
        modelTopology: modelTopology1,
        weightSpecs: weightSpecs1,
        weightData: weightData1,
    };
    beforeEach(done => {
        purgeLocalStorageArtifacts();
        deleteDatabase().then(() => {
            done();
        });
    });
    afterEach(done => {
        purgeLocalStorageArtifacts();
        deleteDatabase().then(() => {
            done();
        });
    });
    // TODO(cais): Reenable this test once we fix
    // https://github.com/tensorflow/tfjs/issues/1198
    // tslint:disable-next-line:ban
    xit('List models: 0 result', done => {
        // Before any model is saved, listModels should return empty result.
        tf.io.listModels()
            .then(out => {
            expect(out).toEqual({});
            done();
        })
            .catch(err => done.fail(err.stack));
    });
    // TODO(cais): Reenable this test once we fix
    // https://github.com/tensorflow/tfjs/issues/1198
    // tslint:disable-next-line:ban
    xit('List models: 1 result', done => {
        const url = 'localstorage://baz/QuxModel';
        const handler = tf.io.getSaveHandlers(url)[0];
        handler.save(artifacts1)
            .then(saveResult => {
            // After successful saving, there should be one model.
            tf.io.listModels()
                .then(out => {
                expect(Object.keys(out).length).toEqual(1);
                expect(out[url].modelTopologyType)
                    .toEqual(saveResult.modelArtifactsInfo.modelTopologyType);
                expect(out[url].modelTopologyBytes)
                    .toEqual(saveResult.modelArtifactsInfo.modelTopologyBytes);
                expect(out[url].weightSpecsBytes)
                    .toEqual(saveResult.modelArtifactsInfo.weightSpecsBytes);
                expect(out[url].weightDataBytes)
                    .toEqual(saveResult.modelArtifactsInfo.weightDataBytes);
                done();
            })
                .catch(err => done.fail(err.stack));
        })
            .catch(err => done.fail(err.stack));
    });
    // TODO(cais): Reenable this test once we fix
    // https://github.com/tensorflow/tfjs/issues/1198
    // tslint:disable-next-line:ban
    xit('Manager: List models: 2 results in 2 mediums', done => {
        const url1 = 'localstorage://QuxModel';
        const url2 = 'indexeddb://QuxModel';
        // First, save a model in Local Storage.
        const handler1 = tf.io.getSaveHandlers(url1)[0];
        handler1.save(artifacts1)
            .then(saveResult1 => {
            // Then, save the model in IndexedDB.
            const handler2 = tf.io.getSaveHandlers(url2)[0];
            handler2.save(artifacts1)
                .then(saveResult2 => {
                // After successful saving, there should be two models.
                tf.io.listModels()
                    .then(out => {
                    expect(Object.keys(out).length).toEqual(2);
                    expect(out[url1].modelTopologyType)
                        .toEqual(saveResult1.modelArtifactsInfo.modelTopologyType);
                    expect(out[url1].modelTopologyBytes)
                        .toEqual(saveResult1.modelArtifactsInfo
                        .modelTopologyBytes);
                    expect(out[url1].weightSpecsBytes)
                        .toEqual(saveResult1.modelArtifactsInfo.weightSpecsBytes);
                    expect(out[url1].weightDataBytes)
                        .toEqual(saveResult1.modelArtifactsInfo.weightDataBytes);
                    expect(out[url2].modelTopologyType)
                        .toEqual(saveResult2.modelArtifactsInfo.modelTopologyType);
                    expect(out[url2].modelTopologyBytes)
                        .toEqual(saveResult2.modelArtifactsInfo
                        .modelTopologyBytes);
                    expect(out[url2].weightSpecsBytes)
                        .toEqual(saveResult2.modelArtifactsInfo.weightSpecsBytes);
                    expect(out[url2].weightDataBytes)
                        .toEqual(saveResult2.modelArtifactsInfo.weightDataBytes);
                    done();
                })
                    .catch(err => done.fail(err.stack));
            })
                .catch(err => done.fail(err.stack));
        })
            .catch(err => done.fail(err.stack));
    });
    // TODO(cais): Reenable this test once we fix
    // https://github.com/tensorflow/tfjs/issues/1198
    // tslint:disable-next-line:ban
    xit('Successful removeModel', done => {
        // First, save a model.
        const handler1 = tf.io.getSaveHandlers('localstorage://QuxModel')[0];
        handler1.save(artifacts1)
            .then(saveResult1 => {
            // Then, save the model under another path.
            const handler2 = tf.io.getSaveHandlers('indexeddb://repeat/QuxModel')[0];
            handler2.save(artifacts1)
                .then(saveResult2 => {
                // After successful saving, delete the first save, and then
                // `listModel` should give only one result.
                // Delete a model specified with a path that includes the
                // indexeddb:// scheme prefix should work.
                tf.io.removeModel('indexeddb://repeat/QuxModel')
                    .then(deletedInfo => {
                    tf.io.listModels()
                        .then(out => {
                        expect(Object.keys(out)).toEqual([
                            'localstorage://QuxModel'
                        ]);
                        tf.io.removeModel('localstorage://QuxModel')
                            .then(out => {
                            // The delete the remaining model.
                            tf.io.listModels()
                                .then(out => {
                                expect(Object.keys(out)).toEqual([]);
                                done();
                            })
                                .catch(err => done.fail(err));
                        })
                            .catch(err => done.fail(err));
                    })
                        .catch(err => done.fail(err));
                })
                    .catch(err => done.fail(err.stack));
            })
                .catch(err => done.fail(err.stack));
        })
            .catch(err => done.fail(err.stack));
    });
    // TODO(cais): Reenable this test once we fix
    // https://github.com/tensorflow/tfjs/issues/1198
    // tslint:disable-next-line:ban
    xit('Successful copyModel between mediums', done => {
        const url1 = 'localstorage://a1/FooModel';
        const url2 = 'indexeddb://a1/FooModel';
        // First, save a model.
        const handler1 = tf.io.getSaveHandlers(url1)[0];
        handler1.save(artifacts1)
            .then(saveResult => {
            // Once model is saved, copy the model to another path.
            tf.io.copyModel(url1, url2)
                .then(modelInfo => {
                tf.io.listModels().then(out => {
                    expect(Object.keys(out).length).toEqual(2);
                    expect(out[url1].modelTopologyType)
                        .toEqual(saveResult.modelArtifactsInfo.modelTopologyType);
                    expect(out[url1].modelTopologyBytes)
                        .toEqual(saveResult.modelArtifactsInfo.modelTopologyBytes);
                    expect(out[url1].weightSpecsBytes)
                        .toEqual(saveResult.modelArtifactsInfo.weightSpecsBytes);
                    expect(out[url1].weightDataBytes)
                        .toEqual(saveResult.modelArtifactsInfo.weightDataBytes);
                    expect(out[url2].modelTopologyType)
                        .toEqual(saveResult.modelArtifactsInfo.modelTopologyType);
                    expect(out[url2].modelTopologyBytes)
                        .toEqual(saveResult.modelArtifactsInfo.modelTopologyBytes);
                    expect(out[url2].weightSpecsBytes)
                        .toEqual(saveResult.modelArtifactsInfo.weightSpecsBytes);
                    expect(out[url2].weightDataBytes)
                        .toEqual(saveResult.modelArtifactsInfo.weightDataBytes);
                    // Load the copy and verify the content.
                    const handler2 = tf.io.getLoadHandlers(url2)[0];
                    handler2.load()
                        .then(loaded => {
                        expect(loaded.modelTopology).toEqual(modelTopology1);
                        expect(loaded.weightSpecs).toEqual(weightSpecs1);
                        expect(new Uint8Array(loaded.weightData))
                            .toEqual(new Uint8Array(weightData1));
                        done();
                    })
                        .catch(err => done.fail(err.stack));
                });
            })
                .catch(err => done.fail(err.stack));
        })
            .catch(err => done.fail(err.stack));
    });
    // TODO(cais): Reenable this test once we fix
    // https://github.com/tensorflow/tfjs/issues/1198
    // tslint:disable-next-line:ban
    xit('Successful moveModel between mediums', done => {
        const url1 = 'localstorage://a1/FooModel';
        const url2 = 'indexeddb://a1/FooModel';
        // First, save a model.
        const handler1 = tf.io.getSaveHandlers(url1)[0];
        handler1.save(artifacts1)
            .then(saveResult => {
            // Once model is saved, move the model to another path.
            tf.io.moveModel(url1, url2)
                .then(modelInfo => {
                tf.io.listModels().then(out => {
                    expect(Object.keys(out)).toEqual([url2]);
                    expect(out[url2].modelTopologyType)
                        .toEqual(saveResult.modelArtifactsInfo.modelTopologyType);
                    expect(out[url2].modelTopologyBytes)
                        .toEqual(saveResult.modelArtifactsInfo.modelTopologyBytes);
                    expect(out[url2].weightSpecsBytes)
                        .toEqual(saveResult.modelArtifactsInfo.weightSpecsBytes);
                    expect(out[url2].weightDataBytes)
                        .toEqual(saveResult.modelArtifactsInfo.weightDataBytes);
                    // Load the copy and verify the content.
                    const handler2 = tf.io.getLoadHandlers(url2)[0];
                    handler2.load()
                        .then(loaded => {
                        expect(loaded.modelTopology).toEqual(modelTopology1);
                        expect(loaded.weightSpecs).toEqual(weightSpecs1);
                        expect(new Uint8Array(loaded.weightData))
                            .toEqual(new Uint8Array(weightData1));
                        done();
                    })
                        .catch(err => {
                        done.fail(err.stack);
                    });
                });
            })
                .catch(err => done.fail(err.stack));
        })
            .catch(err => done.fail(err.stack));
    });
    it('Failed copyModel to invalid source URL', runWithLock(done => {
        const url1 = 'invalidurl';
        const url2 = 'localstorage://a1/FooModel';
        tf.io.copyModel(url1, url2)
            .then(out => {
            done.fail('Copying from invalid URL succeeded unexpectedly.');
        })
            .catch(err => {
            expect(err.message)
                .toEqual('Copying failed because no load handler is found for ' +
                'source URL invalidurl.');
            done();
        });
    }));
    it('Failed copyModel to invalid destination URL', runWithLock(done => {
        const url1 = 'localstorage://a1/FooModel';
        const url2 = 'invalidurl';
        // First, save a model.
        const handler1 = tf.io.getSaveHandlers(url1)[0];
        handler1.save(artifacts1)
            .then(saveResult => {
            // Once model is saved, copy the model to another path.
            tf.io.copyModel(url1, url2)
                .then(out => {
                done.fail('Copying to invalid URL succeeded unexpectedly.');
            })
                .catch(err => {
                expect(err.message)
                    .toEqual('Copying failed because no save handler is found for ' +
                    'destination URL invalidurl.');
                done();
            });
        })
            .catch(err => done.fail(err.stack));
    }));
    it('Failed moveModel to invalid destination URL', runWithLock(done => {
        const url1 = 'localstorage://a1/FooModel';
        const url2 = 'invalidurl';
        // First, save a model.
        const handler1 = tf.io.getSaveHandlers(url1)[0];
        handler1.save(artifacts1)
            .then(saveResult => {
            // Once model is saved, copy the model to an invalid path, which
            // should fail.
            tf.io.moveModel(url1, url2)
                .then(out => {
                done.fail('Copying to invalid URL succeeded unexpectedly.');
            })
                .catch(err => {
                expect(err.message)
                    .toEqual('Copying failed because no save handler is found for ' +
                    'destination URL invalidurl.');
                // Verify that the source has not been removed.
                tf.io.listModels()
                    .then(out => {
                    expect(Object.keys(out)).toEqual([url1]);
                    done();
                })
                    .catch(err => done.fail(err.stack));
            });
        })
            .catch(err => done.fail(err.stack));
    }));
    it('Failed deletedModel: Absent scheme', runWithLock(done => {
        // Attempt to delete a nonexistent model is expected to fail.
        tf.io.removeModel('foo')
            .then(out => {
            done.fail('Removing model with missing scheme succeeded unexpectedly.');
        })
            .catch(err => {
            expect(err.message)
                .toMatch(/The url string provided does not contain a scheme/);
            expect(err.message.indexOf('localstorage')).toBeGreaterThan(0);
            expect(err.message.indexOf('indexeddb')).toBeGreaterThan(0);
            done();
        });
    }));
    it('Failed deletedModel: Invalid scheme', runWithLock(done => {
        // Attempt to delete a nonexistent model is expected to fail.
        tf.io.removeModel('invalidscheme://foo')
            .then(out => {
            done.fail('Removing nonexistent model succeeded unexpectedly.');
        })
            .catch(err => {
            expect(err.message)
                .toEqual('Cannot find model manager for scheme \'invalidscheme\'');
            done();
        });
    }));
    it('Failed deletedModel: Nonexistent model', runWithLock(done => {
        // Attempt to delete a nonexistent model is expected to fail.
        tf.io.removeModel('indexeddb://nonexistent')
            .then(out => {
            done.fail('Removing nonexistent model succeeded unexpectedly.');
        })
            .catch(err => {
            expect(err.message)
                .toEqual('Cannot find model with path \'nonexistent\' in IndexedDB.');
            done();
        });
    }));
    it('Failed copyModel', runWithLock(done => {
        // Attempt to copy a nonexistent model should fail.
        tf.io.copyModel('indexeddb://nonexistent', 'indexeddb://destination')
            .then(out => {
            done.fail('Copying nonexistent model succeeded unexpectedly.');
        })
            .catch(err => {
            expect(err.message)
                .toEqual('Cannot find model with path \'nonexistent\' in IndexedDB.');
            done();
        });
    }));
    it('copyModel: Identical oldPath and newPath leads to Error', runWithLock(done => {
        tf.io.copyModel('a/1', 'a/1')
            .then(out => {
            done.fail('Copying with identical old & new paths succeeded unexpectedly.');
        })
            .catch(err => {
            expect(err.message)
                .toEqual('Old path and new path are the same: \'a/1\'');
            done();
        });
    }));
    it('moveModel: Identical oldPath and newPath leads to Error', runWithLock(done => {
        tf.io.moveModel('a/1', 'a/1')
            .then(out => {
            done.fail('Copying with identical old & new paths succeeded unexpectedly.');
        })
            .catch(err => {
            expect(err.message)
                .toEqual('Old path and new path are the same: \'a/1\'');
            done();
        });
    }));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWxfbWFuYWdlbWVudF90ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9pby9tb2RlbF9tYW5hZ2VtZW50X3Rlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxLQUFLLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDL0IsT0FBTyxFQUFDLFdBQVcsRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUM1RSxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQzVDLE9BQU8sRUFBQywwQkFBMEIsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRTNELDJDQUEyQztBQUMzQyxnREFBZ0Q7QUFDaEQsaUJBQWlCLENBQUMsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLEdBQUcsRUFBRTtJQUNyRCxhQUFhO0lBQ2IsTUFBTSxjQUFjLEdBQU87UUFDekIsWUFBWSxFQUFFLFlBQVk7UUFDMUIsZUFBZSxFQUFFLE9BQU87UUFDeEIsUUFBUSxFQUFFLENBQUM7Z0JBQ1QsWUFBWSxFQUFFLE9BQU87Z0JBQ3JCLFFBQVEsRUFBRTtvQkFDUixvQkFBb0IsRUFBRTt3QkFDcEIsWUFBWSxFQUFFLGlCQUFpQjt3QkFDL0IsUUFBUSxFQUFFOzRCQUNSLGNBQWMsRUFBRSxTQUFTOzRCQUN6QixPQUFPLEVBQUUsR0FBRzs0QkFDWixNQUFNLEVBQUUsSUFBSTs0QkFDWixNQUFNLEVBQUUsU0FBUzt5QkFDbEI7cUJBQ0Y7b0JBQ0QsTUFBTSxFQUFFLE9BQU87b0JBQ2YsbUJBQW1CLEVBQUUsSUFBSTtvQkFDekIsa0JBQWtCLEVBQUUsSUFBSTtvQkFDeEIsaUJBQWlCLEVBQUUsSUFBSTtvQkFDdkIsT0FBTyxFQUFFLFNBQVM7b0JBQ2xCLFlBQVksRUFBRSxRQUFRO29CQUN0QixXQUFXLEVBQUUsSUFBSTtvQkFDakIsb0JBQW9CLEVBQUUsSUFBSTtvQkFDMUIsa0JBQWtCLEVBQUUsRUFBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUM7b0JBQ3pELE9BQU8sRUFBRSxDQUFDO29CQUNWLG1CQUFtQixFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztvQkFDOUIsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLHNCQUFzQixFQUFFLElBQUk7aUJBQzdCO2FBQ0YsQ0FBQztRQUNGLFNBQVMsRUFBRSxZQUFZO0tBQ3hCLENBQUM7SUFDRixNQUFNLFlBQVksR0FBaUM7UUFDakQ7WUFDRSxJQUFJLEVBQUUsY0FBYztZQUNwQixLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2IsS0FBSyxFQUFFLFNBQVM7U0FDakI7UUFDRDtZQUNFLElBQUksRUFBRSxZQUFZO1lBQ2xCLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNWLEtBQUssRUFBRSxTQUFTO1NBQ2pCO0tBQ0YsQ0FBQztJQUNGLE1BQU0sV0FBVyxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3hDLE1BQU0sVUFBVSxHQUF5QjtRQUN2QyxhQUFhLEVBQUUsY0FBYztRQUM3QixXQUFXLEVBQUUsWUFBWTtRQUN6QixVQUFVLEVBQUUsV0FBVztLQUN4QixDQUFDO0lBRUYsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ2hCLDBCQUEwQixFQUFFLENBQUM7UUFDN0IsY0FBYyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUN6QixJQUFJLEVBQUUsQ0FBQztRQUNULENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDZiwwQkFBMEIsRUFBRSxDQUFDO1FBQzdCLGNBQWMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDekIsSUFBSSxFQUFFLENBQUM7UUFDVCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsNkNBQTZDO0lBQzdDLGlEQUFpRDtJQUNqRCwrQkFBK0I7SUFDL0IsR0FBRyxDQUFDLHVCQUF1QixFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ2xDLG9FQUFvRTtRQUNwRSxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRTthQUNiLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNWLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDeEIsSUFBSSxFQUFFLENBQUM7UUFDVCxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUMsQ0FBQyxDQUFDO0lBRUgsNkNBQTZDO0lBQzdDLGlEQUFpRDtJQUNqRCwrQkFBK0I7SUFDL0IsR0FBRyxDQUFDLHVCQUF1QixFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ2xDLE1BQU0sR0FBRyxHQUFHLDZCQUE2QixDQUFDO1FBQzFDLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2FBQ25CLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNqQixzREFBc0Q7WUFDdEQsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUU7aUJBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNWLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0MsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQztxQkFDN0IsT0FBTyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2dCQUM5RCxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixDQUFDO3FCQUM5QixPQUFPLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDLENBQUM7Z0JBQy9ELE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7cUJBQzVCLE9BQU8sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztnQkFDN0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxlQUFlLENBQUM7cUJBQzNCLE9BQU8sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBQzVELElBQUksRUFBRSxDQUFDO1lBQ1QsQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDO2FBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDLENBQUMsQ0FBQztJQUVILDZDQUE2QztJQUM3QyxpREFBaUQ7SUFDakQsK0JBQStCO0lBQy9CLEdBQUcsQ0FBQyw4Q0FBOEMsRUFBRSxJQUFJLENBQUMsRUFBRTtRQUN6RCxNQUFNLElBQUksR0FBRyx5QkFBeUIsQ0FBQztRQUN2QyxNQUFNLElBQUksR0FBRyxzQkFBc0IsQ0FBQztRQUVwQyx3Q0FBd0M7UUFDeEMsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEQsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7YUFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQ2xCLHFDQUFxQztZQUNyQyxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoRCxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztpQkFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNsQix1REFBdUQ7Z0JBQ3ZELEVBQUUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFO3FCQUNiLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDVixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzNDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsaUJBQWlCLENBQUM7eUJBQzlCLE9BQU8sQ0FDSixXQUFXLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztvQkFDMUQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQzt5QkFDL0IsT0FBTyxDQUFDLFdBQVcsQ0FBQyxrQkFBa0I7eUJBQ3pCLGtCQUFrQixDQUFDLENBQUM7b0JBQ3RDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsZ0JBQWdCLENBQUM7eUJBQzdCLE9BQU8sQ0FDSixXQUFXLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztvQkFDekQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxlQUFlLENBQUM7eUJBQzVCLE9BQU8sQ0FDSixXQUFXLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBQ3hELE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsaUJBQWlCLENBQUM7eUJBQzlCLE9BQU8sQ0FDSixXQUFXLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztvQkFDMUQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQzt5QkFDL0IsT0FBTyxDQUFDLFdBQVcsQ0FBQyxrQkFBa0I7eUJBQ3pCLGtCQUFrQixDQUFDLENBQUM7b0JBQ3RDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsZ0JBQWdCLENBQUM7eUJBQzdCLE9BQU8sQ0FDSixXQUFXLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztvQkFDekQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxlQUFlLENBQUM7eUJBQzVCLE9BQU8sQ0FDSixXQUFXLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBQ3hELElBQUksRUFBRSxDQUFDO2dCQUNULENBQUMsQ0FBQztxQkFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzFDLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFFSCw2Q0FBNkM7SUFDN0MsaURBQWlEO0lBQ2pELCtCQUErQjtJQUMvQixHQUFHLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLEVBQUU7UUFDbkMsdUJBQXVCO1FBQ3ZCLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckUsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7YUFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQ2xCLDJDQUEyQztZQUMzQyxNQUFNLFFBQVEsR0FDVixFQUFFLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVELFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2lCQUNwQixJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ2xCLDJEQUEyRDtnQkFDM0QsMkNBQTJDO2dCQUUzQyx5REFBeUQ7Z0JBQ3pELDBDQUEwQztnQkFDMUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsNkJBQTZCLENBQUM7cUJBQzNDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRTtvQkFDbEIsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUU7eUJBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUNWLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDOzRCQUMvQix5QkFBeUI7eUJBQzFCLENBQUMsQ0FBQzt3QkFFSCxFQUFFLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyx5QkFBeUIsQ0FBQzs2QkFDdkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFOzRCQUNWLGtDQUFrQzs0QkFDbEMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUU7aUNBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dDQUNWLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dDQUNyQyxJQUFJLEVBQUUsQ0FBQzs0QkFDVCxDQUFDLENBQUM7aUNBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxDQUFDLENBQUM7NkJBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUNwQyxDQUFDLENBQUM7eUJBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxDQUFDLENBQUM7cUJBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUMxQyxDQUFDLENBQUM7aUJBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUMsQ0FBQyxDQUFDO0lBRUgsNkNBQTZDO0lBQzdDLGlEQUFpRDtJQUNqRCwrQkFBK0I7SUFDL0IsR0FBRyxDQUFDLHNDQUFzQyxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ2pELE1BQU0sSUFBSSxHQUFHLDRCQUE0QixDQUFDO1FBQzFDLE1BQU0sSUFBSSxHQUFHLHlCQUF5QixDQUFDO1FBQ3ZDLHVCQUF1QjtRQUN2QixNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoRCxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQzthQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDakIsdURBQXVEO1lBQ3ZELEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7aUJBQ3RCLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDaEIsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQzVCLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDM0MsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQzt5QkFDOUIsT0FBTyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO29CQUM5RCxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLGtCQUFrQixDQUFDO3lCQUMvQixPQUFPLENBQ0osVUFBVSxDQUFDLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDLENBQUM7b0JBQzFELE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsZ0JBQWdCLENBQUM7eUJBQzdCLE9BQU8sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztvQkFDN0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxlQUFlLENBQUM7eUJBQzVCLE9BQU8sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBQzVELE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsaUJBQWlCLENBQUM7eUJBQzlCLE9BQU8sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztvQkFDOUQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQzt5QkFDL0IsT0FBTyxDQUNKLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO29CQUMxRCxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLGdCQUFnQixDQUFDO3lCQUM3QixPQUFPLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLGdCQUFnQixDQUFDLENBQUM7b0JBQzdELE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsZUFBZSxDQUFDO3lCQUM1QixPQUFPLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxDQUFDO29CQUU1RCx3Q0FBd0M7b0JBQ3hDLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNoRCxRQUFRLENBQUMsSUFBSSxFQUFFO3lCQUNWLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTt3QkFDYixNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQzt3QkFDckQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7d0JBQ2pELE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7NkJBQ3BDLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO3dCQUMxQyxJQUFJLEVBQUUsQ0FBQztvQkFDVCxDQUFDLENBQUM7eUJBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDMUMsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUM7aUJBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUMsQ0FBQyxDQUFDO0lBRUgsNkNBQTZDO0lBQzdDLGlEQUFpRDtJQUNqRCwrQkFBK0I7SUFDL0IsR0FBRyxDQUFDLHNDQUFzQyxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ2pELE1BQU0sSUFBSSxHQUFHLDRCQUE0QixDQUFDO1FBQzFDLE1BQU0sSUFBSSxHQUFHLHlCQUF5QixDQUFDO1FBQ3ZDLHVCQUF1QjtRQUN2QixNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoRCxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQzthQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDakIsdURBQXVEO1lBQ3ZELEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7aUJBQ3RCLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDaEIsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQzVCLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFDekMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQzt5QkFDOUIsT0FBTyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO29CQUM5RCxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLGtCQUFrQixDQUFDO3lCQUMvQixPQUFPLENBQ0osVUFBVSxDQUFDLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDLENBQUM7b0JBQzFELE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsZ0JBQWdCLENBQUM7eUJBQzdCLE9BQU8sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztvQkFDN0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxlQUFlLENBQUM7eUJBQzVCLE9BQU8sQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBRTVELHdDQUF3QztvQkFDeEMsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2hELFFBQVEsQ0FBQyxJQUFJLEVBQUU7eUJBQ1YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO3dCQUNiLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3dCQUNyRCxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQzt3QkFDakQsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQzs2QkFDcEMsT0FBTyxDQUFDLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7d0JBQzFDLElBQUksRUFBRSxDQUFDO29CQUNULENBQUMsQ0FBQzt5QkFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7d0JBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxDQUFDO2dCQUNULENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDO2FBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyx3Q0FBd0MsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDOUQsTUFBTSxJQUFJLEdBQUcsWUFBWSxDQUFDO1FBQzFCLE1BQU0sSUFBSSxHQUFHLDRCQUE0QixDQUFDO1FBQzFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7YUFDdEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNYLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO2lCQUNkLE9BQU8sQ0FDSixzREFBc0Q7Z0JBQ3RELHdCQUF3QixDQUFDLENBQUM7WUFDbEMsSUFBSSxFQUFFLENBQUM7UUFDVCxDQUFDLENBQUMsQ0FBQztJQUNULENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSixFQUFFLENBQUMsNkNBQTZDLEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ25FLE1BQU0sSUFBSSxHQUFHLDRCQUE0QixDQUFDO1FBQzFDLE1BQU0sSUFBSSxHQUFHLFlBQVksQ0FBQztRQUMxQix1QkFBdUI7UUFDdkIsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEQsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7YUFDcEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2pCLHVEQUF1RDtZQUN2RCxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO2lCQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO1lBQzlELENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ1gsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUM7cUJBQ2QsT0FBTyxDQUNKLHNEQUFzRDtvQkFDdEQsNkJBQTZCLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxFQUFFLENBQUM7WUFDVCxDQUFDLENBQUMsQ0FBQztRQUNULENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLEVBQUUsQ0FBQyw2Q0FBNkMsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDbkUsTUFBTSxJQUFJLEdBQUcsNEJBQTRCLENBQUM7UUFDMUMsTUFBTSxJQUFJLEdBQUcsWUFBWSxDQUFDO1FBQzFCLHVCQUF1QjtRQUN2QixNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoRCxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQzthQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDakIsZ0VBQWdFO1lBQ2hFLGVBQWU7WUFDZixFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO2lCQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO1lBQzlELENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ1gsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUM7cUJBQ2QsT0FBTyxDQUNKLHNEQUFzRDtvQkFDdEQsNkJBQTZCLENBQUMsQ0FBQztnQkFFdkMsK0NBQStDO2dCQUMvQyxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRTtxQkFDYixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ1YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO29CQUN6QyxJQUFJLEVBQUUsQ0FBQztnQkFDVCxDQUFDLENBQUM7cUJBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUMxQyxDQUFDLENBQUMsQ0FBQztRQUNULENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLEVBQUUsQ0FBQyxvQ0FBb0MsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDMUQsNkRBQTZEO1FBQzdELEVBQUUsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQzthQUNuQixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDVixJQUFJLENBQUMsSUFBSSxDQUNMLDREQUE0RCxDQUFDLENBQUM7UUFDcEUsQ0FBQyxDQUFDO2FBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ1gsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUM7aUJBQ2QsT0FBTyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7WUFDbEUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9ELE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1RCxJQUFJLEVBQUUsQ0FBQztRQUNULENBQUMsQ0FBQyxDQUFDO0lBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLEVBQUUsQ0FBQyxxQ0FBcUMsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDM0QsNkRBQTZEO1FBQzdELEVBQUUsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLHFCQUFxQixDQUFDO2FBQ25DLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsb0RBQW9ELENBQUMsQ0FBQztRQUNsRSxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDWCxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztpQkFDZCxPQUFPLENBQ0osd0RBQXdELENBQUMsQ0FBQztZQUNsRSxJQUFJLEVBQUUsQ0FBQztRQUNULENBQUMsQ0FBQyxDQUFDO0lBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLEVBQUUsQ0FBQyx3Q0FBd0MsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDOUQsNkRBQTZEO1FBQzdELEVBQUUsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLHlCQUF5QixDQUFDO2FBQ3ZDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsb0RBQW9ELENBQUMsQ0FBQztRQUNsRSxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDWCxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztpQkFDZCxPQUFPLENBQ0osMkRBQTJELENBQUMsQ0FBQztZQUNyRSxJQUFJLEVBQUUsQ0FBQztRQUNULENBQUMsQ0FBQyxDQUFDO0lBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeEMsbURBQW1EO1FBQ25ELEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLHlCQUF5QixFQUFFLHlCQUF5QixDQUFDO2FBQ2hFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsbURBQW1ELENBQUMsQ0FBQztRQUNqRSxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDWCxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztpQkFDZCxPQUFPLENBQ0osMkRBQTJELENBQUMsQ0FBQztZQUNyRSxJQUFJLEVBQUUsQ0FBQztRQUNULENBQUMsQ0FBQyxDQUFDO0lBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLEVBQUUsQ0FBQyx5REFBeUQsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDL0UsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQzthQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDVixJQUFJLENBQUMsSUFBSSxDQUNMLGdFQUFnRSxDQUFDLENBQUM7UUFDeEUsQ0FBQyxDQUFDO2FBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ1gsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUM7aUJBQ2QsT0FBTyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7WUFDNUQsSUFBSSxFQUFFLENBQUM7UUFDVCxDQUFDLENBQUMsQ0FBQztJQUNULENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSixFQUFFLENBQUMseURBQXlELEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQy9FLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7YUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ1YsSUFBSSxDQUFDLElBQUksQ0FDTCxnRUFBZ0UsQ0FBQyxDQUFDO1FBQ3hFLENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNYLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO2lCQUNkLE9BQU8sQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1lBQzVELElBQUksRUFBRSxDQUFDO1FBQ1QsQ0FBQyxDQUFDLENBQUM7SUFDVCxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCAqIGFzIHRmIGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7Q0hST01FX0VOVlMsIGRlc2NyaWJlV2l0aEZsYWdzLCBydW5XaXRoTG9ja30gZnJvbSAnLi4vamFzbWluZV91dGlsJztcbmltcG9ydCB7ZGVsZXRlRGF0YWJhc2V9IGZyb20gJy4vaW5kZXhlZF9kYic7XG5pbXBvcnQge3B1cmdlTG9jYWxTdG9yYWdlQXJ0aWZhY3RzfSBmcm9tICcuL2xvY2FsX3N0b3JhZ2UnO1xuXG4vLyBEaXNhYmxlZCBmb3Igbm9uLUNocm9tZSBicm93c2VycyBkdWUgdG86XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy80MjdcbmRlc2NyaWJlV2l0aEZsYWdzKCdNb2RlbE1hbmFnZW1lbnQnLCBDSFJPTUVfRU5WUywgKCkgPT4ge1xuICAvLyBUZXN0IGRhdGEuXG4gIGNvbnN0IG1vZGVsVG9wb2xvZ3kxOiB7fSA9IHtcbiAgICAnY2xhc3NfbmFtZSc6ICdTZXF1ZW50aWFsJyxcbiAgICAna2VyYXNfdmVyc2lvbic6ICcyLjEuNCcsXG4gICAgJ2NvbmZpZyc6IFt7XG4gICAgICAnY2xhc3NfbmFtZSc6ICdEZW5zZScsXG4gICAgICAnY29uZmlnJzoge1xuICAgICAgICAna2VybmVsX2luaXRpYWxpemVyJzoge1xuICAgICAgICAgICdjbGFzc19uYW1lJzogJ1ZhcmlhbmNlU2NhbGluZycsXG4gICAgICAgICAgJ2NvbmZpZyc6IHtcbiAgICAgICAgICAgICdkaXN0cmlidXRpb24nOiAndW5pZm9ybScsXG4gICAgICAgICAgICAnc2NhbGUnOiAxLjAsXG4gICAgICAgICAgICAnc2VlZCc6IG51bGwsXG4gICAgICAgICAgICAnbW9kZSc6ICdmYW5fYXZnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ25hbWUnOiAnZGVuc2UnLFxuICAgICAgICAna2VybmVsX2NvbnN0cmFpbnQnOiBudWxsLFxuICAgICAgICAnYmlhc19yZWd1bGFyaXplcic6IG51bGwsXG4gICAgICAgICdiaWFzX2NvbnN0cmFpbnQnOiBudWxsLFxuICAgICAgICAnZHR5cGUnOiAnZmxvYXQzMicsXG4gICAgICAgICdhY3RpdmF0aW9uJzogJ2xpbmVhcicsXG4gICAgICAgICd0cmFpbmFibGUnOiB0cnVlLFxuICAgICAgICAna2VybmVsX3JlZ3VsYXJpemVyJzogbnVsbCxcbiAgICAgICAgJ2JpYXNfaW5pdGlhbGl6ZXInOiB7J2NsYXNzX25hbWUnOiAnWmVyb3MnLCAnY29uZmlnJzoge319LFxuICAgICAgICAndW5pdHMnOiAxLFxuICAgICAgICAnYmF0Y2hfaW5wdXRfc2hhcGUnOiBbbnVsbCwgM10sXG4gICAgICAgICd1c2VfYmlhcyc6IHRydWUsXG4gICAgICAgICdhY3Rpdml0eV9yZWd1bGFyaXplcic6IG51bGxcbiAgICAgIH1cbiAgICB9XSxcbiAgICAnYmFja2VuZCc6ICd0ZW5zb3JmbG93J1xuICB9O1xuICBjb25zdCB3ZWlnaHRTcGVjczE6IHRmLmlvLldlaWdodHNNYW5pZmVzdEVudHJ5W10gPSBbXG4gICAge1xuICAgICAgbmFtZTogJ2RlbnNlL2tlcm5lbCcsXG4gICAgICBzaGFwZTogWzMsIDFdLFxuICAgICAgZHR5cGU6ICdmbG9hdDMyJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZW5zZS9iaWFzJyxcbiAgICAgIHNoYXBlOiBbMV0sXG4gICAgICBkdHlwZTogJ2Zsb2F0MzInLFxuICAgIH1cbiAgXTtcbiAgY29uc3Qgd2VpZ2h0RGF0YTEgPSBuZXcgQXJyYXlCdWZmZXIoMTYpO1xuICBjb25zdCBhcnRpZmFjdHMxOiB0Zi5pby5Nb2RlbEFydGlmYWN0cyA9IHtcbiAgICBtb2RlbFRvcG9sb2d5OiBtb2RlbFRvcG9sb2d5MSxcbiAgICB3ZWlnaHRTcGVjczogd2VpZ2h0U3BlY3MxLFxuICAgIHdlaWdodERhdGE6IHdlaWdodERhdGExLFxuICB9O1xuXG4gIGJlZm9yZUVhY2goZG9uZSA9PiB7XG4gICAgcHVyZ2VMb2NhbFN0b3JhZ2VBcnRpZmFjdHMoKTtcbiAgICBkZWxldGVEYXRhYmFzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICBhZnRlckVhY2goZG9uZSA9PiB7XG4gICAgcHVyZ2VMb2NhbFN0b3JhZ2VBcnRpZmFjdHMoKTtcbiAgICBkZWxldGVEYXRhYmFzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBUT0RPKGNhaXMpOiBSZWVuYWJsZSB0aGlzIHRlc3Qgb25jZSB3ZSBmaXhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvMTE5OFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuXG4gIHhpdCgnTGlzdCBtb2RlbHM6IDAgcmVzdWx0JywgZG9uZSA9PiB7XG4gICAgLy8gQmVmb3JlIGFueSBtb2RlbCBpcyBzYXZlZCwgbGlzdE1vZGVscyBzaG91bGQgcmV0dXJuIGVtcHR5IHJlc3VsdC5cbiAgICB0Zi5pby5saXN0TW9kZWxzKClcbiAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICBleHBlY3Qob3V0KS50b0VxdWFsKHt9KTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVyci5zdGFjaykpO1xuICB9KTtcblxuICAvLyBUT0RPKGNhaXMpOiBSZWVuYWJsZSB0aGlzIHRlc3Qgb25jZSB3ZSBmaXhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvMTE5OFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuXG4gIHhpdCgnTGlzdCBtb2RlbHM6IDEgcmVzdWx0JywgZG9uZSA9PiB7XG4gICAgY29uc3QgdXJsID0gJ2xvY2Fsc3RvcmFnZTovL2Jhei9RdXhNb2RlbCc7XG4gICAgY29uc3QgaGFuZGxlciA9IHRmLmlvLmdldFNhdmVIYW5kbGVycyh1cmwpWzBdO1xuICAgIGhhbmRsZXIuc2F2ZShhcnRpZmFjdHMxKVxuICAgICAgICAudGhlbihzYXZlUmVzdWx0ID0+IHtcbiAgICAgICAgICAvLyBBZnRlciBzdWNjZXNzZnVsIHNhdmluZywgdGhlcmUgc2hvdWxkIGJlIG9uZSBtb2RlbC5cbiAgICAgICAgICB0Zi5pby5saXN0TW9kZWxzKClcbiAgICAgICAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICAgICAgICBleHBlY3QoT2JqZWN0LmtleXMob3V0KS5sZW5ndGgpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmxdLm1vZGVsVG9wb2xvZ3lUeXBlKVxuICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChzYXZlUmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mby5tb2RlbFRvcG9sb2d5VHlwZSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmxdLm1vZGVsVG9wb2xvZ3lCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ubW9kZWxUb3BvbG9neUJ5dGVzKTtcbiAgICAgICAgICAgICAgICBleHBlY3Qob3V0W3VybF0ud2VpZ2h0U3BlY3NCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ud2VpZ2h0U3BlY3NCeXRlcyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmxdLndlaWdodERhdGFCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ud2VpZ2h0RGF0YUJ5dGVzKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVyci5zdGFjaykpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IGRvbmUuZmFpbChlcnIuc3RhY2spKTtcbiAgfSk7XG5cbiAgLy8gVE9ETyhjYWlzKTogUmVlbmFibGUgdGhpcyB0ZXN0IG9uY2Ugd2UgZml4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzExOThcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhblxuICB4aXQoJ01hbmFnZXI6IExpc3QgbW9kZWxzOiAyIHJlc3VsdHMgaW4gMiBtZWRpdW1zJywgZG9uZSA9PiB7XG4gICAgY29uc3QgdXJsMSA9ICdsb2NhbHN0b3JhZ2U6Ly9RdXhNb2RlbCc7XG4gICAgY29uc3QgdXJsMiA9ICdpbmRleGVkZGI6Ly9RdXhNb2RlbCc7XG5cbiAgICAvLyBGaXJzdCwgc2F2ZSBhIG1vZGVsIGluIExvY2FsIFN0b3JhZ2UuXG4gICAgY29uc3QgaGFuZGxlcjEgPSB0Zi5pby5nZXRTYXZlSGFuZGxlcnModXJsMSlbMF07XG4gICAgaGFuZGxlcjEuc2F2ZShhcnRpZmFjdHMxKVxuICAgICAgICAudGhlbihzYXZlUmVzdWx0MSA9PiB7XG4gICAgICAgICAgLy8gVGhlbiwgc2F2ZSB0aGUgbW9kZWwgaW4gSW5kZXhlZERCLlxuICAgICAgICAgIGNvbnN0IGhhbmRsZXIyID0gdGYuaW8uZ2V0U2F2ZUhhbmRsZXJzKHVybDIpWzBdO1xuICAgICAgICAgIGhhbmRsZXIyLnNhdmUoYXJ0aWZhY3RzMSlcbiAgICAgICAgICAgICAgLnRoZW4oc2F2ZVJlc3VsdDIgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgc2F2aW5nLCB0aGVyZSBzaG91bGQgYmUgdHdvIG1vZGVscy5cbiAgICAgICAgICAgICAgICB0Zi5pby5saXN0TW9kZWxzKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoT2JqZWN0LmtleXMob3V0KS5sZW5ndGgpLnRvRXF1YWwoMik7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmwxXS5tb2RlbFRvcG9sb2d5VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlUmVzdWx0MS5tb2RlbEFydGlmYWN0c0luZm8ubW9kZWxUb3BvbG9neVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMV0ubW9kZWxUb3BvbG9neUJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChzYXZlUmVzdWx0MS5tb2RlbEFydGlmYWN0c0luZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tb2RlbFRvcG9sb2d5Qnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMV0ud2VpZ2h0U3BlY3NCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlUmVzdWx0MS5tb2RlbEFydGlmYWN0c0luZm8ud2VpZ2h0U3BlY3NCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmwxXS53ZWlnaHREYXRhQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVJlc3VsdDEubW9kZWxBcnRpZmFjdHNJbmZvLndlaWdodERhdGFCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmwyXS5tb2RlbFRvcG9sb2d5VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlUmVzdWx0Mi5tb2RlbEFydGlmYWN0c0luZm8ubW9kZWxUb3BvbG9neVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMl0ubW9kZWxUb3BvbG9neUJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChzYXZlUmVzdWx0Mi5tb2RlbEFydGlmYWN0c0luZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tb2RlbFRvcG9sb2d5Qnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMl0ud2VpZ2h0U3BlY3NCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlUmVzdWx0Mi5tb2RlbEFydGlmYWN0c0luZm8ud2VpZ2h0U3BlY3NCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmwyXS53ZWlnaHREYXRhQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVJlc3VsdDIubW9kZWxBcnRpZmFjdHNJbmZvLndlaWdodERhdGFCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGRvbmUuZmFpbChlcnIuc3RhY2spKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBkb25lLmZhaWwoZXJyLnN0YWNrKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVyci5zdGFjaykpO1xuICB9KTtcblxuICAvLyBUT0RPKGNhaXMpOiBSZWVuYWJsZSB0aGlzIHRlc3Qgb25jZSB3ZSBmaXhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvMTE5OFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuXG4gIHhpdCgnU3VjY2Vzc2Z1bCByZW1vdmVNb2RlbCcsIGRvbmUgPT4ge1xuICAgIC8vIEZpcnN0LCBzYXZlIGEgbW9kZWwuXG4gICAgY29uc3QgaGFuZGxlcjEgPSB0Zi5pby5nZXRTYXZlSGFuZGxlcnMoJ2xvY2Fsc3RvcmFnZTovL1F1eE1vZGVsJylbMF07XG4gICAgaGFuZGxlcjEuc2F2ZShhcnRpZmFjdHMxKVxuICAgICAgICAudGhlbihzYXZlUmVzdWx0MSA9PiB7XG4gICAgICAgICAgLy8gVGhlbiwgc2F2ZSB0aGUgbW9kZWwgdW5kZXIgYW5vdGhlciBwYXRoLlxuICAgICAgICAgIGNvbnN0IGhhbmRsZXIyID1cbiAgICAgICAgICAgICAgdGYuaW8uZ2V0U2F2ZUhhbmRsZXJzKCdpbmRleGVkZGI6Ly9yZXBlYXQvUXV4TW9kZWwnKVswXTtcbiAgICAgICAgICBoYW5kbGVyMi5zYXZlKGFydGlmYWN0czEpXG4gICAgICAgICAgICAgIC50aGVuKHNhdmVSZXN1bHQyID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBZnRlciBzdWNjZXNzZnVsIHNhdmluZywgZGVsZXRlIHRoZSBmaXJzdCBzYXZlLCBhbmQgdGhlblxuICAgICAgICAgICAgICAgIC8vIGBsaXN0TW9kZWxgIHNob3VsZCBnaXZlIG9ubHkgb25lIHJlc3VsdC5cblxuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBhIG1vZGVsIHNwZWNpZmllZCB3aXRoIGEgcGF0aCB0aGF0IGluY2x1ZGVzIHRoZVxuICAgICAgICAgICAgICAgIC8vIGluZGV4ZWRkYjovLyBzY2hlbWUgcHJlZml4IHNob3VsZCB3b3JrLlxuICAgICAgICAgICAgICAgIHRmLmlvLnJlbW92ZU1vZGVsKCdpbmRleGVkZGI6Ly9yZXBlYXQvUXV4TW9kZWwnKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihkZWxldGVkSW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgdGYuaW8ubGlzdE1vZGVscygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG91dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKG91dCkpLnRvRXF1YWwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xvY2Fsc3RvcmFnZTovL1F1eE1vZGVsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGYuaW8ucmVtb3ZlTW9kZWwoJ2xvY2Fsc3RvcmFnZTovL1F1eE1vZGVsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVsZXRlIHRoZSByZW1haW5pbmcgbW9kZWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGYuaW8ubGlzdE1vZGVscygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG91dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKG91dCkpLnRvRXF1YWwoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBkb25lLmZhaWwoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGRvbmUuZmFpbChlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBkb25lLmZhaWwoZXJyLnN0YWNrKSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVyci5zdGFjaykpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IGRvbmUuZmFpbChlcnIuc3RhY2spKTtcbiAgfSk7XG5cbiAgLy8gVE9ETyhjYWlzKTogUmVlbmFibGUgdGhpcyB0ZXN0IG9uY2Ugd2UgZml4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzExOThcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhblxuICB4aXQoJ1N1Y2Nlc3NmdWwgY29weU1vZGVsIGJldHdlZW4gbWVkaXVtcycsIGRvbmUgPT4ge1xuICAgIGNvbnN0IHVybDEgPSAnbG9jYWxzdG9yYWdlOi8vYTEvRm9vTW9kZWwnO1xuICAgIGNvbnN0IHVybDIgPSAnaW5kZXhlZGRiOi8vYTEvRm9vTW9kZWwnO1xuICAgIC8vIEZpcnN0LCBzYXZlIGEgbW9kZWwuXG4gICAgY29uc3QgaGFuZGxlcjEgPSB0Zi5pby5nZXRTYXZlSGFuZGxlcnModXJsMSlbMF07XG4gICAgaGFuZGxlcjEuc2F2ZShhcnRpZmFjdHMxKVxuICAgICAgICAudGhlbihzYXZlUmVzdWx0ID0+IHtcbiAgICAgICAgICAvLyBPbmNlIG1vZGVsIGlzIHNhdmVkLCBjb3B5IHRoZSBtb2RlbCB0byBhbm90aGVyIHBhdGguXG4gICAgICAgICAgdGYuaW8uY29weU1vZGVsKHVybDEsIHVybDIpXG4gICAgICAgICAgICAgIC50aGVuKG1vZGVsSW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgdGYuaW8ubGlzdE1vZGVscygpLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhvdXQpLmxlbmd0aCkudG9FcXVhbCgyKTtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMV0ubW9kZWxUb3BvbG9neVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ubW9kZWxUb3BvbG9neVR5cGUpO1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmwxXS5tb2RlbFRvcG9sb2d5Qnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVSZXN1bHQubW9kZWxBcnRpZmFjdHNJbmZvLm1vZGVsVG9wb2xvZ3lCeXRlcyk7XG4gICAgICAgICAgICAgICAgICBleHBlY3Qob3V0W3VybDFdLndlaWdodFNwZWNzQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ud2VpZ2h0U3BlY3NCeXRlcyk7XG4gICAgICAgICAgICAgICAgICBleHBlY3Qob3V0W3VybDFdLndlaWdodERhdGFCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChzYXZlUmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mby53ZWlnaHREYXRhQnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmwyXS5tb2RlbFRvcG9sb2d5VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChzYXZlUmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mby5tb2RlbFRvcG9sb2d5VHlwZSk7XG4gICAgICAgICAgICAgICAgICBleHBlY3Qob3V0W3VybDJdLm1vZGVsVG9wb2xvZ3lCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ubW9kZWxUb3BvbG9neUJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMl0ud2VpZ2h0U3BlY3NCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChzYXZlUmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mby53ZWlnaHRTcGVjc0J5dGVzKTtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMl0ud2VpZ2h0RGF0YUJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHNhdmVSZXN1bHQubW9kZWxBcnRpZmFjdHNJbmZvLndlaWdodERhdGFCeXRlcyk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIGNvcHkgYW5kIHZlcmlmeSB0aGUgY29udGVudC5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIyID0gdGYuaW8uZ2V0TG9hZEhhbmRsZXJzKHVybDIpWzBdO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlcjIubG9hZCgpXG4gICAgICAgICAgICAgICAgICAgICAgLnRoZW4obG9hZGVkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChsb2FkZWQubW9kZWxUb3BvbG9neSkudG9FcXVhbChtb2RlbFRvcG9sb2d5MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QobG9hZGVkLndlaWdodFNwZWNzKS50b0VxdWFsKHdlaWdodFNwZWNzMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QobmV3IFVpbnQ4QXJyYXkobG9hZGVkLndlaWdodERhdGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKG5ldyBVaW50OEFycmF5KHdlaWdodERhdGExKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGRvbmUuZmFpbChlcnIuc3RhY2spKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBkb25lLmZhaWwoZXJyLnN0YWNrKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVyci5zdGFjaykpO1xuICB9KTtcblxuICAvLyBUT0RPKGNhaXMpOiBSZWVuYWJsZSB0aGlzIHRlc3Qgb25jZSB3ZSBmaXhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvMTE5OFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuXG4gIHhpdCgnU3VjY2Vzc2Z1bCBtb3ZlTW9kZWwgYmV0d2VlbiBtZWRpdW1zJywgZG9uZSA9PiB7XG4gICAgY29uc3QgdXJsMSA9ICdsb2NhbHN0b3JhZ2U6Ly9hMS9Gb29Nb2RlbCc7XG4gICAgY29uc3QgdXJsMiA9ICdpbmRleGVkZGI6Ly9hMS9Gb29Nb2RlbCc7XG4gICAgLy8gRmlyc3QsIHNhdmUgYSBtb2RlbC5cbiAgICBjb25zdCBoYW5kbGVyMSA9IHRmLmlvLmdldFNhdmVIYW5kbGVycyh1cmwxKVswXTtcbiAgICBoYW5kbGVyMS5zYXZlKGFydGlmYWN0czEpXG4gICAgICAgIC50aGVuKHNhdmVSZXN1bHQgPT4ge1xuICAgICAgICAgIC8vIE9uY2UgbW9kZWwgaXMgc2F2ZWQsIG1vdmUgdGhlIG1vZGVsIHRvIGFub3RoZXIgcGF0aC5cbiAgICAgICAgICB0Zi5pby5tb3ZlTW9kZWwodXJsMSwgdXJsMilcbiAgICAgICAgICAgICAgLnRoZW4obW9kZWxJbmZvID0+IHtcbiAgICAgICAgICAgICAgICB0Zi5pby5saXN0TW9kZWxzKCkudGhlbihvdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKG91dCkpLnRvRXF1YWwoW3VybDJdKTtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChvdXRbdXJsMl0ubW9kZWxUb3BvbG9neVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ubW9kZWxUb3BvbG9neVR5cGUpO1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KG91dFt1cmwyXS5tb2RlbFRvcG9sb2d5Qnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVSZXN1bHQubW9kZWxBcnRpZmFjdHNJbmZvLm1vZGVsVG9wb2xvZ3lCeXRlcyk7XG4gICAgICAgICAgICAgICAgICBleHBlY3Qob3V0W3VybDJdLndlaWdodFNwZWNzQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8ud2VpZ2h0U3BlY3NCeXRlcyk7XG4gICAgICAgICAgICAgICAgICBleHBlY3Qob3V0W3VybDJdLndlaWdodERhdGFCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChzYXZlUmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mby53ZWlnaHREYXRhQnl0ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBjb3B5IGFuZCB2ZXJpZnkgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyMiA9IHRmLmlvLmdldExvYWRIYW5kbGVycyh1cmwyKVswXTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXIyLmxvYWQoKVxuICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGxvYWRlZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QobG9hZGVkLm1vZGVsVG9wb2xvZ3kpLnRvRXF1YWwobW9kZWxUb3BvbG9neTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGxvYWRlZC53ZWlnaHRTcGVjcykudG9FcXVhbCh3ZWlnaHRTcGVjczEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KG5ldyBVaW50OEFycmF5KGxvYWRlZC53ZWlnaHREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbChuZXcgVWludDhBcnJheSh3ZWlnaHREYXRhMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lLmZhaWwoZXJyLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBkb25lLmZhaWwoZXJyLnN0YWNrKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVyci5zdGFjaykpO1xuICB9KTtcblxuICBpdCgnRmFpbGVkIGNvcHlNb2RlbCB0byBpbnZhbGlkIHNvdXJjZSBVUkwnLCBydW5XaXRoTG9jayhkb25lID0+IHtcbiAgICBjb25zdCB1cmwxID0gJ2ludmFsaWR1cmwnO1xuICAgIGNvbnN0IHVybDIgPSAnbG9jYWxzdG9yYWdlOi8vYTEvRm9vTW9kZWwnO1xuICAgIHRmLmlvLmNvcHlNb2RlbCh1cmwxLCB1cmwyKVxuICAgICAgICAudGhlbihvdXQgPT4ge1xuICAgICAgICAgIGRvbmUuZmFpbCgnQ29weWluZyBmcm9tIGludmFsaWQgVVJMIHN1Y2NlZWRlZCB1bmV4cGVjdGVkbHkuJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGV4cGVjdChlcnIubWVzc2FnZSlcbiAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAnQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBsb2FkIGhhbmRsZXIgaXMgZm91bmQgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgJ3NvdXJjZSBVUkwgaW52YWxpZHVybC4nKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICB9KSk7XG5cbiAgaXQoJ0ZhaWxlZCBjb3B5TW9kZWwgdG8gaW52YWxpZCBkZXN0aW5hdGlvbiBVUkwnLCBydW5XaXRoTG9jayhkb25lID0+IHtcbiAgICBjb25zdCB1cmwxID0gJ2xvY2Fsc3RvcmFnZTovL2ExL0Zvb01vZGVsJztcbiAgICBjb25zdCB1cmwyID0gJ2ludmFsaWR1cmwnO1xuICAgIC8vIEZpcnN0LCBzYXZlIGEgbW9kZWwuXG4gICAgY29uc3QgaGFuZGxlcjEgPSB0Zi5pby5nZXRTYXZlSGFuZGxlcnModXJsMSlbMF07XG4gICAgaGFuZGxlcjEuc2F2ZShhcnRpZmFjdHMxKVxuICAgICAgICAudGhlbihzYXZlUmVzdWx0ID0+IHtcbiAgICAgICAgICAvLyBPbmNlIG1vZGVsIGlzIHNhdmVkLCBjb3B5IHRoZSBtb2RlbCB0byBhbm90aGVyIHBhdGguXG4gICAgICAgICAgdGYuaW8uY29weU1vZGVsKHVybDEsIHVybDIpXG4gICAgICAgICAgICAgIC50aGVuKG91dCA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZS5mYWlsKCdDb3B5aW5nIHRvIGludmFsaWQgVVJMIHN1Y2NlZWRlZCB1bmV4cGVjdGVkbHkuJyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGV4cGVjdChlcnIubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBzYXZlIGhhbmRsZXIgaXMgZm91bmQgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rlc3RpbmF0aW9uIFVSTCBpbnZhbGlkdXJsLicpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4gZG9uZS5mYWlsKGVyci5zdGFjaykpO1xuICB9KSk7XG5cbiAgaXQoJ0ZhaWxlZCBtb3ZlTW9kZWwgdG8gaW52YWxpZCBkZXN0aW5hdGlvbiBVUkwnLCBydW5XaXRoTG9jayhkb25lID0+IHtcbiAgICBjb25zdCB1cmwxID0gJ2xvY2Fsc3RvcmFnZTovL2ExL0Zvb01vZGVsJztcbiAgICBjb25zdCB1cmwyID0gJ2ludmFsaWR1cmwnO1xuICAgIC8vIEZpcnN0LCBzYXZlIGEgbW9kZWwuXG4gICAgY29uc3QgaGFuZGxlcjEgPSB0Zi5pby5nZXRTYXZlSGFuZGxlcnModXJsMSlbMF07XG4gICAgaGFuZGxlcjEuc2F2ZShhcnRpZmFjdHMxKVxuICAgICAgICAudGhlbihzYXZlUmVzdWx0ID0+IHtcbiAgICAgICAgICAvLyBPbmNlIG1vZGVsIGlzIHNhdmVkLCBjb3B5IHRoZSBtb2RlbCB0byBhbiBpbnZhbGlkIHBhdGgsIHdoaWNoXG4gICAgICAgICAgLy8gc2hvdWxkIGZhaWwuXG4gICAgICAgICAgdGYuaW8ubW92ZU1vZGVsKHVybDEsIHVybDIpXG4gICAgICAgICAgICAgIC50aGVuKG91dCA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZS5mYWlsKCdDb3B5aW5nIHRvIGludmFsaWQgVVJMIHN1Y2NlZWRlZCB1bmV4cGVjdGVkbHkuJyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGV4cGVjdChlcnIubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBzYXZlIGhhbmRsZXIgaXMgZm91bmQgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rlc3RpbmF0aW9uIFVSTCBpbnZhbGlkdXJsLicpO1xuXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNvdXJjZSBoYXMgbm90IGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICB0Zi5pby5saXN0TW9kZWxzKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoT2JqZWN0LmtleXMob3V0KSkudG9FcXVhbChbdXJsMV0pO1xuICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBkb25lLmZhaWwoZXJyLnN0YWNrKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IGRvbmUuZmFpbChlcnIuc3RhY2spKTtcbiAgfSkpO1xuXG4gIGl0KCdGYWlsZWQgZGVsZXRlZE1vZGVsOiBBYnNlbnQgc2NoZW1lJywgcnVuV2l0aExvY2soZG9uZSA9PiB7XG4gICAgLy8gQXR0ZW1wdCB0byBkZWxldGUgYSBub25leGlzdGVudCBtb2RlbCBpcyBleHBlY3RlZCB0byBmYWlsLlxuICAgIHRmLmlvLnJlbW92ZU1vZGVsKCdmb28nKVxuICAgICAgICAudGhlbihvdXQgPT4ge1xuICAgICAgICAgIGRvbmUuZmFpbChcbiAgICAgICAgICAgICAgJ1JlbW92aW5nIG1vZGVsIHdpdGggbWlzc2luZyBzY2hlbWUgc3VjY2VlZGVkIHVuZXhwZWN0ZWRseS4nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAudG9NYXRjaCgvVGhlIHVybCBzdHJpbmcgcHJvdmlkZWQgZG9lcyBub3QgY29udGFpbiBhIHNjaGVtZS8pO1xuICAgICAgICAgIGV4cGVjdChlcnIubWVzc2FnZS5pbmRleE9mKCdsb2NhbHN0b3JhZ2UnKSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgIGV4cGVjdChlcnIubWVzc2FnZS5pbmRleE9mKCdpbmRleGVkZGInKSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gIH0pKTtcblxuICBpdCgnRmFpbGVkIGRlbGV0ZWRNb2RlbDogSW52YWxpZCBzY2hlbWUnLCBydW5XaXRoTG9jayhkb25lID0+IHtcbiAgICAvLyBBdHRlbXB0IHRvIGRlbGV0ZSBhIG5vbmV4aXN0ZW50IG1vZGVsIGlzIGV4cGVjdGVkIHRvIGZhaWwuXG4gICAgdGYuaW8ucmVtb3ZlTW9kZWwoJ2ludmFsaWRzY2hlbWU6Ly9mb28nKVxuICAgICAgICAudGhlbihvdXQgPT4ge1xuICAgICAgICAgIGRvbmUuZmFpbCgnUmVtb3Zpbmcgbm9uZXhpc3RlbnQgbW9kZWwgc3VjY2VlZGVkIHVuZXhwZWN0ZWRseS4nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAudG9FcXVhbChcbiAgICAgICAgICAgICAgICAgICdDYW5ub3QgZmluZCBtb2RlbCBtYW5hZ2VyIGZvciBzY2hlbWUgXFwnaW52YWxpZHNjaGVtZVxcJycpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gIH0pKTtcblxuICBpdCgnRmFpbGVkIGRlbGV0ZWRNb2RlbDogTm9uZXhpc3RlbnQgbW9kZWwnLCBydW5XaXRoTG9jayhkb25lID0+IHtcbiAgICAvLyBBdHRlbXB0IHRvIGRlbGV0ZSBhIG5vbmV4aXN0ZW50IG1vZGVsIGlzIGV4cGVjdGVkIHRvIGZhaWwuXG4gICAgdGYuaW8ucmVtb3ZlTW9kZWwoJ2luZGV4ZWRkYjovL25vbmV4aXN0ZW50JylcbiAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICBkb25lLmZhaWwoJ1JlbW92aW5nIG5vbmV4aXN0ZW50IG1vZGVsIHN1Y2NlZWRlZCB1bmV4cGVjdGVkbHkuJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGV4cGVjdChlcnIubWVzc2FnZSlcbiAgICAgICAgICAgICAgLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgICAnQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoIFxcJ25vbmV4aXN0ZW50XFwnIGluIEluZGV4ZWREQi4nKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICB9KSk7XG5cbiAgaXQoJ0ZhaWxlZCBjb3B5TW9kZWwnLCBydW5XaXRoTG9jayhkb25lID0+IHtcbiAgICAvLyBBdHRlbXB0IHRvIGNvcHkgYSBub25leGlzdGVudCBtb2RlbCBzaG91bGQgZmFpbC5cbiAgICB0Zi5pby5jb3B5TW9kZWwoJ2luZGV4ZWRkYjovL25vbmV4aXN0ZW50JywgJ2luZGV4ZWRkYjovL2Rlc3RpbmF0aW9uJylcbiAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICBkb25lLmZhaWwoJ0NvcHlpbmcgbm9uZXhpc3RlbnQgbW9kZWwgc3VjY2VlZGVkIHVuZXhwZWN0ZWRseS4nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAudG9FcXVhbChcbiAgICAgICAgICAgICAgICAgICdDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggXFwnbm9uZXhpc3RlbnRcXCcgaW4gSW5kZXhlZERCLicpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gIH0pKTtcblxuICBpdCgnY29weU1vZGVsOiBJZGVudGljYWwgb2xkUGF0aCBhbmQgbmV3UGF0aCBsZWFkcyB0byBFcnJvcicsIHJ1bldpdGhMb2NrKGRvbmUgPT4ge1xuICAgIHRmLmlvLmNvcHlNb2RlbCgnYS8xJywgJ2EvMScpXG4gICAgICAgIC50aGVuKG91dCA9PiB7XG4gICAgICAgICAgZG9uZS5mYWlsKFxuICAgICAgICAgICAgICAnQ29weWluZyB3aXRoIGlkZW50aWNhbCBvbGQgJiBuZXcgcGF0aHMgc3VjY2VlZGVkIHVuZXhwZWN0ZWRseS4nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAudG9FcXVhbCgnT2xkIHBhdGggYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZTogXFwnYS8xXFwnJyk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgfSkpO1xuXG4gIGl0KCdtb3ZlTW9kZWw6IElkZW50aWNhbCBvbGRQYXRoIGFuZCBuZXdQYXRoIGxlYWRzIHRvIEVycm9yJywgcnVuV2l0aExvY2soZG9uZSA9PiB7XG4gICAgdGYuaW8ubW92ZU1vZGVsKCdhLzEnLCAnYS8xJylcbiAgICAgICAgLnRoZW4ob3V0ID0+IHtcbiAgICAgICAgICBkb25lLmZhaWwoXG4gICAgICAgICAgICAgICdDb3B5aW5nIHdpdGggaWRlbnRpY2FsIG9sZCAmIG5ldyBwYXRocyBzdWNjZWVkZWQgdW5leHBlY3RlZGx5LicpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpXG4gICAgICAgICAgICAgIC50b0VxdWFsKCdPbGQgcGF0aCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lOiBcXCdhLzFcXCcnKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICB9KSk7XG59KTtcbiJdfQ==