/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../../engine';
import { SparseFillEmptyRows } from '../../kernel_names';
import { convertToTensor } from '../../tensor_util_env';
import { op } from '../operation';
/**
 * The input SparseTensor is represented via the map of inputs {`indices`,
 * `values`, `denseShape`}. The output SparseTensor has the same `denseShape`
 * but with indices `outputIndices` and values `outputValues`. This op inserts a
 * single entry for every row that doesn't have any values. The index is created
 * as `[row, 0, ..., 0]` and the inserted value is `defaultValue`.
 *
 * For example, suppose `spInput` has shape [5, 6] and non-empty values:
 * [0, 1]: a
 * [0, 3]: b
 * [2, 0]: c
 * [3, 1]: d
 *
 * Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values:
 * [0, 1]: a
 * [0, 3]: b
 * [1, 0]: `defaultValue`
 * [2, 0]: c
 * [3, 1]: d
 * [4, 0]: `defaultValue`
 *
 * The output SparseTensor will be in row-major order and will have the same
 * shape as the input.
 *
 * This op also returns an indicator vector shaped [dense_shape[0]] such that
 * emptyRowIndicator[i] = True iff row i was an empty row.
 *
 * And a reverse index map vector shaped [indices.shape[0]] that is used during
 * backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] ==
 * outputIndices[outi, j] for all j
 *
 * ```js
 * const result = tf.sparse.sparseFillEmptyRows(
 *   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],
 *   [0, 10, 13, 14, 32, 33], [5, 6], -1);
 * console.log(result);
 * result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],
 *                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]
 * result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]
 * result['emptyRowIndicator'].print(); // [false, false, true, false, true]
 * result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]
 * ```
 * @param indices: 2-D. the indices of the sparse tensor.
 * @param values: 1-D. the values of the sparse tensor.
 * @param denseShape: 1-D. the shape of the sparse tensor.
 * @param defaultValue: 0-D. default value to insert into location [row, 0, ...,
 *     0] for rows missing from the input sparse tensor.
 * @return A map with the following properties:
 *     - outputIndices
 *     - outputValues: 1-D. the values of the filled sparse tensor.
 *     - emptyRowIndicator: 1-D. whether the dense row was missing in the input
 * sparse tensor.
 *     - reverseIndexMap: 1-D. a map from the input indices to the output
 * indices.
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */
function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
    const $indices = convertToTensor(indices, 'indices', 'sparseFillEmptyRows');
    const $values = convertToTensor(values, 'values', 'sparseFillEmptyRows');
    const $denseShape = convertToTensor(denseShape, 'denseShape', 'sparseFillEmptyRows');
    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseFillEmptyRows', $values.dtype);
    if ($indices.rank !== 2) {
        throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
    }
    if ($values.rank !== 1) {
        throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
    }
    if ($denseShape.rank !== 1) {
        throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
    }
    if ($defaultValue.rank !== 0) {
        throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
    }
    const inputs = {
        indices: $indices,
        values: $values,
        denseShape: $denseShape,
        defaultValue: $defaultValue
    };
    const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);
    return {
        outputIndices: result[0],
        outputValues: result[1],
        emptyRowIndicator: result[2],
        reverseIndexMap: result[3]
    };
}
export const sparseFillEmptyRows = op({ sparseFillEmptyRows_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX2ZpbGxfZW1wdHlfcm93cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NwYXJzZS9zcGFyc2VfZmlsbF9lbXB0eV9yb3dzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFDLG1CQUFtQixFQUE0QixNQUFNLG9CQUFvQixDQUFDO0FBR2xGLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdURHO0FBQ0gsU0FBUyxvQkFBb0IsQ0FDekIsT0FBNEIsRUFBRSxNQUEyQixFQUN6RCxVQUErQixFQUMvQixZQUErQjtJQUNqQyxNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBQzVFLE1BQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLHFCQUFxQixDQUFDLENBQUM7SUFDekUsTUFBTSxXQUFXLEdBQ2IsZUFBZSxDQUFDLFVBQVUsRUFBRSxZQUFZLEVBQUUscUJBQXFCLENBQUMsQ0FBQztJQUNyRSxNQUFNLGFBQWEsR0FBRyxlQUFlLENBQ2pDLFlBQVksRUFBRSxjQUFjLEVBQUUscUJBQXFCLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXhFLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQztVQUNWLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQ3pCO0lBQ0QsSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtRQUN0QixNQUFNLElBQUksS0FBSyxDQUNYLGdEQUFnRCxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUN0RTtJQUNELElBQUksV0FBVyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFDWixXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUMxQjtJQUNELElBQUksYUFBYSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFDWixhQUFhLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUM1QjtJQUVELE1BQU0sTUFBTSxHQUE4QjtRQUN4QyxPQUFPLEVBQUUsUUFBUTtRQUNqQixNQUFNLEVBQUUsT0FBTztRQUNmLFVBQVUsRUFBRSxXQUFXO1FBQ3ZCLFlBQVksRUFBRSxhQUFhO0tBQzVCLENBQUM7SUFFRixNQUFNLE1BQU0sR0FBYSxNQUFNLENBQUMsU0FBUyxDQUFDLG1CQUFtQixFQUFFLE1BQVksQ0FBQyxDQUFDO0lBQzdFLE9BQU87UUFDTCxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN4QixZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN2QixpQkFBaUIsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzVCLGVBQWUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQzNCLENBQUM7QUFDSixDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sbUJBQW1CLEdBQUcsRUFBRSxDQUFDLEVBQUMsb0JBQW9CLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vLi4vZW5naW5lJztcbmltcG9ydCB7U3BhcnNlRmlsbEVtcHR5Um93cywgU3BhcnNlRmlsbEVtcHR5Um93c0lucHV0c30gZnJvbSAnLi4vLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7U2NhbGFyLCBUZW5zb3IsIFRlbnNvcjFELCBUZW5zb3IyRH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7TmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uLy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7U2NhbGFyTGlrZSwgVGVuc29yTGlrZX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBUaGUgaW5wdXQgU3BhcnNlVGVuc29yIGlzIHJlcHJlc2VudGVkIHZpYSB0aGUgbWFwIG9mIGlucHV0cyB7YGluZGljZXNgLFxuICogYHZhbHVlc2AsIGBkZW5zZVNoYXBlYH0uIFRoZSBvdXRwdXQgU3BhcnNlVGVuc29yIGhhcyB0aGUgc2FtZSBgZGVuc2VTaGFwZWBcbiAqIGJ1dCB3aXRoIGluZGljZXMgYG91dHB1dEluZGljZXNgIGFuZCB2YWx1ZXMgYG91dHB1dFZhbHVlc2AuIFRoaXMgb3AgaW5zZXJ0cyBhXG4gKiBzaW5nbGUgZW50cnkgZm9yIGV2ZXJ5IHJvdyB0aGF0IGRvZXNuJ3QgaGF2ZSBhbnkgdmFsdWVzLiBUaGUgaW5kZXggaXMgY3JlYXRlZFxuICogYXMgYFtyb3csIDAsIC4uLiwgMF1gIGFuZCB0aGUgaW5zZXJ0ZWQgdmFsdWUgaXMgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogRm9yIGV4YW1wbGUsIHN1cHBvc2UgYHNwSW5wdXRgIGhhcyBzaGFwZSBbNSwgNl0gYW5kIG5vbi1lbXB0eSB2YWx1ZXM6XG4gKiBbMCwgMV06IGFcbiAqIFswLCAzXTogYlxuICogWzIsIDBdOiBjXG4gKiBbMywgMV06IGRcbiAqXG4gKiBSb3dzIDEgYW5kIDQgYXJlIGVtcHR5LCBzbyB0aGUgb3V0cHV0IHdpbGwgYmUgb2Ygc2hhcGUgWzUsIDZdIHdpdGggdmFsdWVzOlxuICogWzAsIDFdOiBhXG4gKiBbMCwgM106IGJcbiAqIFsxLCAwXTogYGRlZmF1bHRWYWx1ZWBcbiAqIFsyLCAwXTogY1xuICogWzMsIDFdOiBkXG4gKiBbNCwgMF06IGBkZWZhdWx0VmFsdWVgXG4gKlxuICogVGhlIG91dHB1dCBTcGFyc2VUZW5zb3Igd2lsbCBiZSBpbiByb3ctbWFqb3Igb3JkZXIgYW5kIHdpbGwgaGF2ZSB0aGUgc2FtZVxuICogc2hhcGUgYXMgdGhlIGlucHV0LlxuICpcbiAqIFRoaXMgb3AgYWxzbyByZXR1cm5zIGFuIGluZGljYXRvciB2ZWN0b3Igc2hhcGVkIFtkZW5zZV9zaGFwZVswXV0gc3VjaCB0aGF0XG4gKiBlbXB0eVJvd0luZGljYXRvcltpXSA9IFRydWUgaWZmIHJvdyBpIHdhcyBhbiBlbXB0eSByb3cuXG4gKlxuICogQW5kIGEgcmV2ZXJzZSBpbmRleCBtYXAgdmVjdG9yIHNoYXBlZCBbaW5kaWNlcy5zaGFwZVswXV0gdGhhdCBpcyB1c2VkIGR1cmluZ1xuICogYmFja3Byb3BhZ2F0aW9uLCByZXZlcnNlSW5kZXhNYXBbaV0gPSBvdXRpIHMudC4gaW5kaWNlc1tpLCBqXSA9PVxuICogb3V0cHV0SW5kaWNlc1tvdXRpLCBqXSBmb3IgYWxsIGpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcmVzdWx0ID0gdGYuc3BhcnNlLnNwYXJzZUZpbGxFbXB0eVJvd3MoXG4gKiAgIFtbMCwgMF0sIFsxLCAwXSwgWzEsIDNdLCBbMSwgNF0sIFszLCAyXSwgWzMsIDNdXSxcbiAqICAgWzAsIDEwLCAxMywgMTQsIDMyLCAzM10sIFs1LCA2XSwgLTEpO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIHJlc3VsdFsnb3V0cHV0SW5kaWNlcyddLnByaW50KCk7IC8vIFtbMCwgMF0sIFsxLCAwXSwgWzEsIDNdLCBbMSwgNF0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgWzIsIDBdLCBbMywgMl0sIFszLCAzXSwgWzQsIDBdXVxuICogcmVzdWx0WydvdXRwdXRWYWx1ZXMnXS5wcmludCgpOyAvLyBbMCwgMTAsIDEzLCAxNCwtMSwgMzIsIDMzLCAtMV1cbiAqIHJlc3VsdFsnZW1wdHlSb3dJbmRpY2F0b3InXS5wcmludCgpOyAvLyBbZmFsc2UsIGZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZV1cbiAqIHJlc3VsdFsncmV2ZXJzZUluZGV4TWFwJ10ucHJpbnQoKTsgLy8gWzAsIDEsIDIsIDMsIDUsIDZdXG4gKiBgYGBcbiAqIEBwYXJhbSBpbmRpY2VzOiAyLUQuIHRoZSBpbmRpY2VzIG9mIHRoZSBzcGFyc2UgdGVuc29yLlxuICogQHBhcmFtIHZhbHVlczogMS1ELiB0aGUgdmFsdWVzIG9mIHRoZSBzcGFyc2UgdGVuc29yLlxuICogQHBhcmFtIGRlbnNlU2hhcGU6IDEtRC4gdGhlIHNoYXBlIG9mIHRoZSBzcGFyc2UgdGVuc29yLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZTogMC1ELiBkZWZhdWx0IHZhbHVlIHRvIGluc2VydCBpbnRvIGxvY2F0aW9uIFtyb3csIDAsIC4uLixcbiAqICAgICAwXSBmb3Igcm93cyBtaXNzaW5nIGZyb20gdGhlIGlucHV0IHNwYXJzZSB0ZW5zb3IuXG4gKiBAcmV0dXJuIEEgbWFwIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogICAgIC0gb3V0cHV0SW5kaWNlc1xuICogICAgIC0gb3V0cHV0VmFsdWVzOiAxLUQuIHRoZSB2YWx1ZXMgb2YgdGhlIGZpbGxlZCBzcGFyc2UgdGVuc29yLlxuICogICAgIC0gZW1wdHlSb3dJbmRpY2F0b3I6IDEtRC4gd2hldGhlciB0aGUgZGVuc2Ugcm93IHdhcyBtaXNzaW5nIGluIHRoZSBpbnB1dFxuICogc3BhcnNlIHRlbnNvci5cbiAqICAgICAtIHJldmVyc2VJbmRleE1hcDogMS1ELiBhIG1hcCBmcm9tIHRoZSBpbnB1dCBpbmRpY2VzIHRvIHRoZSBvdXRwdXRcbiAqIGluZGljZXMuXG4gKiBAZG9jIHtoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdTcGFyc2UnfVxuICovXG5mdW5jdGlvbiBzcGFyc2VGaWxsRW1wdHlSb3dzXyhcbiAgICBpbmRpY2VzOiBUZW5zb3IyRHxUZW5zb3JMaWtlLCB2YWx1ZXM6IFRlbnNvcjFEfFRlbnNvckxpa2UsXG4gICAgZGVuc2VTaGFwZTogVGVuc29yMUR8VGVuc29yTGlrZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNjYWxhcnxTY2FsYXJMaWtlKTogTmFtZWRUZW5zb3JNYXAge1xuICBjb25zdCAkaW5kaWNlcyA9IGNvbnZlcnRUb1RlbnNvcihpbmRpY2VzLCAnaW5kaWNlcycsICdzcGFyc2VGaWxsRW1wdHlSb3dzJyk7XG4gIGNvbnN0ICR2YWx1ZXMgPSBjb252ZXJ0VG9UZW5zb3IodmFsdWVzLCAndmFsdWVzJywgJ3NwYXJzZUZpbGxFbXB0eVJvd3MnKTtcbiAgY29uc3QgJGRlbnNlU2hhcGUgPVxuICAgICAgY29udmVydFRvVGVuc29yKGRlbnNlU2hhcGUsICdkZW5zZVNoYXBlJywgJ3NwYXJzZUZpbGxFbXB0eVJvd3MnKTtcbiAgY29uc3QgJGRlZmF1bHRWYWx1ZSA9IGNvbnZlcnRUb1RlbnNvcihcbiAgICAgIGRlZmF1bHRWYWx1ZSwgJ2RlZmF1bHRWYWx1ZScsICdzcGFyc2VGaWxsRW1wdHlSb3dzJywgJHZhbHVlcy5kdHlwZSk7XG5cbiAgaWYgKCRpbmRpY2VzLnJhbmsgIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc2hvdWxkIGJlIFRlbnNvcjJEIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAkeyRpbmRpY2VzLnNoYXBlfWApO1xuICB9XG4gIGlmICgkdmFsdWVzLnJhbmsgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBWYWx1ZXMgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZSAkeyR2YWx1ZXMuc2hhcGV9YCk7XG4gIH1cbiAgaWYgKCRkZW5zZVNoYXBlLnJhbmsgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlbnNlIHNoYXBlIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGUgJHtcbiAgICAgICAgJGRlbnNlU2hhcGUuc2hhcGV9YCk7XG4gIH1cbiAgaWYgKCRkZWZhdWx0VmFsdWUucmFuayAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgYSBzY2FsYXIgYnV0IHJlY2VpdmVkIHNoYXBlICR7XG4gICAgICAgICRkZWZhdWx0VmFsdWUuc2hhcGV9YCk7XG4gIH1cblxuICBjb25zdCBpbnB1dHM6IFNwYXJzZUZpbGxFbXB0eVJvd3NJbnB1dHMgPSB7XG4gICAgaW5kaWNlczogJGluZGljZXMsXG4gICAgdmFsdWVzOiAkdmFsdWVzLFxuICAgIGRlbnNlU2hhcGU6ICRkZW5zZVNoYXBlLFxuICAgIGRlZmF1bHRWYWx1ZTogJGRlZmF1bHRWYWx1ZVxuICB9O1xuXG4gIGNvbnN0IHJlc3VsdDogVGVuc29yW10gPSBFTkdJTkUucnVuS2VybmVsKFNwYXJzZUZpbGxFbXB0eVJvd3MsIGlucHV0cyBhcyB7fSk7XG4gIHJldHVybiB7XG4gICAgb3V0cHV0SW5kaWNlczogcmVzdWx0WzBdLFxuICAgIG91dHB1dFZhbHVlczogcmVzdWx0WzFdLFxuICAgIGVtcHR5Um93SW5kaWNhdG9yOiByZXN1bHRbMl0sXG4gICAgcmV2ZXJzZUluZGV4TWFwOiByZXN1bHRbM11cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHNwYXJzZUZpbGxFbXB0eVJvd3MgPSBvcCh7c3BhcnNlRmlsbEVtcHR5Um93c199KTtcbiJdfQ==