/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,a){"object"==typeof exports&&"undefined"!=typeof module?a(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],a):a((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf,e.seedrandom)}(this,(function(e,a,t){"use strict";function n(e){if(e&&e.__esModule)return e;var a=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(a,t,n.get?n:{enumerable:!0,get:function(){return e[t]}})}})),a.default=e,a}var r=n(t),i=function(e,a){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,a){e.__proto__=a}||function(e,a){for(var t in a)a.hasOwnProperty(t)&&(e[t]=a[t])})(e,a)};function o(e,a,t,n){return new(t||(t=Promise))((function(r,i){function o(e){try{u(n.next(e))}catch(e){i(e)}}function s(e){try{u(n.throw(e))}catch(e){i(e)}}function u(e){var a;e.done?r(e.value):(a=e.value,a instanceof t?a:new t((function(e){e(a)}))).then(o,s)}u((n=n.apply(e,a||[])).next())}))}function s(e,a){var t,n,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,n&&(r=2&i[0]?n.return:i[0]?n.throw||((r=n.return)&&r.call(n),0):n.next)&&!(r=r.call(n,i[1])).done)return r;switch(n=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return o.label++,{value:i[1],done:!1};case 5:o.label++,n=i[1],i=[0];continue;case 7:i=o.ops.pop(),o.trys.pop();continue;default:if(!(r=o.trys,(r=r.length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){o=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){o.label=i[1];break}if(6===i[0]&&o.label<r[1]){o.label=r[1],r=i;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(i);break}r[2]&&o.ops.pop(),o.trys.pop();continue}i=a.call(e,o)}catch(e){i=[6,e],n=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}}function u(e){var a="function"==typeof Symbol&&Symbol.iterator,t=a&&e[a],n=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(a?"Object is not iterable.":"Symbol.iterator is not defined.")}function d(e,a){var t="function"==typeof Symbol&&e[Symbol.iterator];if(!t)return e;var n,r,i=t.call(e),o=[];try{for(;(void 0===a||a-- >0)&&!(n=i.next()).done;)o.push(n.value)}catch(e){r={error:e}}finally{try{n&&!n.done&&(t=i.return)&&t.call(i)}finally{if(r)throw r.error}}return o}function l(){for(var e=[],a=0;a<arguments.length;a++)e=e.concat(d(arguments[a]));return e}function p(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&a.util.assert("complex64"!==e.dtype,(function(){return t+" does not support complex64 tensors in the CPU backend."}))}))}var c=a.kernel_impls.whereImpl,f=function(e){function t(){var t=e.call(this)||this;return t.blockSize=48,t.firstUse=!0,t.data=new a.DataStorage(t,a.engine()),t}return function(e,a){function t(){this.constructor=e}i(e,a),e.prototype=null===a?Object.create(a):(t.prototype=a.prototype,new t)}(t,e),t.prototype.nextDataId=function(){return t.nextDataId++},t.prototype.write=function(e,t,n){this.firstUse&&(this.firstUse=!1,a.env().get("IS_NODE")&&a.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r},t.prototype.makeTensorInfo=function(e,t,n){var r;if("string"===t&&null!=n&&n.length>0&&a.util.isString(n[0])){var i=n.map((function(e){return a.util.encodeString(e)}));r=this.write(i,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}},t.prototype.refCount=function(e){return this.data.has(e)?this.data.get(e).refCount:0},t.prototype.incRef=function(e){this.data.get(e).refCount++},t.prototype.decRef=function(e){this.data.has(e)&&this.data.get(e).refCount--},t.prototype.move=function(e,a,t,n,r){this.data.set(e,{values:a,dtype:n,refCount:r})},t.prototype.numDataIds=function(){return this.data.numDataIds()},t.prototype.read=function(e){return o(this,void 0,void 0,(function(){return s(this,(function(a){return[2,this.readSync(e)]}))}))},t.prototype.readSync=function(e){var t=this.data.get(e),n=t.dtype,r=t.complexTensorInfos;if("complex64"===n){var i=this.readSync(r.real.dataId),o=this.readSync(r.imag.dataId);return a.backend_util.mergeRealAndImagArrays(i,o)}return this.data.get(e).values},t.prototype.bufferSync=function(e){var t=this.readSync(e.dataId),n=t;if("string"===e.dtype)try{n=t.map((function(e){return a.util.decodeString(e)}))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return a.buffer(e.shape,e.dtype,n)},t.prototype.makeOutput=function(e,t,n){var r=this.write(e,t,n);return a.engine().makeTensorFromDataId(r,t,n,this)},t.prototype.disposeData=function(e,a){if(void 0===a&&(a=!1),this.data.has(e)){if(this.data.get(e).refCount--,!a&&this.data.get(e).refCount>0)return!1;var t=this.data.get(e).complexTensorInfos;null!=t&&(this.disposeData(t.real.dataId,!0),this.disposeData(t.imag.dataId,!0)),this.data.delete(e)}return!0},t.prototype.disposeIntermediateTensorInfo=function(e){this.disposeData(e.dataId)},t.prototype.time=function(e){return o(this,void 0,void 0,(function(){var t;return s(this,(function(n){return t=a.util.now(),e(),[2,{kernelMs:a.util.now()-t}]}))}))},t.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},t.prototype.where=function(e){p([e],"where");var a=this.readSync(e.dataId);return c(e.shape,a)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.epsilon=function(){return e.prototype.epsilon.call(this)},t}(a.KernelBackend);function h(e){for(var a=new Float32Array(e.length),t=0;t<e.length;++t)a[t]=Math.abs(e[t]);return a}f.nextDataId=0;var m={kernelName:a.Abs,backendName:"cpu",kernelFunc:function(e){var t=e.inputs.x,n=e.backend;p(t,"abs");var r=new Float32Array(a.util.sizeFromShape(t.shape));return r=h(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function v(e){return function(t,n,r,i,o){var s=a.backend_util.assertAndGetBroadcastShape(t,n),u=s.length,d=a.util.computeStrides(s),l=a.util.sizeFromShape(s),p=a.util.getTypedArrayFromDType(o,l),c=t.length,f=n.length,h=a.util.computeStrides(t),m=a.util.computeStrides(n),v=a.backend_util.getBroadcastDims(t,s),k=a.backend_util.getBroadcastDims(n,s);if(v.length+k.length===0)for(var g=0;g<p.length;++g)p[g]=e(r[g%r.length],i[g%i.length]);else{var b=function(t){var n=a.util.indexToLoc(t,u,d),o=n.slice(-c);v.forEach((function(e){return o[e]=0}));var s=a.util.locToIndex(o,c,h),l=n.slice(-f);k.forEach((function(e){return l[e]=0}));var g=a.util.locToIndex(l,f,m);p[t]=e(r[s],i[g])};for(g=0;g<p.length;++g)b(g)}return[p,s]}}function k(e){var a=e.inputs,t=e.backend,n=a.real,r=a.imag,i=t.data.get(n.dataId).values,o=t.data.get(r.dataId).values,s=t.makeTensorInfo(n.shape,"complex64");return t.data.get(s.dataId).complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",o)},s}var g={kernelName:a.Complex,backendName:"cpu",kernelFunc:k};function b(e,t,n){if(void 0===n&&(n="float32"),"complex64"===n)return k({inputs:{real:b(e,t,"float32"),imag:b(e,t,"float32")},backend:e});var r=a.util.makeZerosTypedArray(a.util.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function I(e){var a=e.inputs,t=e.backend,n=a.x;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var y={kernelName:a.Identity,backendName:"cpu",kernelFunc:I};function N(e){var a=e.inputs,t=e.backend,n=a.input,r=t.data.get(n.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}var x={kernelName:a.Real,backendName:"cpu",kernelFunc:N};function T(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.dtype;if("complex64"===o){if("complex64"===i.dtype)return I({inputs:{x:i},backend:n});var s=b(n,i.shape,i.dtype),u=T({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),l=k({inputs:{real:u,imag:s},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(u),l}if("complex64"===i.dtype){var p=N({inputs:{input:i},backend:n}),l=T({inputs:{x:p},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(p),l}if(!a.util.hasEncodingLoss(i.dtype,o))return{dataId:(l=I({inputs:{x:i},backend:n})).dataId,shape:l.shape,dtype:o};if("int32"===o){var c=n.data.get(i.dataId).values,f=Int32Array.from(c);return n.makeTensorInfo(i.shape,"int32",f)}if("bool"===o){var h=n.data.get(i.dataId).values,m=a.util.toTypedArray([0],i.dtype),g=d(v((function(e,a){return e!==a?1:0}))(i.shape,[],h,m,"bool"),2),y=g[0],x=g[1];return n.makeTensorInfo(x,"bool",y)}throw new Error("Error in Cast: failed to cast "+i.dtype+" to "+o)}var S={kernelName:a.Cast,backendName:"cpu",kernelFunc:T};function F(e,t,n,r){return null==n?function(n){var i=n.inputs,o=n.backend,s=i.a,u=i.b,l=o;p([s,u],e);var c=l.data.get(s.dataId).values,f=l.data.get(u.dataId).values,h="string"===s.dtype?a.backend_util.fromUint8ToStringArray(c):c,m="string"===s.dtype?a.backend_util.fromUint8ToStringArray(f):f,v=r||s.dtype,k=d(t(s.shape,u.shape,h,m,v),2),g=k[0],b=k[1];return l.makeTensorInfo(b,v,g)}:function(e){var a=e.inputs,i=e.backend,o=a.a,s=a.b,u=i;if("complex64"===o.dtype||"complex64"===s.dtype){var l=T({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(l.dataId),c=p.complexTensorInfos.real,f=p.complexTensorInfos.imag,h=u.data.get(c.dataId).values,m=u.data.get(f.dataId).values,v=T({inputs:{x:s},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(v.dataId),b=g.complexTensorInfos.real,I=g.complexTensorInfos.imag,y=u.data.get(b.dataId).values,N=u.data.get(I.dataId).values,x=d(n(o.shape,s.shape,h,m,y,N),3),S=x[0],F=x[1],M=x[2],A=u.makeTensorInfo(M,"float32",S),w=u.makeTensorInfo(M,"float32",F),D=k({inputs:{real:A,imag:w},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(A),u.disposeIntermediateTensorInfo(w),D}var _=u.data.get(o.dataId).values,E=u.data.get(s.dataId).values,z=r||o.dtype,W=d(t(o.shape,s.shape,_,E,z),2),C=W[0];M=W[1];return u.makeTensorInfo(M,z,C)}}function M(e){return function(t,n,r,i,o,s){var u=a.backend_util.assertAndGetBroadcastShape(t,n),d=a.util.sizeFromShape(u),l=u.length,p=a.util.computeStrides(u),c=a.util.getTypedArrayFromDType("float32",d),f=a.util.getTypedArrayFromDType("float32",d),h=a.backend_util.getBroadcastDims(t,u),m=a.backend_util.getBroadcastDims(n,u),v=a.backend_util.mergeRealAndImagArrays(r,i),k=a.backend_util.mergeRealAndImagArrays(o,s),g=t.length,b=a.util.computeStrides(t),I=n.length,y=a.util.computeStrides(n);if(h.length+m.length===0)for(var N=0;N<c.length;N++){var x=N%v.length,T=N%k.length,S=e(v[2*x],v[2*x+1],k[2*T],k[2*T+1]);c[N]=S.real,f[N]=S.imag}else{var F=function(t){var n=a.util.indexToLoc(t,l,p),r=n.slice(-g);h.forEach((function(e){return r[e]=0}));var i=a.util.locToIndex(r,g,b),o=n.slice(-I);m.forEach((function(e){return o[e]=0}));var s=a.util.locToIndex(o,I,y),u=e(v[2*i],v[2*i+1],k[2*s],k[2*s+1]);c[t]=u.real,f[t]=u.imag};for(N=0;N<c.length;N++)F(N)}return[c,f,u]}}var A=v((function(e,a){return e+a})),w=M((function(e,a,t,n){return{real:e+t,imag:a+n}})),D=F(a.Add,A,w),_={kernelName:a.Add,backendName:"cpu",kernelFunc:D};function E(e,t,n,r,i){for(var o=a.util.sizeFromShape(r),s=a.util.makeZerosTypedArray(i,n),u=0;u<e.length;u++){var d=e[u];if(d<0)throw new Error("Input x must be non-negative!");d>=i||(s[d]+=o>0?t[u]:1)}return s}function z(e,t,n,r){void 0===r&&(r=!1);for(var i=e.shape[0],o=e.shape[1],s=a.buffer([i,n],t.dtype),u=0;u<i;u++)for(var d=0;d<o;d++){var l=e.get(u,d);if(l<0)throw new Error("Input x must be non-negative!");l>=n||(r?s.set(1,u,l):t.size>0?s.set(s.get(u,l)+t.get(u,d),u,l):s.set(s.get(u,l)+1,u,l))}return s}function W(e){return function(t,n,r){for(var i=a.util.getTypedArrayFromDType(n,t.length),o=0;o<t.length;++o)i[o]=e(t[o],r);return i}}function C(e,t,n){return function(r){var i=r.inputs,o=r.attrs,s=r.backend,u=i.x;if(p(u,e),"string"===u.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");for(var d=s,l=d.data.get(u.dataId).values,c=a.util.sizeFromShape(u.shape),f=n||u.dtype,h=a.util.getArrayFromDType(f,c),m=0;m<c;++m)h[m]=t(l[m],o);return d.makeTensorInfo(u.shape,f,h)}}function H(e,a,t){return function(n){var r=n.inputs,i=n.attrs,o=n.backend,s=r.x;if(p(s,e),"string"===s.dtype||"string"===t)throw new Error("unaryKernelFunc does not support string input/output");var u=o,d=u.data.get(s.dataId).values,l=t||s.dtype,c=a(d,l,i);return u.makeTensorInfo(s.shape,l,c)}}var P=W((function(e){return Math.ceil(e)})),R=H(a.Ceil,P),B={kernelName:a.Ceil,backendName:"cpu",kernelFunc:R};function O(e,t,n,r){var i=a.util.getArrayFromDType(n,a.util.sizeFromShape(t));if(r&&"string"!==n){var o=0;e.forEach((function(e){var t=a.util.sizeFromShape(e.shape);i.set(e.vals,o),o+=t}))}else{var s=0;e.forEach((function(e){for(var r="string"===n?a.backend_util.fromUint8ToStringArray(e.vals):e.vals,o=0,u=0;u<e.shape[0];++u)for(var d=u*t[1]+s,l=0;l<e.shape[1];++l)i[d+l]=r[o++];s+=e.shape[1]}))}return i}var G=v((function(e,a){return e===a?1:0})),q=F(a.Equal,G,null,"bool"),L={kernelName:a.Equal,backendName:"cpu",kernelFunc:q},V=W((function(e){return Math.exp(e)})),U=H(a.Exp,V,"float32"),j={kernelName:a.Exp,backendName:"cpu",kernelFunc:U},Z=W((function(e){return Math.expm1(e)})),K=H(a.Expm1,Z),Y={kernelName:a.Expm1,backendName:"cpu",kernelFunc:K},J=W((function(e){return Math.floor(e)})),Q=H(a.Floor,J),X={kernelName:a.Floor,backendName:"cpu",kernelFunc:Q};function $(e,t,n,r,i,o,s,u,d){for(var p=a.buffer([r,o],n),c=0;c<r;c++){for(var f=[],h=0,m=0;m<i;m++){var v=e[c*i+m];h+=v*s[m],f.push(v)}if(h<0||h>=d/o)throw new Error("Invalid indices: "+f+" does not index into "+u);for(var k=0;k<o;k++)p.values[c*o+k]=t.get.apply(t,l(t.indexToLoc(h*o+k)))}return p}function ee(e,t,n){for(var r=a.buffer(n,e.dtype),i=0;i<r.size;++i){var o=r.indexToLoc(i).slice(),s=o[0],u=o[2],d=t.locToIndex([s,u]);o[2]=t.values[d];var l=e.locToIndex(o);r.values[i]=e.values[l]}return r}var ae=v((function(e,a){return e>a?1:0})),te=F(a.Greater,ae,null,"bool"),ne={kernelName:a.Greater,backendName:"cpu",kernelFunc:te},re=v((function(e,a){return e>=a?1:0})),ie=F(a.GreaterEqual,re,null,"bool"),oe={kernelName:a.GreaterEqual,backendName:"cpu",kernelFunc:ie},se=v((function(e,a){return e<a?1:0})),ue=F(a.Less,se,null,"bool"),de={kernelName:a.Less,backendName:"cpu",kernelFunc:ue},le=v((function(e,a){return e<=a?1:0})),pe=F(a.LessEqual,le,null,"bool"),ce={kernelName:a.LessEqual,backendName:"cpu",kernelFunc:pe};function fe(e,t,n){var r=(t-e)/(n-1),i=a.util.makeZerosTypedArray(n,"float32");i[0]=e;for(var o=1;o<i.length;o++)i[o]=i[o-1]+r;return i}var he=W((function(e){return Math.log(e)})),me=H(a.Log,he),ve={kernelName:a.Log,backendName:"cpu",kernelFunc:me};function ke(e,t,n,r){for(var i=a.util.getTypedArrayFromDType(r,a.util.sizeFromShape(n)),o=0;o<i.length;++o){for(var s=o*t,u=e[s],d=0;d<t;++d){var l=e[s+d];(Number.isNaN(l)||l>u)&&(u=l)}i[o]=u}return i}var ge=v((function(e,a){return Math.max(e,a)})),be=F(a.Maximum,ge),Ie={kernelName:a.Maximum,backendName:"cpu",kernelFunc:be},ye=v((function(e,a){return Math.min(e,a)})),Ne=F(a.Minimum,ye),xe={kernelName:a.Minimum,backendName:"cpu",kernelFunc:Ne},Te=v((function(e,a){return e*a})),Se=M((function(e,a,t,n){return{real:e*t-a*n,imag:e*n+a*t}})),Fe=F(a.Multiply,Te,Se),Me={kernelName:a.Multiply,backendName:"cpu",kernelFunc:Fe};function Ae(e,t,n){var r=a.util.createScalarValue(-1,n);return Te([],t,r,e,n)}var we={kernelName:a.Neg,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.x;p(n,"neg");var r=d(Ae(t.data.get(n.dataId).values,n.shape,n.dtype),2),i=r[0],o=r[1];return t.makeTensorInfo(o,n.dtype,i)}},De=v((function(e,a){return e!==a?1:0})),_e=F(a.NotEqual,De,null,"bool"),Ee={kernelName:a.NotEqual,backendName:"cpu",kernelFunc:_e};function ze(e,t,n,r,i){for(var o=t.length,s=a.util.sizeFromShape(t),u=a.util.computeStrides(t),d=a.util.computeStrides(i),l=a.util.getTypedArrayFromDType(n,a.util.sizeFromShape(i)),p=0;p<s;++p){for(var c=a.util.indexToLoc(p,o,u),f=new Array(c.length),h=0;h<f.length;h++)f[h]=c[r[h]];l[a.util.locToIndex(f,o,d)]=e[p]}return l}function We(e){var a=e.inputs,t=e.attrs,n=e.backend,r=a.x,i=t.perm;p(r,"transpose");for(var o=r.shape.length,s=new Array(o),u=0;u<s.length;u++)s[u]=r.shape[i[u]];var d=ze(n.data.get(r.dataId).values,r.shape,r.dtype,i,s);return{dataId:n.write(d,s,r.dtype),shape:s,dtype:r.dtype}}var Ce={kernelName:a.Transpose,backendName:"cpu",kernelFunc:We};function He(e,t,n,r){for(var i=d(a.backend_util.computeOutAndReduceShapes(e,r),2),o=i[0],s=i[1],u=a.upcastType(t,"int32"),l=a.util.makeZerosTypedArray(a.util.sizeFromShape(o),u),p=a.util.sizeFromShape(s),c=0;c<l.length;++c){for(var f=c*p,h=1,m=0;m<p;++m)h*=n[f+m];l[c]=h}return{outVals:l,outShape:o,outDtype:u}}var Pe={kernelName:a.Prod,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,s=r.keepDims;p(i,"prod");var u=i.shape.length,d=a.util.parseAxisParam(o,i.shape),l=a.backend_util.getAxesPermutation(d,u),c=d,f=i,h=[];null!=l&&(f=We({inputs:{x:i},backend:n,attrs:{perm:l}}),h.push(f),c=a.backend_util.getInnerMostAxes(c.length,u));var m=n.data.get(f.dataId).values,v=He(f.shape,f.dtype,m,c),k=v.outVals,g=v.outShape,b=v.outDtype,I=g;return s&&(I=a.backend_util.expandShapeToKeepDim(g,d)),h.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.makeTensorInfo(I,b,k)}};function Re(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return a.util.makeZerosTypedArray(0,r);var i=Math.abs(Math.ceil((t-e)/n)),o=a.util.makeZerosTypedArray(i,r);t<e&&1===n&&(n=-1),o[0]=e;for(var s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var Be=W((function(e){return 1/Math.sqrt(e)})),Oe=H(a.Rsqrt,Be),Ge={kernelName:a.Rsqrt,backendName:"cpu",kernelFunc:Oe},qe=W((function(e){return 1/(1+Math.exp(-e))})),Le=C(a.Sigmoid,(function(e){return 1/(1+Math.exp(-e))})),Ve={kernelName:a.Sigmoid,backendName:"cpu",kernelFunc:Le};function Ue(e,t,n,r,i){var o=a.slice_util.isSliceContinous(r,t,n),s=a.util.sizeFromShape(n),u=a.util.computeStrides(r);if(o){var d=a.slice_util.computeFlatOffset(t,u);return"string"===i?e.slice(d,d+s):e.subarray(d,d+s)}for(var p="string"===i?a.backend_util.fromUint8ToStringArray(e):e,c=a.buffer(r,i,p),f=a.buffer(n,i),h=0;h<f.size;++h){var m=f.indexToLoc(h),v=m.map((function(e,a){return e+t[a]}));f.set.apply(f,l([c.get.apply(c,l(v))],m))}return"string"===i?a.backend_util.fromStringArrayToUint8(f.values):f.values}function je(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.begin,s=r.size;p(i,"slice");var u=d(a.slice_util.parseSliceParams(i,o,s),2),l=u[0],c=u[1];a.slice_util.assertParamsValid(i,l,c);var f=Ue(n.data.get(i.dataId).values,l,c,i.shape,i.dtype);return n.makeTensorInfo(c,i.dtype,f)}var Ze={kernelName:a.Slice,backendName:"cpu",kernelFunc:je};function Ke(e,t,n,r,i,o,s){var u=t[0],d=o[0],l=new Array(d),p=new Array(u),c=t[1];if(0===d){if(0!==u)throw new Error("Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = "+u);return[I=a.util.getArrayFromDType(n,0),[0,c],y=a.util.getArrayFromDType(i,0),l,p]}for(var f=!0,h=0,m=new Array(d).fill(0),v=0;v<u;++v){if((g=e[v*c])<0)throw new Error("indices("+v+", 0) is invalid: "+g+" < 0");if(g>=d)throw new Error("indices("+v+", 0) is invalid: "+g+" >= "+d);++m[g],f=f&&g>=h,h=g}for(var k=!0,g=0;g<d;++g){var b=0===m[g];l[g]=b,k=k&&!b,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(k&&f){var I=e,y=r;for(v=0;v<u;++v)p[v]=v;return[I,[u,c],y,l,p]}var N=m[d-1],x=(I=a.util.getArrayFromDType(n,N*c),y=a.util.getArrayFromDType(i,N),new Array(d).fill(0));for(v=0;v<u;++v){var T=x[g=e[v*c]],S=(0===g?0:m[g-1])+T;x[g]++;for(var F=0;F<c;++F)I[S*c+F]=e[v*c+F];y[S]=r[v],p[v]=S}for(g=0;g<d;++g){if(0===x[g]){var M=0===g?0:m[g-1];I[M*c+0]=g;for(var A=1;A<c;++A)I[M*c+A]=0;y[M]=s}}return[I,[N,c],y,l,p]}function Ye(e,t,n,r,i){for(var o=a.util.sizeFromShape(r),s=t[0],u=i.length,d=[],l=1,p=-1,c=0;c<u;++c){var f=i[c];if(-1===f){if(-1!==p)throw new Error("only one output dimension may be -1, not both "+p+" and "+c);p=c,d.push(1)}else{if(f<0)throw new Error("size "+c+" must be non-negative, not "+f);l*=f,d.push(f)}}if(-1!==p){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");var h=Math.trunc(o/l);if(l*h!==o)throw new Error("Input to reshape is a SparseTensor with "+o+"\n          dense values, but the requested shape requires a multiple of "+l+". inputShape="+r+" outputShape= "+d);d[p]=h}var m=a.util.sizeFromShape(d);if(m!==o)throw new Error("Input to reshape is a tensor with "+o+" dense values, but the requested shape has "+m+". inputShape="+r+" outputShape="+d);var v=r.length,k=[];if(v>0){k[v-1]=1;for(c=v-2;c>=0;--c)k[c]=k[c+1]*r[c+1]}var g=[];if(u>0){g[u-1]=1;for(c=u-2;c>=0;--c)g[c]=g[c+1]*d[c+1]}for(var b=a.util.getArrayFromDType(n,s*u),I=0;I<s;++I){for(var y=0,N=0;N<v;++N)y+=e[I*v+N]*k[N];for(N=0;N<u;++N)b[I*u+N]=Math.trunc(y/g[N]),y%=g[N]}return[b,[s,u],d]}function Je(e,t,n,r,i,o,s){void 0===o&&(o=!1),void 0===s&&(s=0);var u=r.length;if(u!==i.length)throw new Error("segmentIds and indices should have same size.");var d=[t[0],e.length/t[0]],l=d[1],p=u>0?i[u-1]+1:0;if(p<0)throw new Error("segment ids must be >= 0");var c=t.slice();c[0]=p;var f=c.reduce((function(e,a){return e*a}),1),h=a.util.getArrayFromDType(n,f);if(0===u)return p>0&&h.fill(s),[h,c];if(p<=0)throw new Error("segment ids must be >= 0");for(var m=0,v=1,k=0,g=i[m];;){var b=0;if(v<u){if(g===(b=i[v])){++v;continue}if(g>=b)throw new Error("segment ids are not increasing")}if(g<0||g>=p)throw new Error("Segment id "+g+" out of range [0, "+p+"), possibly because segmentIds input is not sorted.");g>k&&h.fill(s,k*l,g*l);for(var I=m;I<v;++I){var y=r[I];if(y<0||y>=d[0])throw new Error("Bad: indices["+I+"] == "+r[I]+" out of range [0, "+d[0]+")");for(var N=0;N<l;N++)h[g*l+N]+=e[y*l+N]}if(o)for(N=0;N<l;N++)h[g*l+N]/=v-m;if(m=v,k=g+1,g=b,++v>u)break}return k<p&&h.fill(s,k*l,p*l),[h,c]}var Qe=W((function(e){return Math.sqrt(e)})),Xe=C(a.Sqrt,(function(e){return Math.sqrt(e)})),$e={kernelName:a.Sqrt,backendName:"cpu",kernelFunc:Xe},ea=v((function(e,a){var t=e-a;return t*t})),aa=F(a.SquaredDifference,ea),ta={kernelName:a.SquaredDifference,backendName:"cpu",kernelFunc:aa};function na(e,t,n,r){for(var i=a.buffer(e,t.dtype),o=0;o<i.size;o++){for(var s=i.indexToLoc(o),u=new Array(s.length),d=0;d<u.length;d++)u[d]=s[d]*n[d]+r[d];i.set.apply(i,l([t.get.apply(t,l(u))],s))}return i}var ra=function(){function e(e,t,n,r,i,o){this.separator=a.util.encodeString(e),this.nGramWidths=t,this.leftPad=a.util.encodeString(n),this.rightPad=a.util.encodeString(r),this.padWidth=i,this.preserveShort=o}return e.prototype.getPadWidth=function(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)},e.prototype.getNumNGrams=function(e,a){var t=this.getPadWidth(a);return Math.max(0,e+2*t-a+1)},e.prototype.createNGrams=function(e,a,t,n,r,i){for(var o=function(o){var u=s.getPadWidth(i),d=Math.max(0,u-o),l=Math.max(0,u-(r-(o+1))),p=i-(d+l),c=a+(d>0?0:o-u),f=0;f+=d*s.leftPad.length;for(var h=0;h<p;++h)f+=e[c+h].length;f+=l*s.rightPad.length,f+=(d+l+p-1)*s.separator.length,t[n+o]=new Uint8Array(f);var m=t[n+o],v=0,k=function(e){return e.forEach((function(e){return m[v++]=e}))};for(h=0;h<d;++h)k(s.leftPad),k(s.separator);for(h=0;h<p-1;++h)k(e[c+h]),k(s.separator);if(p>0){k(e[c+p-1]);for(h=0;h<l;++h)k(s.separator),k(s.rightPad)}else{for(h=0;h<l-1;++h)k(s.rightPad),k(s.separator);k(s.rightPad)}},s=this,u=0;u<r;++u)o(u)},e.prototype.compute=function(e,t){var n=this,r=e.length,i=t.length;if(i>0){var o=t[0];if(0!==o)throw new Error("First split value must be 0, got "+o);for(var s=1;s<i;++s){var u=t[s]>=o;if(!(u=u&&t[s]<=r))throw new Error("Invalid split value "+t[s]+", must be in ["+o+", "+r+"]");o=t[s]}if(o!==r)throw new Error("Last split value must be data size. Expected "+r+", got "+o)}var d=i-1,l=a.util.getArrayFromDType("int32",i);if(0===r||0===i){var p=new Array(r);for(s=0;s<=d;++s)l[s]=0;return[p,l]}l[0]=0;var c=function(e){var a=t[e]-t[e-1],r=0;f.nGramWidths.forEach((function(e){r+=n.getNumNGrams(a,e)})),f.preserveShort&&a>0&&0===r&&(r=1),l[e]=l[e-1]+r},f=this;for(s=1;s<=d;++s)c(s);var h=new Array(l[d]),m=function(a){var r=t[a],i=l[a];if(v.nGramWidths.forEach((function(o){var s=t[a+1]-t[a],u=n.getNumNGrams(s,o);n.createNGrams(e,r,h,i,u,o),i+=u})),v.preserveShort&&i===l[a]){var o=t[a+1]-t[a];if(0===o)return"continue";var s=o+2*v.padWidth;v.createNGrams(e,r,h,i,1,s)}},v=this;for(s=0;s<d;++s)m(s);return[h,l]},e}();function ia(e,a,t,n,r,i,o,s){return new ra(t,n,r,i,o,s).compute(e,a)}function oa(e,a,t,n){if(e.length)if(0!==a.length)if(1!==a.length){var r=0;for(u=0;u<e.length+1;u++)if(u===e.length||-1!==a.indexOf(e[u])){s=e.subarray(r,u);t&&0===s.length||n.push(s),r=u+1}}else{for(var i=a[0],o=e.indexOf(i);-1!==o;){var s=e.subarray(0,o);t&&0===s.length||n.push(s),o=(e=e.subarray(o+1)).indexOf(i)}t&&0===e.length||n.push(e)}else for(var u=0;u<e.length;++u)n.push(e.subarray(u,u+1))}function sa(e,t,n){for(var r=e.length,i=[],o=0,s=0,u=new Array(r),d=0;d<r;++d){var l=i.length;oa(e[d],t,n,i);var p=i.length-l;u[d]=p,o+=p,s=Math.max(s,p)}var c=a.util.getArrayFromDType("int32",2*o),f=new Array(o),h=[r,s],m=0;for(d=0;d<r;++d)for(var v=0;v<u[d];++v)c[2*m]=d,c[2*m+1]=v,f[m]=i[m],++m;return[c,f,h]}function ua(e,t){for(var n=a.util.getArrayFromDType("int32",e.length),r=0;r<e.length;++r)n[r]=a.util.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var da=v((function(e,a){return e-a})),la=M((function(e,a,t,n){return{real:e-t,imag:a-n}})),pa=F(a.Sub,da,la),ca={kernelName:a.Sub,backendName:"cpu",kernelFunc:pa};function fa(e,t){for(var n=new Array(e.rank),r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];var i=a.buffer(n,e.dtype);for(r=0;r<i.values.length;++r){for(var o=i.indexToLoc(r),s=new Array(e.rank),u=0;u<s.length;u++)s[u]=o[u]%e.shape[u];var d=e.locToIndex(s);i.values[r]=e.values[d]}return i}var ha=function(e,a){var t=a.value-e.value;return 0===t?e.index-a.index:t};function ma(e,t,n,r){for(void 0===n&&(n=0),void 0===r&&(r=e.length-1);r>n;){if(r-n>600){var i=r-n+1,o=t-n+1,s=Math.log(i),u=.5*Math.exp(2*s/3),d=.5*Math.sqrt(s*u*(i-u)/i)*Math.sign(o-i/2);ma(e,t,Math.max(n,Math.floor(t-o*u/i+d)),Math.min(r,Math.floor(t+(i-o)*u/i+d)))}var l=e[t],p=n,c=r;for(a.util.swap(e,n,t),ha(e[r],l)>0&&a.util.swap(e,n,r);p<c;){for(a.util.swap(e,p,c),p++,c--;ha(e[p],l)<0;)p+=1;for(;ha(e[c],l)>0;)c-=1}0===ha(e[n],l)?a.util.swap(e,n,c):(c+=1,a.util.swap(e,c,r)),c<=t&&(n=c+1),t<=c&&(r=c-1)}}function va(e,t,n,r,i){for(var o=t[t.length-1],s=d([e.length/o,o],2),u=s[0],l=s[1],p=a.util.getTypedArrayFromDType(n,u*r),c=a.util.getTypedArrayFromDType("int32",u*r),f=function(a){var t=a*l,n=e.subarray(t,t+l),o=new Array(n.length);n.forEach((function(e,a){return o[a]={value:e,index:a}})),r<o.length&&(ma(o,r),o=o.slice(0,r)),i&&o.sort(ha);for(var s=a*r,u=p.subarray(s,s+r),d=c.subarray(s,s+r),f=0;f<r;f++)u[f]=o[f].value,d[f]=o[f].index},h=0;h<u;h++)f(h);var m=t.slice();return m[m.length-1]=r,[a.buffer(m,n,p),a.buffer(m,"int32",c)]}function ka(e,t,n,r){for(var i=a.util.parseAxisParam(t,n)[0],o=[1,n[0],1],s=0;s<i;s++)o[0]*=n[s];o[1]=n[i];for(s=i+1;s<n.length;s++)o[2]*=n[s];var u={},d=new Int32Array(n[i]),l=new a.TensorBuffer(o,r,e),p=[],c=1===o[0]&&1===o[2];for(s=0;s<n[i];s++){var f=void 0;if(c)f=e[s].toString();else{for(var h=[],m=0;m<o[0];m++)for(var v=0;v<o[2];v++)h.push(l.get(m,s,v));f=h.join(",")}if(void 0!==u[f])d[s]=u[f];else{var k=Object.keys(u).length;u[f]=k,d[s]=k,p.push(s)}}var g=o.slice();g[1]=Object.keys(u).length;var b=new a.TensorBuffer(g,r);p.forEach((function(e,a){for(var t=0;t<o[0];t++)for(var n=0;n<o[2];n++)b.set(l.get(t,e,n),t,a,n)}));var I=n.slice();return I[i]=g[1],{outputValues:b.values,outputShape:I,indices:d}}var ga={__proto__:null,simpleAbsImpl:h,addImpl:A,bincountImpl:E,bincountReduceImpl:z,ceilImpl:P,concatImpl:O,equalImpl:G,expImpl:V,expm1Impl:Z,floorImpl:J,gatherNdImpl:$,gatherV2Impl:ee,greaterImpl:ae,greaterEqualImpl:re,lessImpl:se,lessEqualImpl:le,linSpaceImpl:fe,logImpl:he,maxImpl:ke,maximumImpl:ge,minimumImpl:ye,multiplyImpl:Te,negImpl:Ae,notEqualImpl:De,prodImpl:He,rangeImpl:Re,rsqrtImpl:Be,sigmoidImpl:qe,sliceImpl:Ue,sparseFillEmptyRowsImpl:Ke,sparseReshapeImpl:Ye,sparseSegmentReductionImpl:Je,sqrtImpl:Qe,squaredDifferenceImpl:ea,stridedSliceImpl:na,stringNGramsImpl:ia,stringSplitImpl:sa,stringToHashBucketFastImpl:ua,subImpl:da,tileImpl:fa,topKImpl:va,transposeImpl:ze,uniqueImpl:ka};a.registerBackend("cpu",(function(){return new f}),1);var ba=C(a.Elu,(function(e){return e>=0?e:Math.exp(e)-1})),Ia={kernelName:a.Elu,backendName:"cpu",kernelFunc:ba};function ya(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.alpha;p([i],"leakyRelu");for(var s=a.util.sizeFromShape(i.shape),u=n.data.get(i.dataId).values,d=a.util.getTypedArrayFromDType("float32",s),l=0;l<u.length;l++)d[l]=u[l]<0?o*u[l]:u[l];return n.makeTensorInfo(i.shape,"float32",d)}var Na={kernelName:a.LeakyRelu,backendName:"cpu",kernelFunc:ya},xa=v((function(e,a){return e<0?a*e:e}));function Ta(e){var a=e.inputs,t=e.backend,n=a.x,r=a.alpha;p([n,r],"prelu");var i=t.data.get(n.dataId).values,o=t.data.get(r.dataId).values,s=d(xa(n.shape,r.shape,i,o,"float32"),2),u=s[0],l=s[1];return t.makeTensorInfo(l,"float32",u)}var Sa={kernelName:a.Prelu,backendName:"cpu",kernelFunc:Ta},Fa=C(a.Relu,(function(e){return Math.max(0,e)})),Ma={kernelName:a.Relu,backendName:"cpu",kernelFunc:Fa},Aa=C(a.Relu6,(function(e){return Math.min(Math.max(0,e),6)})),wa={kernelName:a.Relu6,backendName:"cpu",kernelFunc:Aa};function Da(e,a,t,n,r){if("linear"===t)return I({inputs:{x:a},backend:e});if("relu"===t)return Fa({inputs:{x:a},backend:e});if("elu"===t)return ba({inputs:{x:a},backend:e});if("relu6"===t)return Aa({inputs:{x:a},backend:e});if("prelu"===t)return Ta({inputs:{x:a,alpha:n},backend:e});if("leakyrelu"===t)return ya({inputs:{x:a},backend:e,attrs:{alpha:r}});if("sigmoid"===t)return Le({inputs:{x:a},backend:e});throw new Error("Activation "+t+" has not been implemented for the CPU backend.")}function _a(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.shape,s=a.util.sizeFromShape(i.shape),u=a.util.inferFromImplicitShape(o,s),d=a.util.sizeFromShape(u);a.util.assert(s===d,(function(){return"The new shape ("+u+") has "+d+" elements and the old shape ("+i.shape+") has "+s+" elements. The new shape and old shape must have the same number of elements."})),n.incRef(i.dataId);var l=n.data.get(i.dataId);if(null!=l.complexTensorInfos){var p=l.complexTensorInfos.real,c=l.complexTensorInfos.imag;p.shape=u,c.shape=u}return{dataId:i.dataId,shape:u,dtype:i.dtype}}var Ea={kernelName:a.Reshape,backendName:"cpu",kernelFunc:_a};function za(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.a,o=t.b,s=r.transposeA,u=r.transposeB;p([i,o],"matMul");var l=i.shape.length,c=o.shape.length,f=s?i.shape[l-2]:i.shape[l-1],h=u?o.shape[c-1]:o.shape[c-2],m=s?i.shape[l-1]:i.shape[l-2],v=u?o.shape[c-2]:o.shape[c-1],k=i.shape.slice(0,-2),g=o.shape.slice(0,-2),b=a.util.sizeFromShape(k),I=a.util.sizeFromShape(g),y=b===I||1===b||1===I;a.util.assert(l>=2&&c>=2&&y,(function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of ("+k+") and ("+g+")."}));var N=(b>I?i.shape.slice(0,-2):o.shape.slice(0,-2)).concat([m,v]);a.util.assert(f===h,(function(){return"Error in matMul: inner shapes ("+f+") and ("+h+") of Tensors with shapes "+i.shape+" and "+o.shape+" and transposeA="+s+" and transposeB="+u+" must match."}));for(var x=u?[I,v,h]:[I,h,v],T=_a({inputs:{x:i},backend:n,attrs:{shape:s?[b,f,m]:[b,m,f]}}),S=_a({inputs:{x:o},backend:n,attrs:{shape:x}}),F=s?T.shape[1]:T.shape[2],M=s?T.shape[2]:T.shape[1],A=u?S.shape[1]:S.shape[2],w=Math.max(b,I),D=n.data.get(T.dataId).values,_=n.data.get(S.dataId).values,E=a.util.computeStrides(T.shape),z=a.util.computeStrides(S.shape),W=d(s?[E[0],1,E[1]]:[E[0],E[1],1],3),C=W[0],H=W[1],P=W[2],R=d(u?[1,z[1],z[0]]:[z[1],1,z[0]],3),B=R[0],O=R[1],G=R[2],q=M*A,L=a.buffer([w,M,A],T.dtype),V=L.values,U=n.blockSize,j=0;j<w;j++)for(var Z=0;Z<M;Z+=U)for(var K=0;K<A;K+=U)for(var Y=0;Y<F;Y+=U)for(var J=Math.min(Z+U,M),Q=Math.min(K+U,A),X=Math.min(Y+U,F),$=Z;$<J;$++)for(var ee=K;ee<Q;ee++){for(var ae=0,te=Y;te<X;te++){var ne=Math.min(j,b-1)*C,re=Math.min(j,I-1)*G;ae+=D[ne+$*H+te*P]*_[te*B+ee*O+re]}V[j*q+($*A+ee)]+=ae}return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(S),n.makeTensorInfo(N,L.dtype,L.values)}var Wa={kernelName:a.BatchMatMul,backendName:"cpu",kernelFunc:za};var Ca={kernelName:a._FusedMatMul,backendName:"cpu",kernelFunc:function(e){var a,t,n,r,i,o=e.inputs,s=e.backend,d=e.attrs,l=o.a,p=o.b,c=o.bias,f=o.preluActivationWeights,h=d.transposeA,m=d.transposeB,v=d.activation,k=d.leakyreluAlpha,g=[];n=za({inputs:{a:l,b:p},attrs:{transposeA:h,transposeB:m},backend:s}),c&&(r=D({inputs:{a:n,b:c},backend:s}),g.push(n),n=r),v&&(i=Da(s,n,v,f,k),g.push(n),n=i);try{for(var b=u(g),I=b.next();!I.done;I=b.next()){var y=I.value;s.disposeIntermediateTensorInfo(y)}}catch(e){a={error:e}}finally{try{I&&!I.done&&(t=b.return)&&t.call(b)}finally{if(a)throw a.error}}return n}},Ha=C(a.Acos,(function(e){return Math.acos(e)})),Pa={kernelName:a.Acos,backendName:"cpu",kernelFunc:Ha},Ra=C(a.Acosh,(function(e){return Math.acosh(e)})),Ba={kernelName:a.Acosh,backendName:"cpu",kernelFunc:Ra};var Oa={kernelName:a.AddN,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t;p(t,"addN");for(var i=r.map((function(e){return n.data.get(e.dataId).values})),o=a.buffer(r[0].shape,r[0].dtype),s=o.values,u=0;u<r.length;u++)for(var d=i[u],l=0;l<s.length;l++)s[l]+=d[l];return n.makeTensorInfo(o.shape,o.dtype,o.values)}};var Ga={kernelName:a.All,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,s=r.keepDims;p(i,"all");var u=a.util.parseAxisParam(o,i.shape),l=u,c=a.backend_util.getAxesPermutation(l,i.shape.length),f=i;null!=c&&(f=We({inputs:{x:i},backend:n,attrs:{perm:c}}),l=a.backend_util.getInnerMostAxes(l.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("all",l,f.shape.length);for(var h=d(a.backend_util.computeOutAndReduceShapes(f.shape,l),2),m=h[0],v=h[1],k=a.util.sizeFromShape(v),g=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),b=n.data.get(f.dataId).values,I=0;I<g.length;++I){for(var y=I*k,N=b[y],x=0;x<k;++x){var T=b[y+x];N=N&&T}g[I]=N}null!=c&&n.disposeIntermediateTensorInfo(f);var S=n.makeTensorInfo(m,f.dtype,g);if(s){var F=_a({inputs:{x:S},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(m,u)}});return n.disposeIntermediateTensorInfo(S),F}return S}};var qa={kernelName:a.Any,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,s=r.keepDims;p(i,"any");var u=a.util.parseAxisParam(o,i.shape),l=u,c=a.backend_util.getAxesPermutation(l,i.shape.length),f=i;null!=c&&(f=We({inputs:{x:i},backend:n,attrs:{perm:c}}),l=a.backend_util.getInnerMostAxes(l.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("any",l,f.shape.length);for(var h=d(a.backend_util.computeOutAndReduceShapes(f.shape,l),2),m=h[0],v=h[1],k=a.util.sizeFromShape(v),g=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),b=n.data.get(f.dataId).values,I=0;I<g.length;++I){for(var y=I*k,N=b[y],x=0;x<k;++x){var T=b[y+x];N=N||T}g[I]=N}null!=c&&n.disposeIntermediateTensorInfo(f);var S=n.makeTensorInfo(m,f.dtype,g);if(s){var F=_a({inputs:{x:S},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(m,u)}});return n.disposeIntermediateTensorInfo(S),F}return S}};var La={kernelName:a.ArgMax,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis;p(i,"argMax");var s=a.util.parseAxisParam(o,i.shape),u=a.backend_util.getAxesPermutation(s,i.shape.length),l=i,c=[];null!=u&&(l=We({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),s=a.backend_util.getInnerMostAxes(s.length,l.shape.length)),s=[s[0]],a.backend_util.assertAxesAreInnerMostDims("argMax",s,l.shape.length);for(var f=d(a.backend_util.computeOutAndReduceShapes(l.shape,s),2),h=f[0],m=f[1],v=a.util.sizeFromShape(h),k=a.util.makeZerosTypedArray(v,"int32"),g=a.util.sizeFromShape(m),b=n.data.get(l.dataId).values,I=0;I<k.length;++I){for(var y=I*g,N=b[y],x=0,T=0;T<g;++T){var S=b[y+T];S>N&&(N=S,x=T)}k[I]=x}return c.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.makeTensorInfo(h,"int32",k)}};var Va={kernelName:a.ArgMin,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis;p(i,"argMin");var s=a.util.parseAxisParam(o,i.shape),u=a.backend_util.getAxesPermutation(s,i.shape.length),l=i,c=[];null!=u&&(l=We({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(l),s=a.backend_util.getInnerMostAxes(s.length,l.shape.length)),s=[s[0]],a.backend_util.assertAxesAreInnerMostDims("argMin",s,l.shape.length);for(var f=d(a.backend_util.computeOutAndReduceShapes(l.shape,s),2),h=f[0],m=f[1],v=a.util.sizeFromShape(h),k=a.util.makeZerosTypedArray(v,"int32"),g=a.util.sizeFromShape(m),b=n.data.get(l.dataId).values,I=0;I<k.length;++I){for(var y=I*g,N=b[y],x=0,T=0;T<g;++T){var S=b[y+T];S<N&&(N=S,x=T)}k[I]=x}return c.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.makeTensorInfo(h,"int32",k)}},Ua=C(a.Asin,(function(e){return Math.asin(e)})),ja={kernelName:a.Asin,backendName:"cpu",kernelFunc:Ua},Za=C(a.Asinh,(function(e){return Math.asinh(e)})),Ka={kernelName:a.Asinh,backendName:"cpu",kernelFunc:Za},Ya=C(a.Atan,(function(e){return Math.atan(e)})),Ja={kernelName:a.Atan,backendName:"cpu",kernelFunc:Ya},Qa=v((function(e,a){return Math.atan2(e,a)})),Xa=F(a.Atan2,Qa),$a={kernelName:a.Atan2,backendName:"cpu",kernelFunc:Xa},et=C(a.Atanh,(function(e){return Math.atanh(e)})),at={kernelName:a.Atanh,backendName:"cpu",kernelFunc:et};function tt(e,t,n,r,i,o){for(var s=i.strideHeight,u=i.strideWidth,d=i.dilationHeight,l=i.dilationWidth,p=i.effectiveFilterHeight,c=i.effectiveFilterWidth,f=i.padInfo.top,h=i.padInfo.left,m="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=a.buffer(i.outShape,n),k=v.values,g=i.outShape[1]*i.outShape[2]*i.outShape[3],b=i.outShape[2]*i.outShape[3],I=i.outShape[3],y=0;y<i.batchSize;++y)for(var N=y*g,x=y*r[0],T=0;T<i.inChannels;++T)for(var S=0;S<i.outHeight;++S)for(var F=S*s-f,M=Math.max(0,F),A=Math.min(i.inHeight,p+F),w=N+S*b,D=0;D<i.outWidth;++D){for(var _=D*u-h,E=Math.max(0,_),z=Math.min(i.inWidth,c+_),W=m,C=0,H=0,P=M;P<A;P+=d){for(var R=x+P*r[1],B=E;B<z;B+=l){var O=e[R+B*r[2]+T];"max"===o&&O>W?W=O:"avg"===o&&(C+=O,H++)}if(isNaN(W))break}k[w+D*I+T]="avg"===o?C/H:W}return v}function nt(e,t,n,r,i,o){void 0===i&&(i=!1),void 0===o&&(o=!1);for(var s=a.buffer(r.outShape,"int32"),u=r.strideHeight,d=r.strideWidth,l=r.dilationHeight,p=r.dilationWidth,c=r.effectiveFilterHeight,f=r.effectiveFilterWidth,h=r.padInfo.top,m=r.padInfo.left,v=a.buffer(t,n,e),k=0;k<r.batchSize;++k)for(var g=0;g<r.inChannels;++g)for(var b=0;b<r.outHeight;++b){for(var I=b*u-h,y=I;y<0;)y+=l;for(var N=Math.min(r.inHeight,c+I),x=0;x<r.outWidth;++x){for(var T=x*d-m,S=T;S<0;)S+=p;for(var F=Math.min(r.inWidth,f+T),M=Number.NEGATIVE_INFINITY,A=-1,w=y;w<N;w+=l)for(var D=w-I,_=S;_<F;_+=p){var E=_-T,z=v.get(k,w,_,g);z>M&&(M=z,A=i?o?((k*r.inHeight+w)*r.inWidth+_)*r.inChannels+g:(w*r.inWidth+_)*r.inChannels+g:D*f+E)}s.set(A,k,b,x,g)}}return s}function rt(e,t,n,r,i,o){for(var s=i.strideDepth,u=i.strideHeight,d=i.strideWidth,l=i.dilationDepth,p=i.dilationHeight,c=i.dilationWidth,f=i.effectiveFilterDepth,h=i.effectiveFilterHeight,m=i.effectiveFilterWidth,v=i.padInfo.front,k=i.padInfo.top,g=i.padInfo.left,b="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=a.buffer(i.outShape,n),y=I.values,N=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],x=i.outShape[2]*i.outShape[3]*i.outShape[4],T=i.outShape[3]*i.outShape[4],S=i.outShape[4],F=0;F<i.batchSize;++F)for(var M=F*N,A=F*r[0],w=0;w<i.inChannels;++w)for(var D=0;D<i.outDepth;++D){for(var _=D*s-v,E=_;E<0;)E+=l;for(var z=Math.min(i.inDepth,f+_),W=M+D*x,C=0;C<i.outHeight;++C){for(var H=C*u-k,P=H;P<0;)P+=p;for(var R=Math.min(i.inHeight,h+H),B=W+C*T,O=0;O<i.outWidth;++O){for(var G=O*d-g,q=G;q<0;)q+=c;for(var L=Math.min(i.inWidth,m+G),V=B+O*S,U=b,j=0,Z=0,K=E;K<z;K+=l){for(var Y=A+K*r[1],J=P;J<R;J+=p){for(var Q=Y+J*r[2],X=q;X<L;X+=c){var $=e[Q+X*r[3]+w];if("max"===o&&$>U?U=$:"avg"===o&&(j+=$,Z++),isNaN(U))break}if(isNaN(U))break}if(isNaN(U))break}y[V+w]="avg"===o?j/Z:U}}}return I}var it={kernelName:a.AvgPool,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x;p(i,"avgPool");var o=r.filterSize,s=r.strides,u=r.pad,d=r.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(s,1),(function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+s+" and dilations '1'"}));var l,c=a.backend_util.computePool2DInfo(i.shape,o,s,1,u,d);if(1===c.filterWidth&&1===c.filterHeight&&a.util.arraysEqual(c.inShape,c.outShape))l=I({inputs:{x:i},backend:n});else{var f=n.data.get(i.dataId).values,h=a.util.computeStrides(i.shape),m=tt(f,i.shape,i.dtype,h,c,"avg");l=n.makeTensorInfo(c.outShape,i.dtype,m.values)}return l}};var ot={kernelName:a.AvgPool3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.filterSize,s=r.strides,u=r.pad,d=r.dimRoundingMode,l=r.dataFormat;p(i,"avgPool3d");var c=a.backend_util.computePool3DInfo(i.shape,o,s,1,u,d,l),f=rt(n.data.get(i.dataId).values,i.shape,i.dtype,a.util.computeStrides(i.shape),c,"avg");return n.makeTensorInfo(f.shape,"float32",f.values)}};var st={kernelName:a.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,s=r.filterSize,u=r.strides,d=r.pad,l=r.dimRoundingMode;p([i,o],"avgPool3DGrad");for(var c=a.backend_util.computePool3DInfo(o.shape,s,u,1,d,l),f=c.strideDepth,h=c.strideHeight,m=c.strideWidth,v=c.filterDepth,k=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,I=c.dilationHeight,y=c.dilationWidth,N=c.effectiveFilterDepth,x=c.effectiveFilterHeight,T=c.effectiveFilterWidth,S=N-1-c.padInfo.front,F=T-1-c.padInfo.left,M=x-1-c.padInfo.top,A=a.buffer(o.shape,"float32"),w=1/(v*k*g),D=n.bufferSync(i),_=0;_<c.batchSize;++_)for(var E=0;E<c.inChannels;++E)for(var z=0;z<c.inDepth;++z)for(var W=0;W<c.inHeight;++W)for(var C=0;C<c.inWidth;++C){for(var H=z-S,P=W-M,R=C-F,B=0,O=0;O<N;O+=b){var G=(H+O)/f;if(!(G<0||G>=c.outDepth||Math.floor(G)!==G))for(var q=0;q<x;q+=I){var L=(P+q)/h;if(!(L<0||L>=c.outHeight||Math.floor(L)!==L))for(var V=0;V<T;V+=y){var U=(R+V)/m;if(!(U<0||U>=c.outWidth||Math.floor(U)!==U))B+=D.get(_,G,L,U,E)}}}A.set(B*w,_,z,W,C,E)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}};var ut={kernelName:a.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,s=o;p([i,o],"avgPoolGrad");for(var u=r.filterSize,d=r.strides,l=r.pad,c=a.backend_util.computePool2DInfo(s.shape,u,d,1,l),f=c.strideHeight,h=c.strideWidth,m=c.filterHeight,v=c.filterWidth,k=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,I=c.effectiveFilterWidth,y=I-1-c.padInfo.left,N=b-1-c.padInfo.top,x=a.buffer(s.shape,"float32"),T=1/(m*v),S=n.data.get(i.dataId).values,F=a.buffer(i.shape,"float32",S),M=0;M<c.batchSize;++M)for(var A=0;A<c.inChannels;++A)for(var w=0;w<c.inHeight;++w)for(var D=0;D<c.inWidth;++D){for(var _=w-N,E=D-y,z=0,W=0;W<b;W+=k){var C=(_+W)/f;if(!(C<0||C>=c.outHeight||Math.floor(C)!==C))for(var H=0;H<I;H+=g){var P=(E+H)/h;if(!(P<0||P>=c.outWidth||Math.floor(P)!==P))z+=F.get(M,C,P,A)}}x.set(z*T,M,w,D,A)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};var dt={kernelName:a.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.scale,s=t.offset,u=t.mean,d=t.variance;a.util.assert(u.shape.length===d.shape.length,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),a.util.assert(null==s||u.shape.length===s.shape.length,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),a.util.assert(null==o||u.shape.length===o.shape.length,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."})),p([i,u,d,o,s],"batchNorm");var l=r.varianceEpsilon;null==l&&(l=.001);for(var c=n.data.get(i.dataId).values,f=n.data.get(u.dataId).values,h=n.data.get(d.dataId).values,m=o?n.data.get(o.dataId).values:new Float32Array([1]),v=s?n.data.get(s.dataId).values:new Float32Array([0]),k=new Float32Array(c.length),g=v.length,b=m.length,I=h.length,y=f.length,N=0,x=0,T=0,S=0,F=0;F<c.length;++F)k[F]=v[N++]+(c[F]-f[x++])*m[T++]/Math.sqrt(h[S++]+l),N>=g&&(N=0),x>=y&&(x=0),T>=b&&(T=0),S>=I&&(S=0);return n.makeTensorInfo(i.shape,i.dtype,k)}};var lt={kernelName:a.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.blockShape,s=r.crops;p([i],"batchToSpaceND");var u=o.reduce((function(e,a){return e*a})),d=a.backend_util.getReshaped(i.shape,o,u),l=a.backend_util.getPermuted(d.length,o.length),c=a.backend_util.getReshapedPermuted(i.shape,o,u),f=a.backend_util.getSliceBeginCoords(s,o.length),h=a.backend_util.getSliceSize(c,s,o.length),m=_a({inputs:{x:i},backend:n,attrs:{shape:d}}),v=We({inputs:{x:m},backend:n,attrs:{perm:l}}),k=_a({inputs:{x:v},backend:n,attrs:{shape:c}}),g=je({inputs:{x:k},backend:n,attrs:{begin:f,size:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),g}};var pt={kernelName:a.Bincount,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.weights,o=n.size,s=E(t.data.get(r.dataId).values,t.data.get(i.dataId).values,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,s)}};var ct={kernelName:a.BroadcastArgs,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.s0,i=t.s1,o=n.data.get(r.dataId).values,s=n.data.get(i.dataId).values,u=a.backend_util.assertAndGetBroadcastShape(Array.from(o),Array.from(s));return n.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},ft=C(a.ClipByValue,(function(e,a){var t=a;return e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e})),ht={kernelName:a.ClipByValue,backendName:"cpu",kernelFunc:ft},mt={kernelName:a.ComplexAbs,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs.x,n=e.backend,r=new Float32Array(a.util.sizeFromShape(t.shape)),i=n.data.get(t.dataId),o=i.complexTensorInfos.real,s=i.complexTensorInfos.imag,u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,l=0;l<u.length;l++){var p=u[l],c=d[l];r[l]=Math.hypot(p,c)}return n.makeOutput(r,t.shape,"float32")}};function vt(e){var a=e.inputs,t=e.backend,n=a.input,r=t.data.get(n.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}var kt={kernelName:a.Imag,backendName:"cpu",kernelFunc:vt};function gt(e){var t=e.inputs,n=e.backend,r=e.attrs.axis,i=a.util.parseAxisParam(r,t[0].shape)[0],o=a.backend_util.computeOutShape(t.map((function(e){return e.shape})),i);if(0===a.util.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);var s=t.filter((function(e){return a.util.sizeFromShape(e.shape)>0}));if(1===s.length)return I({inputs:{x:s[0]},backend:n});var u=s.map((function(e){return e.shape}));if(a.backend_util.assertParamsConsistent(u,i),"complex64"===s[0].dtype){var d=s.map((function(e){return N({inputs:{input:e},backend:n})})),l=s.map((function(e){return vt({inputs:{input:e},backend:n})})),p=gt({inputs:d,backend:n,attrs:{axis:i}}),c=gt({inputs:l,backend:n,attrs:{axis:i}}),f=k({inputs:{real:p,imag:c},backend:n});return d.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),l.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),f}var h=s.map((function(e){var t=a.util.sizeFromShape(e.shape.slice(i));return _a({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),m=h.map((function(e){return{vals:n.data.get(e.dataId).values,shape:e.shape}}));o=a.backend_util.computeOutShape(h.map((function(e){return e.shape})),1);var v=1===h[0].shape[0],g=O(m,o,t[0].dtype,v),b=a.backend_util.computeOutShape(s.map((function(e){return e.shape})),i),y=n.makeTensorInfo(b,t[0].dtype,g);return h.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),y}var bt={kernelName:a.Concat,backendName:"cpu",kernelFunc:gt};function It(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,s=r.strides,u=r.pad,d=r.dataFormat,l=r.dilations,c=r.dimRoundingMode;p([i,o],"conv2d");for(var f=a.backend_util.convertConv2DDataFormat(d),h=a.backend_util.computeConv2DInfo(i.shape,o.shape,s,l,u,c,!1,f),m=h.filterHeight,v=h.filterWidth,k=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,I=h.padInfo.top,y="channelsLast"===h.dataFormat,N=new a.TensorBuffer(h.outShape,i.dtype),x=a.util.computeStrides(i.shape),T=a.util.computeStrides(o.shape),S=x[0],F=y?x[1]:x[2],M=y?x[2]:1,A=y?1:x[1],w=N.strides[0],D=y?N.strides[1]:N.strides[2],_=y?N.strides[2]:1,E=y?1:N.strides[1],z=n.data.get(i.dataId).values,W=n.data.get(o.dataId).values,C=N.values,H=0;H<h.batchSize;++H)for(var P=H*S,R=H*w,B=0;B<h.outHeight;++B)for(var O=R+B*D,G=B*h.strideHeight-I,q=0;q<m;++q){var L=G+q*k;if(!(L<0||L>=h.inHeight))for(var V=q*T[0],U=P+L*F,j=0;j<h.outWidth;++j)for(var Z=O+j*_,K=j*h.strideWidth-b,Y=0;Y<v;++Y){var J=K+Y*g;if(!(J<0||J>=h.inWidth))for(var Q=U+J*M,X=V+Y*T[1],$=0;$<h.inChannels;++$){for(var ee=z[Q+$*A],ae=0;ae<h.outChannels;++ae)C[Z+ae*E]+=ee*W[X+ae];X+=h.outChannels}}}return n.makeTensorInfo(N.shape,N.dtype,C)}var yt={kernelName:a.Conv2D,backendName:"cpu",kernelFunc:It};var Nt={kernelName:a.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.dy,s=r.strides,u=r.pad,d=r.dataFormat,l=r.dimRoundingMode,c=r.filterShape;p([i,o],"conv2dBackpropFilter");for(var f=a.backend_util.convertConv2DDataFormat(d),h=a.backend_util.computeConv2DInfo(i.shape,c,s,1,u,l,!1,f),m=h.strideHeight,v=h.strideWidth,k=h.filterHeight,g=h.filterWidth,b="channelsLast"===h.dataFormat,I=new a.TensorBuffer(h.filterShape,"float32"),y=h.padInfo.left,N=h.padInfo.top,x=n.data.get(i.dataId).values,T=n.data.get(o.dataId).values,S=new a.TensorBuffer(i.shape,i.dtype,x),F=new a.TensorBuffer(o.shape,o.dtype,T),M=0;M<k;++M)for(var A=Math.max(0,Math.ceil((N-M)/m)),w=Math.min(h.outHeight,(h.inHeight+N-M)/m),D=0;D<g;++D)for(var _=Math.max(0,Math.ceil((y-D)/v)),E=Math.min(h.outWidth,(h.inWidth+y-D)/v),z=0;z<h.inChannels;++z)for(var W=0;W<h.outChannels;++W){for(var C=0,H=0;H<h.batchSize;++H)for(var P=A;P<w;++P)for(var R=M+P*m-N,B=_;B<E;++B){var O=D+B*v-y;C+=b?S.get(H,R,O,z)*F.get(H,P,B,W):S.get(H,z,R,O)*F.get(H,W,P,B)}I.set(C,M,D,z,W)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var xt={kernelName:a.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.filter,s=r.inputShape,u=r.strides,l=r.pad,c=r.dataFormat,f=r.dimRoundingMode;p([i,o],"conv2dBackpropInput");var h=a.util.computeStrides(o.shape),m=a.util.computeStrides(i.shape),v=a.backend_util.convertConv2DDataFormat(c),k=a.backend_util.computeConv2DInfo(s,o.shape,u,1,l,f,!1,v),g=new a.TensorBuffer(k.inShape,"float32"),b=g.values,I=n.data.get(i.dataId).values,y=n.data.get(o.dataId).values,N=d(h,3),x=N[0],T=N[1],S=N[2],F=k.batchSize,M=k.filterHeight,A=k.filterWidth,w=k.inChannels,D=k.inHeight,_=k.inWidth,E=k.outChannels,z=k.outHeight,W=k.outWidth,C=k.strideHeight,H=k.strideWidth;v=k.dataFormat;for(var P=M-1-k.padInfo.top,R=A-1-k.padInfo.left,B="channelsLast"===v,O=g.strides[0],G=B?g.strides[1]:g.strides[2],q=B?g.strides[2]:1,L=B?1:g.strides[1],V=m[0],U=B?m[1]:m[2],j=B?m[2]:1,Z=B?1:m[1],K=0;K<F;++K)for(var Y=0;Y<w;++Y)for(var J=0;J<D;++J)for(var Q=J-P,X=Math.max(0,Math.ceil(Q/C)),$=Math.min(z,(M+Q)/C),ee=0;ee<_;++ee){for(var ae=ee-R,te=Math.max(0,Math.ceil(ae/H)),ne=Math.min(W,(A+ae)/H),re=0,ie=X;ie<$;++ie)for(var oe=ie*C-Q,se=te;se<ne;++se)for(var ue=V*K+U*ie+j*se,de=x*(M-1-oe)+T*(A-1-(se*H-ae))+S*Y,le=0;le<E;++le){re+=I[ue+Z*le]*y[de+le]}b[O*K+G*J+q*ee+L*Y]=re}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var Tt={kernelName:a.Conv3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,s=r.strides,u=r.pad,d=r.dilations;p([i,o],"conv3d");for(var l=a.backend_util.computeConv3DInfo(i.shape,o.shape,s,d,u),c=l.filterDepth,f=l.filterHeight,h=l.filterWidth,m=l.dilationDepth,v=l.dilationHeight,k=l.dilationWidth,g=l.padInfo,b=g.front,I=g.left,y=g.top,N=new a.TensorBuffer(l.outShape,i.dtype),x=n.data.get(i.dataId).values,T=n.data.get(o.dataId).values,S=N.values,F=a.util.computeStrides(i.shape),M=a.util.computeStrides(o.shape),A=0;A<l.batchSize;++A)for(var w=A*F[0],D=A*N.strides[0],_=0;_<l.outDepth;++_)for(var E=D+_*N.strides[1],z=_*l.strideDepth-b,W=0;W<c;++W){var C=z+W*m;if(!(C<0||C>=l.inDepth))for(var H=W*M[0],P=w+C*F[1],R=0;R<l.outHeight;++R)for(var B=E+R*N.strides[2],O=R*l.strideHeight-y,G=0;G<f;++G){var q=O+G*v;if(!(q<0||q>=l.inHeight))for(var L=H+G*M[1],V=P+q*F[2],U=0;U<l.outWidth;++U)for(var j=B+U*l.outChannels,Z=U*l.strideWidth-I,K=0;K<h;++K){var Y=Z+K*k;if(!(Y<0||Y>=l.inWidth))for(var J=L+K*M[2],Q=V+Y*l.inChannels,X=J,$=0;$<l.inChannels;++$){for(var ee=x[Q+$],ae=0;ae<l.outChannels;++ae)S[j+ae]+=ee*T[X+ae];X+=l.outChannels}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};var St={kernelName:a.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.dy,s=r.strides,u=r.pad,l=r.filterShape;p([i,o],"conv3dBackpropFilterV2");for(var c=a.util.computeStrides(i.shape),f=a.util.computeStrides(o.shape),h=a.backend_util.computeConv3DInfo(i.shape,l,s,1,u),m=h.strideDepth,v=h.strideHeight,k=h.strideWidth,g=h.filterDepth,b=h.filterHeight,I=h.filterWidth,y=new a.TensorBuffer(h.filterShape,"float32"),N=y.values,x=d(y.strides,4),T=x[0],S=x[1],F=x[2],M=x[3],A=n.data.get(o.dataId).values,w=d(f,4),D=w[0],_=w[1],E=w[2],z=w[3],W=n.data.get(i.dataId).values,C=d(c,4),H=C[0],P=C[1],R=C[2],B=C[3],O=h.padInfo.front,G=h.padInfo.left,q=h.padInfo.top,L=0;L<g;++L)for(var V=Math.max(0,Math.ceil((O-L)/m)),U=Math.min(h.outDepth,(h.inDepth+O-L)/m),j=L*T,Z=0;Z<b;++Z)for(var K=Math.max(0,Math.ceil((q-Z)/v)),Y=Math.min(h.outHeight,(h.inHeight+q-Z)/v),J=Z*S+j,Q=0;Q<I;++Q)for(var X=Math.max(0,Math.ceil((G-Q)/k)),$=Math.min(h.outWidth,(h.inWidth+G-Q)/k),ee=Q*F+J,ae=0;ae<h.inChannels;++ae)for(var te=ae*M+ee,ne=0;ne<h.outChannels;++ne){for(var re=0,ie=0;ie<h.batchSize;++ie)for(var oe=ie*H,se=ie*D,ue=V;ue<U;++ue)for(var de=(L+ue*m-O)*P+oe,le=ue*_+se,pe=K;pe<Y;++pe)for(var ce=(Z+pe*v-q)*R+de,fe=pe*E+le,he=X;he<$;++he){var me=he*z+fe;re+=W[(Q+he*k-G)*B+ce+ae]*A[me+ne]}N[te+ne]=re}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var Ft={kernelName:a.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.filter,s=r.pad,u=r.strides,l=r.inputShape;p([i],"conv3dBackpropInputV2");for(var c=a.util.computeStrides(i.shape),f=a.util.computeStrides(o.shape),h=a.backend_util.computeConv3DInfo(l,o.shape,u,1,s),m=new a.TensorBuffer(h.inShape,"float32"),v=m.values,k=d(m.strides,4),g=k[0],b=k[1],I=k[2],y=k[3],N=n.data.get(i.dataId).values,x=d(c,4),T=x[0],S=x[1],F=x[2],M=x[3],A=n.data.get(o.dataId).values,w=d(f,4),D=w[0],_=w[1],E=w[2],z=w[3],W=h.batchSize,C=h.filterDepth,H=h.filterHeight,P=h.filterWidth,R=h.inChannels,B=h.inDepth,O=h.inHeight,G=h.inWidth,q=h.outChannels,L=h.outDepth,V=h.outHeight,U=h.outWidth,j=h.strideDepth,Z=h.strideHeight,K=h.strideWidth,Y=C-1-h.padInfo.front,J=H-1-h.padInfo.top,Q=P-1-h.padInfo.left,X=0;X<W;++X)for(var $=0;$<R;++$)for(var ee=0;ee<B;++ee)for(var ae=ee-Y,te=Math.max(0,Math.ceil(ae/j)),ne=Math.min(L,(C+ae)/j),re=0;re<O;++re)for(var ie=re-J,oe=Math.max(0,Math.ceil(ie/Z)),se=Math.min(V,(H+ie)/Z),ue=0;ue<G;++ue){for(var de=ue-Q,le=Math.max(0,Math.ceil(de/K)),pe=Math.min(U,(P+de)/K),ce=0,fe=te;fe<ne;++fe)for(var he=fe*j-ae,me=oe;me<se;++me)for(var ve=me*Z-ie,ke=le;ke<pe;++ke)for(var ge=T*X+S*fe+F*me+M*ke,be=D*(C-1-he)+_*(H-1-ve)+E*(P-1-(ke*K-de))+z*$,Ie=0;Ie<q;++Ie){ce+=N[ge+Ie]*A[be+Ie]}v[g*X+b*ee+I*re+y*ue+$]=ce}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},Mt=C(a.Cos,(function(e){return Math.cos(e)})),At={kernelName:a.Cos,backendName:"cpu",kernelFunc:Mt},wt=C(a.Cosh,(function(e){return Math.cosh(e)})),Dt={kernelName:a.Cosh,backendName:"cpu",kernelFunc:wt};var _t={kernelName:a.CropAndResize,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.backend,r=e.attrs,i=t.image,o=t.boxes,s=t.boxInd,u=r.cropSize,l=r.method,p=r.extrapolationValue,c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=o.shape[0],g=d(u,2),b=g[0],I=g[1],y=a.buffer([k,b,I,v],"float32"),N=n.data.get(o.dataId).values,x=n.data.get(s.dataId).values,T=n.data.get(i.dataId).values,S=a.util.computeStrides(i.shape),F=a.util.computeStrides(y.shape),M=0;M<k;M++){var A=4*M,w=N[A],D=N[A+1],_=N[A+2],E=N[A+3],z=x[M];if(!(z>=f))for(var W=b>1?(_-w)*(h-1)/(b-1):0,C=I>1?(E-D)*(m-1)/(I-1):0,H=0;H<b;H++){var P=b>1?w*(h-1)+H*W:.5*(w+_)*(h-1);if(P<0||P>h-1)for(var R=0;R<I;R++)for(var B=0;B<v;B++){var O=B+R*F[2]+H*F[1]+M*F[0];y.values[O]=p}else if("bilinear"===l){var G=Math.floor(P),q=Math.ceil(P),L=P-G;for(R=0;R<I;R++){if((X=I>1?D*(m-1)+R*C:.5*(D+E)*(m-1))<0||X>m-1)for(B=0;B<v;B++){O=B+R*F[2]+H*F[1]+M*F[0];y.values[O]=p}else{var V=Math.floor(X),U=Math.ceil(X),j=X-V;for(B=0;B<v;B++){var Z=T[O=B+V*S[2]+G*S[1]+z*S[0]],K=T[O=B+U*S[2]+G*S[1]+z*S[0]],Y=T[O=B+V*S[2]+q*S[1]+z*S[0]],J=Z+(K-Z)*j,Q=Y+(T[O=B+U*S[2]+q*S[1]+z*S[0]]-Y)*j;O=B+R*F[2]+H*F[1]+M*F[0],y.values[O]=J+(Q-J)*L}}}}else for(R=0;R<I;++R){var X;if((X=I>1?D*(m-1)+R*C:.5*(D+E)*(m-1))<0||X>m-1)for(B=0;B<v;B++){O=B+R*F[2]+H*F[1]+M*F[0];y.values[O]=p}else{var $=Math.round(X),ee=Math.round(P);for(B=0;B<v;B++){var ae=B+$*S[2]+ee*S[1]+z*S[0],te=B+R*F[2]+H*F[1]+M*F[0];y.values[te]=T[ae]}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var Et={kernelName:a.Cumsum,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,s=r.exclusive,u=r.reverse;p(i,"cumsum");var d=a.backend_util.getAxesPermutation([o],i.shape.length),l=i;null!=d&&(l=We({inputs:{x:i},backend:n,attrs:{perm:d}}));var c=a.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(c!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(l.shape.length-1)+" but got axis="+c);for(var f=a.upcastType(l.dtype,"int32"),h=a.util.makeZerosTypedArray(a.util.sizeFromShape(l.shape),f),m=n.data.get(l.dataId).values,v=l.shape[l.shape.length-1],k=u?function(e,a){return e+v-a-1}:function(e,a){return e+a},g=0;g<m.length;g+=v)for(var b=0;b<v;b++){var I=k(g,b);if(0===b)h[I]=s?0:m[I];else{var y=k(g,b-1);h[I]=s?m[y]+h[y]:m[I]+h[y]}}var N=n.makeTensorInfo(l.shape,f,h);if(null!=d){var x=We({inputs:{x:N},backend:n,attrs:{perm:a.backend_util.getUndoAxesPermutation(d)}});return n.disposeIntermediateTensorInfo(N),n.disposeIntermediateTensorInfo(l),x}return N}};var zt={kernelName:a.DenseBincount,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.weights,o=n.size,s=n.binaryOutput;if(1===r.shape.length){var u=E(t.data.get(r.dataId).values,t.data.get(i.dataId).values,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}if(2===r.shape.length){var d=z(t.bufferSync(r),t.bufferSync(i),o,s);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+r.shape.length+".")}};var Wt={kernelName:a.DepthToSpace,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.blockSize,s=r.dataFormat;a.util.assert("NHWC"===s,(function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+s}));for(var u=i.shape[0],d=i.shape[1],l=i.shape[2],p=i.shape[3],c=d*o,f=l*o,h=p/(o*o),m=n.data.get(i.dataId).values,v=new Float32Array(u*c*f*h),k=0,g=0;g<u;++g)for(var b=0;b<c;++b)for(var I=Math.floor(b/o),y=b%o,N=0;N<f;++N)for(var x=Math.floor(N/o),T=(y*o+N%o)*h,S=0;S<h;++S){var F=S+T+p*(x+l*(I+d*g));v[k++]=m[F]}return n.makeTensorInfo([u,c,f,h],i.dtype,v)}};function Ct(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,s=r.strides,u=r.pad,d=r.dilations,l=r.dimRoundingMode;p([i,o],"depthwiseConv2DNative");var c=a.util.computeStrides(i.shape),f=a.util.computeStrides(o.shape),h=d;null==h&&(h=[1,1]),a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(s,h),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+s+" and dilations '"+h+"'"}));for(var m=a.backend_util.computeConv2DInfo(i.shape,o.shape,s,h,u,l,!0),v=m.filterHeight,k=m.filterWidth,g=m.dilationHeight,b=m.dilationWidth,I=m.padInfo,y=I.left,N=I.top,x=m.outChannels/m.inChannels,T=new a.TensorBuffer(m.outShape,i.dtype),S=n.data.get(i.dataId).values,F=n.data.get(o.dataId).values,M=T.values,A=0;A<m.batchSize;++A)for(var w=A*c[0],D=A*T.strides[0],_=0;_<m.outHeight;++_)for(var E=D+_*T.strides[1],z=_*m.strideHeight-N,W=0;W<v;++W){var C=z+W*g;if(!(C<0||C>=m.inHeight))for(var H=W*f[0],P=w+C*c[1],R=0;R<m.outWidth;++R)for(var B=E+R*T.strides[2],O=R*m.strideWidth-y,G=0;G<k;++G){var q=O+G*b;if(!(q<0||q>=m.inWidth))for(var L=H+G*f[1],V=P+q*m.inChannels,U=B,j=L,Z=0;Z<m.inChannels;++Z){for(var K=S[V+Z],Y=0;Y<x;++Y)M[U+Y]+=K*F[j+Y];U+=x,j+=x}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var Ht={kernelName:a.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:Ct};var Pt={kernelName:a.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.dy,s=r.strides,u=r.dilations,d=r.pad,l=r.dimRoundingMode,c=r.filterShape;p([i,o],"depthwiseConv2dNativeBackpropFilter");for(var f=a.backend_util.computeConv2DInfo(i.shape,c,s,u,d,l,!0),h=f.strideHeight,m=f.strideWidth,v=f.filterHeight,k=f.filterWidth,g=new a.TensorBuffer(f.filterShape,"float32"),b=f.padInfo.left,I=f.padInfo.top,y=f.outChannels/f.inChannels,N=n.data.get(i.dataId).values,x=new a.TensorBuffer(i.shape,i.dtype,N),T=n.data.get(o.dataId).values,S=new a.TensorBuffer(o.shape,o.dtype,T),F=0;F<v;++F)for(var M=Math.max(0,Math.ceil((I-F)/h)),A=Math.min(f.outHeight,(f.inHeight+I-F)/h),w=0;w<k;++w)for(var D=Math.max(0,Math.ceil((b-w)/m)),_=Math.min(f.outWidth,(f.inWidth+b-w)/m),E=0;E<f.outChannels;++E){for(var z=Math.trunc(E/y),W=E%y,C=0,H=0;H<f.batchSize;++H)for(var P=M;P<A;++P)for(var R=F+P*h-I,B=D;B<_;++B){var O=w+B*m-b;C+=x.get(H,R,O,z)*S.get(H,P,B,E)}g.set(C,F,w,z,W)}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var Rt={kernelName:a.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.filter,s=r.strides,u=r.dilations,l=r.pad,c=r.dimRoundingMode,f=r.inputShape;p([i,o],"depthwiseConv2DNativeBackpropInput");for(var h=a.util.computeStrides(i.shape),m=a.util.computeStrides(o.shape),v=a.backend_util.computeConv2DInfo(f,o.shape,s,u,l,c,!0),k=new a.TensorBuffer(v.inShape,"float32"),g=k.values,b=d(k.strides,3),I=b[0],y=b[1],N=b[2],x=n.data.get(i.dataId).values,T=d(h,3),S=T[0],F=T[1],M=T[2],A=n.data.get(o.dataId).values,w=d(m,3),D=w[0],_=w[1],E=w[2],z=v.batchSize,W=v.filterHeight,C=v.filterWidth,H=v.inChannels,P=v.inHeight,R=v.inWidth,B=v.outChannels,O=v.outHeight,G=v.outWidth,q=v.strideHeight,L=v.strideWidth,V=W-1-v.padInfo.top,U=C-1-v.padInfo.left,j=B/H,Z=0;Z<z;++Z)for(var K=0;K<H;++K)for(var Y=0;Y<P;++Y)for(var J=Y-V,Q=Math.max(0,Math.ceil(J/q)),X=Math.min(O,(W+J)/q),$=0;$<R;++$){for(var ee=$-U,ae=Math.max(0,Math.ceil(ee/L)),te=Math.min(G,(C+ee)/L),ne=0,re=Q;re<X;++re)for(var ie=re*q-J,oe=ae;oe<te;++oe)for(var se=S*Z+F*re+M*oe,ue=D*(W-1-ie)+_*(C-1-(oe*L-ee))+E*K,de=0;de<j;++de){ne+=x[se+(K*j+de)]*A[ue+de]}g[I*Z+y*Y+N*$+K]=ne}return n.makeTensorInfo(k.shape,k.dtype,k.values)}};var Bt={kernelName:a.Diag,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.backend,r=t.x,i=a.util.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,s=a.buffer([i,i],r.dtype),u=s.values,d=0;d<o.length;d++)u[d*i+d]=o[d];var p=l(r.shape,r.shape);return n.makeTensorInfo(p,s.dtype,s.values)}},Ot={kernelName:a.Dilation2D,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,s=r.strides,u=r.pad,d=r.dilations,l=n,p=l.data.get(i.dataId).values,c=i.shape.length,f=l.data.get(o.dataId).values,h=o.shape.length,m=a.backend_util.computeDilation2DInfo(i.shape,o.shape,s,u,"NHWC",d),v=m.batchSize,k=m.inHeight,g=m.inWidth,b=m.inChannels,I=m.outHeight,y=m.outWidth,N=m.padInfo,x=m.strideHeight,T=m.strideWidth,S=m.filterHeight,F=m.filterWidth,M=m.dilationHeight,A=m.dilationWidth,w=m.outShape,D=a.util.sizeFromShape(w),_=w.length,E=a.util.getArrayFromDType(i.dtype,D),z=0;z<v;++z)for(var W=0;W<I;++W)for(var C=W*x-N.top,H=0;H<y;++H)for(var P=H*T-N.left,R=0;R<b;++R){for(var B=Number.MIN_SAFE_INTEGER,O=0;O<S;++O){var G=C+O*M;if(G>=0&&G<k)for(var q=0;q<F;++q){var L=P+q*A;if(L>=0&&L<g){var V=a.util.locToIndex([z,G,L,R],c,a.util.computeStrides(i.shape)),U=a.util.locToIndex([O,q,R],h,a.util.computeStrides(o.shape)),j=p[V]+f[U];j>B&&(B=j)}}}E[a.util.locToIndex([z,W,H,R],_,a.util.computeStrides(w))]=B}return{dataId:l.write(a.util.toTypedArray(E,i.dtype),w,i.dtype),shape:w,dtype:i.dtype}}},Gt={kernelName:a.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,s=t.dy,u=r.strides,d=r.pad,l=r.dilations,p=n,c=a.util.toNestedArray(i.shape,p.data.get(i.dataId).values),f=a.util.toNestedArray(o.shape,p.data.get(o.dataId).values),h=a.backend_util.computeDilation2DInfo(i.shape,o.shape,u,d,"NHWC",l),m=h.batchSize,v=h.inHeight,k=h.inWidth,g=h.inChannels,b=h.outHeight,I=h.outWidth,y=h.padInfo,N=h.strideHeight,x=h.strideWidth,T=h.filterHeight,S=h.filterWidth,F=h.dilationHeight,M=h.dilationWidth,A=h.outShape;a.util.assert(s.rank===A.length,(function(){return"Error in "+a.Dilation2DBackpropFilter+", dy must have the same rank as output "+A.length+", but got "+s.rank}));for(var w=a.util.toNestedArray(A,p.data.get(s.dataId).values),D=a.util.makeZerosNestedTypedArray(o.shape,o.dtype),_=0;_<m;++_)for(var E=0;E<b;++E)for(var z=E*N-y.top,W=0;W<I;++W)for(var C=W*x-y.left,H=0;H<g;++H){for(var P=Number.MIN_SAFE_INTEGER,R=0,B=0,O=0;O<T;++O){var G=z+O*F;if(G>=0&&G<v)for(var q=0;q<S;++q){var L=C+q*M;if(L>=0&&L<k){var V=c[_][G][L][H]+f[O][q][H];V>P&&(P=V,R=O,B=q)}}}D[R][B][H]+=w[_][E][W][H]}return{dataId:p.write(a.util.toTypedArray(D,i.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},qt={kernelName:a.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,s=t.dy,u=r.strides,d=r.pad,l=r.dilations,p=n,c=a.util.toNestedArray(i.shape,p.data.get(i.dataId).values),f=a.util.toNestedArray(o.shape,p.data.get(o.dataId).values),h=a.backend_util.computeDilation2DInfo(i.shape,o.shape,u,d,"NHWC",l),m=h.batchSize,v=h.inHeight,k=h.inWidth,g=h.inChannels,b=h.outHeight,I=h.outWidth,y=h.padInfo,N=h.strideHeight,x=h.strideWidth,T=h.filterHeight,S=h.filterWidth,F=h.dilationHeight,M=h.dilationWidth,A=h.outShape;a.util.assert(s.rank===A.length,(function(){return"Error in "+a.Dilation2DBackpropInput+", dy must have the same rank as output "+A.length+", but got "+s.rank}));for(var w=a.util.toNestedArray(A,p.data.get(s.dataId).values),D=a.util.makeZerosNestedTypedArray(i.shape,i.dtype),_=0;_<m;++_)for(var E=0;E<b;++E)for(var z=E*N-y.top,W=0;W<I;++W)for(var C=W*x-y.left,H=0;H<g;++H){for(var P=Number.MIN_SAFE_INTEGER,R=z<0?0:z,B=C<0?0:C,O=0;O<T;++O){var G=z+O*F;if(G>=0&&G<v)for(var q=0;q<S;++q){var L=C+q*M;if(L>=0&&L<k){var V=c[_][G][L][H]+f[O][q][H];V>P&&(P=V,R=G,B=L)}}}D[_][R][B][H]+=w[_][E][W][H]}return{dataId:p.write(a.util.toTypedArray(D,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};function Lt(e){var t,n=e.inputs,r=e.backend,i=e.attrs,o=n.x,s=i.axis,u=i.keepDims;p(o,"sum");var l=(t="bool"===o.dtype?T({inputs:{x:o},backend:r,attrs:{dtype:"int32"}}):I({inputs:{x:o},backend:r})).shape.length,c=a.util.parseAxisParam(s,t.shape),f=a.backend_util.getAxesPermutation(c,l),h=c,m=t;null!=f&&(m=We({inputs:{x:t},backend:r,attrs:{perm:f}}),h=a.backend_util.getInnerMostAxes(h.length,l)),a.backend_util.assertAxesAreInnerMostDims("sum",h,m.shape.length);for(var v=d(a.backend_util.computeOutAndReduceShapes(m.shape,h),2),k=v[0],g=v[1],y=b(r,k,a.backend_util.upcastType(m.dtype,"int32")),N=a.util.sizeFromShape(g),x=r.data.get(y.dataId).values,S=r.data.get(m.dataId).values,F=0;F<x.length;++F){for(var M=F*N,A=0,w=0;w<N;++w)A+=S[M+w];x[F]=A}if(u){var D=y;y=_a({inputs:{x:y},backend:r,attrs:{shape:a.backend_util.expandShapeToKeepDim(y.shape,c)}}),r.disposeIntermediateTensorInfo(D)}return r.disposeIntermediateTensorInfo(t),null!=f&&r.disposeIntermediateTensorInfo(m),y}var Vt={kernelName:a.Sum,backendName:"cpu",kernelFunc:Lt};var Ut={kernelName:a.Einsum,backendName:"cpu",kernelFunc:function(e){var t,n,r,i,o=e.inputs,s=e.backend,d=e.attrs.equation,l=o,p=a.backend_util.decodeEinsumEquation(d,l.length),c=p.allDims,f=p.summedDims,h=p.idDims;a.backend_util.checkEinsumDimSizes(c.length,h,l);for(var m=a.backend_util.getEinsumComputePath(f,h),v=m.path,k=m.steps,g=k.length,b=null,I=c.length,y=[],N=0;N<g;++N){try{for(var x=(t=void 0,u(k[N])),T=x.next();!T.done;T=x.next()){var S=T.value,F=a.backend_util.getEinsumPermutation(I,h[S]),M=F.permutationIndices,A=F.expandDims,w=void 0;a.backend_util.isIdentityPermutation(M)?w=l[S]:(w=We({inputs:{x:l[S]},backend:s,attrs:{perm:M}}),y.push(w));for(var D=w.shape.slice(),_=0;_<A.length;++_)D.splice(A[_],0,1);a.util.arraysEqual(w.shape,D)||(w=_a({inputs:{x:w},backend:s,attrs:{shape:D}}),y.push(w)),null===b?b=w:(b=Fe({inputs:{a:w,b:b},backend:s}),y.push(b))}}catch(e){t={error:e}}finally{try{T&&!T.done&&(n=x.return)&&n.call(x)}finally{if(t)throw t.error}}N<g-1&&(v[N]>=0&&(b=Lt({inputs:{x:b},backend:s,attrs:{axis:v[N]-(c.length-I),keepDims:!1}}),y.push(b)),I--)}try{for(var E=u(y),z=E.next();!z.done;z=E.next()){var W=z.value;W!==b&&s.disposeIntermediateTensorInfo(W)}}catch(e){r={error:e}}finally{try{z&&!z.done&&(i=E.return)&&i.call(E)}finally{if(r)throw r.error}}return b}};var jt={kernelName:a.EluGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.dy,i=t.y;p([r,i],"eluGrad");for(var o=new Float32Array(a.util.sizeFromShape(i.shape)),s=n.data.get(i.dataId).values,u=n.data.get(r.dataId).values,d=0;d<s.length;++d){var l=s[d];o[d]=l>=1?u[d]:u[d]*(l+1)}return n.makeTensorInfo(i.shape,"float32",o)}},Zt=a.backend_util.ERF_P,Kt=a.backend_util.ERF_A1,Yt=a.backend_util.ERF_A2,Jt=a.backend_util.ERF_A3,Qt=a.backend_util.ERF_A4,Xt=a.backend_util.ERF_A5,$t=C(a.Erf,(function(e){var a=Math.sign(e),t=Math.abs(e),n=1/(1+Zt*t);return a*(1-((((Xt*n+Qt)*n+Jt)*n+Yt)*n+Kt)*n*Math.exp(-t*t))})),en={kernelName:a.Erf,backendName:"cpu",kernelFunc:$t};function an(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.input,o=r.dim,s=i.shape.length,u=i.shape.slice(),d=o;return o<0&&(a.util.assert(-(s+1)<=o,(function(){return"Axis must be in the interval ["+-(s+1)+", "+s+"]"})),d=s+o+1),u.splice(d,0,1),_a({inputs:{x:i},backend:n,attrs:{shape:u}})}var tn={kernelName:a.ExpandDims,backendName:"cpu",kernelFunc:an},nn=v((function(e,a){return e/a})),rn=F(a.RealDiv,nn),on={kernelName:a.RealDiv,backendName:"cpu",kernelFunc:rn};function sn(e,t,n){for(var r=e.shape,i=r[0],o=r[1],s=n.data.get(e.dataId),u=s.complexTensorInfos.real,d=s.complexTensorInfos.imag,l=[i,o],p=a.util.sizeFromShape(l),c=a.util.getTypedArrayFromDType("float32",p),f=a.util.getTypedArrayFromDType("float32",p),h=0;h<i;h++){for(var m=je({inputs:{x:u},backend:n,attrs:{begin:[h,0],size:[1,o]}}),v=je({inputs:{x:d},backend:n,attrs:{begin:[h,0],size:[1,o]}}),g=k({inputs:{real:m,imag:v},backend:n}),b=un(g,t,n),I=b.real,y=b.imag,N=a.backend_util.mergeRealAndImagArrays(I,y),x=0;x<o;x++){var T=a.backend_util.getComplexWithIndex(N,x);c[h*o+x]=T.real,f[h*o+x]=T.imag}n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(g)}var S=n.makeTensorInfo(l,"float32",c),F=n.makeTensorInfo(l,"float32",f),M=k({inputs:{real:S,imag:F},backend:n});return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(F),M}function un(e,t,n){var r=a.util.sizeFromShape(e.shape),i=n.data.get(e.dataId),o=n.data.get(i.complexTensorInfos.real.dataId).values,s=n.data.get(i.complexTensorInfos.imag.dataId).values;if(0==((g=r)&g-1)){var u=dn(o,s,r,t,n),d=[e.shape[0],e.shape[1]];if(t){var l=n.makeTensorInfo(d,"float32",u.real),p=n.makeTensorInfo(d,"float32",u.imag),c=n.makeTensorInfo([],"float32",a.util.createScalarValue(r,"float32")),f=I({inputs:{x:c},backend:n}),h=on.kernelFunc({inputs:{a:l,b:c},backend:n}),m=on.kernelFunc({inputs:{a:p,b:f},backend:n}),v=n.data.get(h.dataId).values,k=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),{real:v,imag:k}}return u}var g,b=function(e,t,n){for(var r=new Float32Array(2*t),i=0;i<t;i++){for(var o=0,s=0,u=0;u<t;u++){var d=a.backend_util.exponent(i*u,t,n),l=a.backend_util.getComplexWithIndex(e,u);o+=l.real*d.real-l.imag*d.imag,s+=l.real*d.imag+l.imag*d.real}n&&(o/=t,s/=t),a.backend_util.assignToTypedArray(r,o,s,i)}return r}(a.backend_util.mergeRealAndImagArrays(o,s),r,t);return a.backend_util.splitRealAndImagArrays(b)}function dn(e,t,n,r,i){if(1===n)return{real:e,imag:t};var o=a.backend_util.mergeRealAndImagArrays(e,t),s=n/2,u=a.backend_util.complexWithEvenIndex(o),d=u.real,l=u.imag,p=[d.length],c=i.makeTensorInfo(p,"float32",d),f=i.makeTensorInfo(p,"float32",l),h=k({inputs:{real:c,imag:f},backend:i}),m=a.backend_util.complexWithOddIndex(o),v=m.real,g=m.imag,b=[v.length],I=i.makeTensorInfo(b,"float32",v),y=i.makeTensorInfo(b,"float32",g),x=k({inputs:{real:I,imag:y},backend:i}),T=dn(d,l,s,r,i),S=T.real,F=T.imag,M=[S.length],A=i.makeTensorInfo(M,"float32",S),w=i.makeTensorInfo(M,"float32",F),_=k({inputs:{real:A,imag:w},backend:i}),E=dn(v,g,s,r,i),z=E.real,W=E.imag,C=[z.length],H=i.makeTensorInfo(C,"float32",z),P=i.makeTensorInfo(C,"float32",W),R=k({inputs:{real:H,imag:P},backend:i}),B=a.backend_util.exponents(n,r),O=[B.real.length],G=i.makeTensorInfo(O,"float32",B.real),q=i.makeTensorInfo(O,"float32",B.imag),L=k({inputs:{real:G,imag:q},backend:i}),V=Fe({inputs:{a:L,b:R},backend:i}),U=D({inputs:{a:_,b:V},backend:i}),j=pa({inputs:{a:_,b:V},backend:i}),Z=N({inputs:{input:U},backend:i}),K=N({inputs:{input:j},backend:i}),Y=vt({inputs:{input:U},backend:i}),J=vt({inputs:{input:j},backend:i}),Q=gt({inputs:[Z,K],backend:i,attrs:{axis:0}}),X=gt({inputs:[Y,J],backend:i,attrs:{axis:0}}),$=i.data.get(Q.dataId).values,ee=i.data.get(X.dataId).values;return i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(I),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(R),i.disposeIntermediateTensorInfo(G),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(Z),i.disposeIntermediateTensorInfo(Y),i.disposeIntermediateTensorInfo(K),i.disposeIntermediateTensorInfo(J),i.disposeIntermediateTensorInfo(Q),i.disposeIntermediateTensorInfo(X),{real:$,imag:ee}}var ln={kernelName:a.FFT,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.input,i=a.util.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],s=_a({inputs:{x:r},backend:n,attrs:{shape:[i/o,o]}}),u=sn(s,!1,n),d=_a({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(u),d}};function pn(e){var t=e.backend,n=e.attrs,r=n.shape,i=n.value,o=n.dtype||a.util.inferDtype(i),s=a.util.getArrayFromDType(o,a.util.sizeFromShape(r));return function(e,a,t){e.fill(a)}(s,i),t.makeTensorInfo(r,o,s)}var cn={kernelName:a.Fill,backendName:"cpu",kernelFunc:pn};var fn={kernelName:a.FlipLeftRight,backendName:"cpu",kernelFunc:function(e){var t=e.inputs;e.attrs;for(var n=e.backend,r=t.image,i=n,o=a.util.getTypedArrayFromDType(r.dtype,a.util.sizeFromShape(r.shape)),s=d(r.shape,4),u=s[0],l=s[1],p=s[2],c=s[3],f=i.data.get(r.dataId).values,h=0;h<u;h++)for(var m=h*p*l*c,v=0;v<l;v++)for(var k=v*(p*c),g=0;g<p;g++)for(var b=g*c,I=0;I<c;I++){var y=Math.round(p-g-1),N=m+k+b+I,x=f[N];if(y>=0&&y<p)x=f[m+k+y*c+I];o[N]=x}return{dataId:i.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},hn=v((function(e,a){return Math.floor(e/a)})),mn=F(a.FloorDiv,hn,null,"int32"),vn={kernelName:a.FloorDiv,backendName:"cpu",kernelFunc:mn};var kn={kernelName:a.FusedConv2D,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.filter,o=a.bias,s=a.preluActivationWeights,u=n.strides,d=n.pad,l=n.dataFormat,p=n.dilations,c=n.dimRoundingMode,f=n.activation,h=n.leakyreluAlpha,m=It({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:l,dilations:p,dimRoundingMode:c}});if(o){var v=m;m=D({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(v)}if(f){v=m;m=Da(t,m,f,s,h),t.disposeIntermediateTensorInfo(v)}return m}};var gn={kernelName:a.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.filter,o=a.bias,s=a.preluActivationWeights,u=n.strides,d=n.pad,l=n.dataFormat,p=n.dilations,c=n.dimRoundingMode,f=n.activation,h=n.leakyreluAlpha,m=Ct({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:l,dilations:p,dimRoundingMode:c}});if(o){var v=m;m=D({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(v)}if(f){v=m;m=Da(t,m,f,s,h),t.disposeIntermediateTensorInfo(v)}return m}};var bn={kernelName:a.GatherNd,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.params,i=t.indices,o=a.util.sizeFromShape(r.shape),s=i.shape,u=s[s.length-1],l=d(a.backend_util.prepareAndValidate(r,i),4),p=l[0],c=l[1],f=l[2],h=l[3];if(0===c)return n.makeTensorInfo(p,r.dtype,[]);var m=$(n.data.get(i.dataId).values,n.bufferSync(r),r.dtype,c,u,f,h,r.shape,o);return n.makeTensorInfo(p,r.dtype,m.values)}};var In={kernelName:a.GatherV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.indices,s=r.axis,u=r.batchDims;p([i,o],"gatherV2");for(var d=a.util.parseAxisParam(s,i.shape)[0],l=n.data.get(o.dataId).values,c=i.shape[d],f=function(e){var t=l[e];a.util.assert(t<=c-1&&t>=0,(function(){return"GatherV2: the index value "+t+" is not in [0, "+(c-1)+"]"}))},h=0;h<l.length;++h)f(h);var m=u;null==u&&(m=0);var v=a.util.sizeFromShape(o.shape),k=a.backend_util.segment_util.collectGatherOpShapeInfo(i,o,d,m),g=_a({inputs:{x:i},backend:n,attrs:{shape:[k.batchSize,k.outerSize,k.dimSize,k.sliceSize]}}),b=_a({inputs:{x:o},backend:n,attrs:{shape:[k.batchSize,v/k.batchSize]}}),I=[k.batchSize,k.outerSize,v/k.batchSize,k.sliceSize],y=n.bufferSync(b),N=ee(n.bufferSync(g),y,I);return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.makeTensorInfo(k.outputShape,N.dtype,N.values)}};var yn={kernelName:a.IFFT,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.input,i=a.util.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],s=_a({inputs:{x:r},backend:n,attrs:{shape:[i/o,o]}}),u=sn(s,!0,n),d=_a({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(u),d}},Nn=C(a.IsFinite,(function(e){return Number.isFinite(e)?1:0}),"bool"),xn={kernelName:a.IsFinite,backendName:"cpu",kernelFunc:Nn},Tn=C(a.IsInf,(function(e){return Math.abs(e)===1/0?1:0}),"bool"),Sn={kernelName:a.IsInf,backendName:"cpu",kernelFunc:Tn},Fn=C(a.IsNan,(function(e){return Number.isNaN(e)?1:0}),"bool"),Mn={kernelName:a.IsNan,backendName:"cpu",kernelFunc:Fn};var An={kernelName:a.LinSpace,backendName:"cpu",kernelFunc:function(e){var a=e.backend,t=e.attrs,n=fe(t.start,t.stop,t.num);return a.makeTensorInfo([n.length],"float32",n)}},wn=C(a.Log1p,(function(e){return Math.log1p(e)})),Dn={kernelName:a.Log1p,backendName:"cpu",kernelFunc:wn},_n=v((function(e,a){return e&&a})),En=F(a.LogicalAnd,_n,null,"bool"),zn={kernelName:a.LogicalAnd,backendName:"cpu",kernelFunc:En},Wn=C(a.LogicalNot,(function(e){return e?0:1}),"bool"),Cn={kernelName:a.LogicalNot,backendName:"cpu",kernelFunc:Wn},Hn=v((function(e,a){return e||a})),Pn=F(a.LogicalOr,Hn,null,"bool"),Rn={kernelName:a.LogicalOr,backendName:"cpu",kernelFunc:Pn};var Bn={kernelName:a.LRN,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.depthRadius,s=r.bias,u=r.alpha,d=r.beta;p(i,"LRN");var l=i.shape[3],c=l-1,f=n.data.get(i.dataId).values,h=a.util.sizeFromShape(i.shape),m=new Float32Array(h);function v(e){for(var a=e%l,t=e-a+Math.max(0,a-o),n=e-a+Math.min(a+o,c),r=0;t<=n;t++){var i=f[t];r+=i*i}return r}for(var k=0;k<h;k++){var g=v(k),b=f[k]*Math.pow(s+u*g,-d);m[k]=b}return n.makeTensorInfo(i.shape,i.dtype,m)}};var On={kernelName:a.LRNGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.y,s=t.dy,u=r.depthRadius,d=r.bias,l=r.alpha,c=r.beta;p(s,"LRNGrad");for(var f=a.util.sizeFromShape(s.shape),h=s.shape[3],m=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,k=n.data.get(o.dataId).values,g=new Float32Array(f),b=f,I=0;I<b;I++){for(var y=I%h,N=I-y+Math.max(0,y-u),x=I-y+Math.min(h,y+u+1),T=0,S=N;S<x;S++)T+=Math.pow(v[S],2);T=l*T+d;for(S=N;S<x;S++){var F=-2*l*c*v[S]*k[I]/T;I===S&&(F+=Math.pow(T,-c)),F*=m[I],g[S]+=F}}return n.makeTensorInfo(s.shape,i.dtype,g)}};function Gn(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.reductionIndices,s=r.keepDims,u=n,l=i.shape,c=l.length,f=a.util.parseAxisParam(o,l),h=f,m=a.backend_util.getAxesPermutation(h,c),v=u.data.get(i.dataId).values;if(null!=m){for(var k=new Array(c),g=0;g<k.length;g++)k[g]=l[m[g]];v=ze(v,l,i.dtype,m,k),h=a.backend_util.getInnerMostAxes(h.length,c),l=k}p(i,"max"),a.backend_util.assertAxesAreInnerMostDims("max",h,c);var b=d(a.backend_util.computeOutAndReduceShapes(l,h),2),I=b[0],y=b[1],N=ke(v,a.util.sizeFromShape(y),I,i.dtype),x=u.write(N,I,i.dtype),T=I;s&&(T=k=a.backend_util.expandShapeToKeepDim(I,f));return{dataId:x,shape:T,dtype:i.dtype}}var qn={kernelName:a.Max,backendName:"cpu",kernelFunc:Gn};var Ln={kernelName:a.MaxPool,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x;p(i,"maxPool");var o=r.filterSize,s=r.strides,u=r.pad,d=r.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(s,1),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+s+" and dilations '1'"}));var l,c=a.backend_util.computePool2DInfo(i.shape,o,s,1,u,d);if(1===c.filterWidth&&1===c.filterHeight&&a.util.arraysEqual(c.inShape,c.outShape))l=I({inputs:{x:i},backend:n});else{var f=n.data.get(i.dataId).values,h=a.util.computeStrides(i.shape),m=tt(f,i.shape,i.dtype,h,c,"max");l=n.makeTensorInfo(c.outShape,i.dtype,m.values)}return l}};var Vn={kernelName:a.MaxPool3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.filterSize,s=r.strides,u=r.pad,d=r.dimRoundingMode,l=r.dataFormat;p(i,"maxPool3d");var c=a.backend_util.computePool3DInfo(i.shape,o,s,1,u,d,l),f=rt(n.data.get(i.dataId).values,i.shape,i.dtype,a.util.computeStrides(i.shape),c,"max");return n.makeTensorInfo(f.shape,"float32",f.values)}};var Un={kernelName:a.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,s=r.filterSize,u=r.strides,d=r.pad,l=r.dimRoundingMode;p([i,o],"maxPool3DGrad");for(var c=a.backend_util.computePool3DInfo(o.shape,s,u,1,d,l),f=function(e,t){for(var n=a.buffer(t.outShape,"int32"),r=t.strideDepth,i=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,d=t.dilationWidth,l=t.effectiveFilterDepth,p=t.effectiveFilterHeight,c=t.effectiveFilterWidth,f=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left,v=0;v<t.batchSize;++v)for(var k=0;k<t.inChannels;++k)for(var g=0;g<t.outDepth;++g){for(var b=g*r-f,I=b;I<0;)I+=s;for(var y=Math.min(t.inDepth,l+b),N=0;N<t.outHeight;++N){for(var x=N*i-h,T=x;T<0;)T+=u;for(var S=Math.min(t.inHeight,p+x),F=0;F<t.outWidth;++F){for(var M=F*o-m,A=M;A<0;)A+=d;for(var w=Math.min(t.inWidth,c+M),D=Number.NEGATIVE_INFINITY,_=-1,E=I;E<y;E+=s)for(var z=E-b,W=T;W<S;W+=u)for(var C=W-x,H=A;H<w;H+=d){var P=H-M,R=e.get(v,E,W,H,k);R>=D&&(D=R,_=z*p*c+C*p+P)}n.set(_,v,g,N,F,k)}}}return n}(n.bufferSync(o),c),h=c.strideDepth,m=c.strideHeight,v=c.strideWidth,k=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,I=c.effectiveFilterDepth,y=c.effectiveFilterHeight,N=c.effectiveFilterWidth,x=I-1-c.padInfo.front,T=N-1-c.padInfo.left,S=y-1-c.padInfo.top,F=a.buffer(o.shape,"float32"),M=n.bufferSync(i),A=0;A<c.batchSize;++A)for(var w=0;w<c.inChannels;++w)for(var D=0;D<c.inDepth;++D)for(var _=0;_<c.inHeight;++_)for(var E=0;E<c.inWidth;++E){for(var z=D-x,W=_-S,C=E-T,H=0,P=0;P<I;P+=k){var R=(z+P)/h;if(!(R<0||R>=c.outDepth||Math.floor(R)!==R))for(var B=0;B<y;B+=g){var O=(W+B)/m;if(!(O<0||O>=c.outHeight||Math.floor(O)!==O))for(var G=0;G<N;G+=b){var q=(C+G)/v;if(!(q<0||q>=c.outWidth||Math.floor(q)!==q)){var L=I*y*N-1-f.get(A,R,O,q,w)===P*y*N+B*N+G?1:0;if(0!==L)H+=M.get(A,R,O,q,w)*L}}}}F.set(H,A,D,_,E,w)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}};var jn={kernelName:a.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,s=o;p([o,t.output],"maxPoolGrad");for(var u=r.filterSize,d=r.strides,l=r.pad,c=r.dimRoundingMode,f=a.backend_util.computePool2DInfo(s.shape,u,d,1,l,c),h=n.data.get(s.dataId).values,m=a.buffer(f.outShape,s.dtype,nt(h,s.shape,s.dtype,f).values),v=f.strideHeight,k=f.strideWidth,g=f.dilationHeight,b=f.dilationWidth,I=f.effectiveFilterHeight,y=f.effectiveFilterWidth,N=y-1-f.padInfo.left,x=I-1-f.padInfo.top,T=a.buffer(s.shape,"float32"),S=n.data.get(i.dataId).values,F=a.buffer(i.shape,"float32",S),M=0;M<f.batchSize;++M)for(var A=0;A<f.inChannels;++A)for(var w=0;w<f.inHeight;++w)for(var D=0;D<f.inWidth;++D){for(var _=w-x,E=D-N,z=0,W=0;W<I;W+=g){var C=(_+W)/v;if(!(C<0||C>=f.outHeight||Math.floor(C)!==C))for(var H=0;H<y;H+=b){var P=(E+H)/k;if(!(P<0||P>=f.outWidth||Math.floor(P)!==P)){var R=I*y-1-m.get(M,C,P,A)===W*y+H?1:0;if(0!==R)z+=F.get(M,C,P,A)*R}}}T.set(z,M,w,D,A)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};var Zn={kernelName:a.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,i=t.x,o=n.filterSize,s=n.strides,u=n.pad,l=n.includeBatchInIndex,c=r;p(i,"MaxPoolWithArgmax");var f=c.data.get(i.dataId).values,h=a.backend_util.computePool2DInfo(i.shape,o,s,[1,1],u),m=d(function(e,t,n,r,i){var o=tt(e,0,n,a.util.computeStrides(t),i,"max"),s=nt(e,t,n,i,!0,r);return[o.values,s.values]}(f,i.shape,i.dtype,l,h),2),v=m[0],k=m[1],g=c.write(v,h.outShape,i.dtype),b=c.write(k,h.outShape,i.dtype);return[{dataId:g,shape:h.outShape,dtype:i.dtype},{dataId:b,shape:h.outShape,dtype:"int32"}]}};var Kn={kernelName:a.Mean,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,s=r.keepDims,u=a.util.parseAxisParam(o,i.shape),d=a.backend_util.computeOutAndReduceShapes(i.shape,u)[1],l=a.util.sizeFromShape(d),p=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));p.push(c);var f=T({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});p.push(f);var h=rn({inputs:{a:f,b:c},backend:n});p.push(h);var m=Lt({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:s}});return p.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),m}};var Yn={kernelName:a.Min,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,s=r.keepDims;p(i,"min");var u=a.util.parseAxisParam(o,i.shape),l=u,c=a.backend_util.getAxesPermutation(l,i.shape.length),f=i;null!=c&&(f=We({inputs:{x:i},backend:n,attrs:{perm:c}}),l=a.backend_util.getInnerMostAxes(l.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",l,f.shape.length);for(var h=d(a.backend_util.computeOutAndReduceShapes(f.shape,l),2),m=h[0],v=h[1],k=a.util.sizeFromShape(v),g=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),b=n.data.get(f.dataId).values,I=0;I<g.length;++I){for(var y=I*k,N=b[y],x=0;x<k;++x){var T=b[y+x];(Number.isNaN(T)||T<N)&&(N=T)}g[I]=N}null!=c&&n.disposeIntermediateTensorInfo(f);var S=n.makeTensorInfo(m,f.dtype,g);if(s){var F=_a({inputs:{x:S},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(m,u)}});return n.disposeIntermediateTensorInfo(S),F}return S}};var Jn={kernelName:a.MirrorPad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.paddings,s=r.mode;p(i,"mirrorPad");for(var u=o.map((function(e,a){return e[0]+i.shape[a]+e[1]})),d=o.map((function(e){return e[0]})),l=o.map((function(e,a){return e[0]+i.shape[a]})),c="reflect"===s?0:1,f=n.data.get(i.dataId).values,h=i.shape.length,m=a.util.computeStrides(i.shape),v=a.util.sizeFromShape(u),k=u.length,g=a.util.computeStrides(u),b=a.util.getTypedArrayFromDType(i.dtype,v),I=0;I<v;I++){for(var y=a.util.indexToLoc(I,k,g),N=0;N<k;N++)y[N]<d[N]?y[N]=2*d[N]-y[N]-c:y[N]>=l[N]&&(y[N]=2*(l[N]-1)-y[N]+c);y=y.map((function(e,a){return e-d[a]}));var x=a.util.locToIndex(y,h,m);b[I]=f[x]}return{dataId:n.write(b,u,i.dtype),shape:u,dtype:i.dtype}}},Qn=v((function(e,a){var t=e%a;return e<0&&a<0||e>=0&&a>=0?t:(t+a)%a})),Xn=F(a.Mod,Qn),$n={kernelName:a.Mod,backendName:"cpu",kernelFunc:Xn};function er(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.logits,o=r.dim,s=i.shape.length,u=o;if(-1===u&&(u=s-1),u!==s-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+s+" and dim was "+u);var d=a.util.parseAxisParam([u],i.shape),l=Gn({inputs:{x:i},backend:n,attrs:{reductionIndices:d,keepDims:!1}}),p=a.backend_util.expandShapeToKeepDim(l.shape,d),c=_a({inputs:{x:l},backend:n,attrs:{shape:p}}),f=pa({inputs:{a:i,b:c},backend:n}),h=U({inputs:{x:f},backend:n}),m=Lt({inputs:{x:h},backend:n,attrs:{axis:d,keepDims:!1}}),v=_a({inputs:{x:m},backend:n,attrs:{shape:p}}),k=rn({inputs:{a:h,b:v},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(v),k}var ar={kernelName:a.Softmax,backendName:"cpu",kernelFunc:er};var tr={kernelName:a.Multinomial,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,i=e.attrs,o=t.logits,s=i.numSamples,u=i.seed,d=i.normalized;p(o,"multinomial");for(var l=d?o:er({inputs:{logits:o},backend:n,attrs:{dim:-1}}),c=l.shape[0],f=l.shape[1],h=n.data.get(l.dataId).values,m=[c,s],v=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),"int32"),k=0;k<c;++k){var g=k*f,b=new Float32Array(f-1);b[0]=h[g];for(var I=1;I<b.length;++I)b[I]=b[I-1]+h[g+I];for(var y=r.alea(u.toString()),N=k*s,x=0;x<s;++x){var T=y();v[N+x]=b.length;for(I=0;I<b.length;I++)if(T<b[I]){v[N+x]=I;break}}}return d||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(m,"int32",v)}},nr=a.kernel_impls.nonMaxSuppressionV3Impl;var rr={kernelName:a.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.boxes,i=a.scores,o=n.maxOutputSize,s=n.iouThreshold,u=n.scoreThreshold;p(r,"NonMaxSuppression");var d=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=nr(d,l,o,s,u).selectedIndices;return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}},ir=a.kernel_impls.nonMaxSuppressionV4Impl;var or={kernelName:a.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.boxes,i=a.scores,o=n.maxOutputSize,s=n.iouThreshold,u=n.scoreThreshold,d=n.padToMaxOutputSize;p(r,"NonMaxSuppressionPadded");var l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,f=ir(l,c,o,s,u,d),h=f.selectedIndices,m=f.validOutputs;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([m]))]}},sr=a.kernel_impls.nonMaxSuppressionV5Impl;var ur={kernelName:a.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.boxes,i=a.scores,o=n.maxOutputSize,s=n.iouThreshold,u=n.scoreThreshold,d=n.softNmsSigma;p(r,"NonMaxSuppressionWithScore");var l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,f=sr(l,c,o,s,u,d),h=f.selectedIndices,m=f.selectedScores;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([m.length],"float32",new Float32Array(m))]}};var dr={kernelName:a.OneHot,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.indices,o=r.depth,s=r.onValue,u=r.offValue;p(i,"oneHot");var d=a.util.sizeFromShape(i.shape),c=new Float32Array(d*o);c.fill(u);for(var f=n.data.get(i.dataId).values,h=0;h<d;++h)f[h]>=0&&f[h]<o&&(c[h*o+f[h]]=s);return n.makeTensorInfo(l(i.shape,[o]),"int32",c)}};function lr(e){var a=e.inputs,t=e.backend,n=a.x;if("string"===n.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===n.dtype){var r=N({inputs:{input:n},backend:t}),i=lr({inputs:{x:r},backend:t}),o=vt({inputs:{input:n},backend:t}),s=lr({inputs:{x:o},backend:t}),u=k({inputs:{real:i,imag:s},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),u}return pn({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var pr={kernelName:a.ZerosLike,backendName:"cpu",kernelFunc:lr};var cr={kernelName:a.OnesLike,backendName:"cpu",kernelFunc:function e(a){var t=a.inputs,n=a.backend,r=t.x;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){var i=N({inputs:{input:r},backend:n}),o=e({inputs:{x:i},backend:n}),s=vt({inputs:{input:r},backend:n}),u=lr({inputs:{x:s},backend:n}),d=k({inputs:{real:o,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(u),d}return pn({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function fr(e){var t=e.inputs,n=e.backend,r=e.attrs.axis;if(1===t.length)return an({inputs:{input:t[0]},backend:n,attrs:{dim:r}});var i=t[0].shape,o=t[0].dtype;t.forEach((function(e){a.util.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),a.util.assert(o===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var s=[],u=gt({inputs:t.map((function(e){var a=an({inputs:{input:e},backend:n,attrs:{dim:r}});return s.push(a),a})),backend:n,attrs:{axis:r}});return s.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),u}var hr={kernelName:a.Pack,backendName:"cpu",kernelFunc:fr};var mr={kernelName:a.PadV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.paddings,s=r.constantValue;p(i,"pad");var u=o.map((function(e,a){return e[0]+i.shape[a]+e[1]})),d=o.map((function(e){return e[0]})),l=n.data.get(i.dataId).values,c=a.util.sizeFromShape(i.shape),f=i.shape.length,h=a.util.computeStrides(i.shape),m=a.util.sizeFromShape(u),v=u.length,k=a.util.computeStrides(u),g=a.util.getTypedArrayFromDType(i.dtype,m);0!==s&&g.fill(s);for(var b=0;b<c;b++){var I=a.util.indexToLoc(b,f,h).map((function(e,a){return e+d[a]}));g[a.util.locToIndex(I,v,k)]=l[b]}return{dataId:n.write(g,u,i.dtype),shape:u,dtype:i.dtype}}},vr=v((function(e,a){return Math.pow(e,a)})),kr=F(a.Pow,vr),gr={kernelName:a.Pow,backendName:"cpu",kernelFunc:kr};var br={kernelName:a.Range,backendName:"cpu",kernelFunc:function(e){var a=e.backend,t=e.attrs,n=t.start,r=t.stop,i=t.dtype,o=Re(n,r,t.step,i);return a.makeTensorInfo([o.length],i,o)}},Ir=C(a.Reciprocal,(function(e){return 1/e})),yr={kernelName:a.Reciprocal,backendName:"cpu",kernelFunc:Ir};var Nr={kernelName:a.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=r.alignCorners,s=r.halfPixelCenters,u=r.size;p(i,"resizeBilinear");for(var l=a.util.computeStrides(i.shape),c=d(u,2),f=c[0],h=c[1],m=d(i.shape,4),v=m[0],k=m[1],g=m[2],b=m[3],I=n.data.get(i.dataId).values,y=new Float32Array(a.util.sizeFromShape([v,f,h,b])),N=[o&&f>1?k-1:k,o&&h>1?g-1:g],x=[o&&f>1?f-1:f,o&&h>1?h-1:h],T=0,S=N[0]/x[0],F=N[1]/x[1],M=0;M<v;M++)for(var A=0;A<f;A++){var w=void 0;w=s?S*(A+.5)-.5:S*A;for(var D=Math.max(0,Math.floor(w)),_=w-D,E=Math.min(k-1,Math.ceil(w)),z=M*l[0]+D*l[1],W=M*l[0]+E*l[1],C=0;C<h;C++){var H=void 0;H=s?F*(C+.5)-.5:F*C;for(var P=Math.max(0,Math.floor(H)),R=H-P,B=Math.min(g-1,Math.ceil(H)),O=z+P*l[2],G=W+P*l[2],q=z+B*l[2],L=W+B*l[2],V=0;V<b;V++){var U=I[O+V],j=I[G+V],Z=U+(I[q+V]-U)*R,K=Z+(j+(I[L+V]-j)*R-Z)*_;y[T++]=K}}}return n.makeTensorInfo([v,f,h,b],"float32",y)}};var xr={kernelName:a.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=t.dy,s=r.alignCorners;p([o,i],"resizeBilinearGrad");for(var u=a.util.computeStrides(i.shape),l=d(i.shape,4),c=l[0],f=l[1],h=l[2],m=l[3],v=d(o.shape,3),k=v[1],g=v[2],b=new Float32Array(c*f*h*m),I=[s&&k>1?f-1:f,s&&g>1?h-1:h],y=[s&&k>1?k-1:k,s&&g>1?g-1:g],N=I[0]/y[0],x=I[1]/y[1],T=n.data.get(o.dataId).values,S=0,F=0;F<c;F++)for(var M=F*u[0],A=0;A<k;A++)for(var w=A*N,D=Math.floor(w),_=Math.min(Math.ceil(w),f-1),E=M+D*u[1],z=M+_*u[1],W=w-D,C=1-W,H=0;H<g;H++)for(var P=H*x,R=Math.floor(P),B=Math.min(Math.ceil(P),h-1),O=P-R,G=1-O,q=E+R*u[2],L=E+B*u[2],V=z+R*u[2],U=z+B*u[2],j=C*G,Z=C*O,K=W*G,Y=W*O,J=0;J<m;J++){var Q=T[S++];b[q+J]+=Q*j,b[L+J]+=Q*Z,b[V+J]+=Q*K,b[U+J]+=Q*Y}return n.makeTensorInfo([c,h,f,m],"float32",b)}};var Tr={kernelName:a.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=r.alignCorners,s=r.halfPixelCenters,u=r.size;p(i,"resizeNearestNeighbor");for(var l=a.util.computeStrides(i.shape),c=d(u,2),f=c[0],h=c[1],m=d(i.shape,4),v=m[0],k=m[1],g=m[2],b=m[3],I=n.data.get(i.dataId).values,y=new Float32Array(v*f*h*b),N=[o&&f>1?k-1:k,o&&h>1?g-1:g],x=[o&&f>1?f-1:f,o&&h>1?h-1:h],T=N[0]/x[0],S=N[1]/x[1],F=0,M=0;M<v;M++)for(var A=M*l[0],w=0;w<f;w++){var D=s?T*(w+.5):T*w,_=Math.min(k-1,o?Math.round(D):Math.floor(D));s&&(_=Math.max(0,_));for(var E=A+_*l[1],z=0;z<h;z++){var W=s?S*(z+.5):S*z,C=Math.min(g-1,o?Math.round(W):Math.floor(W));s&&(C=Math.max(0,C));for(var H=E+C*l[2],P=0;P<b;P++){var R=I[H+P];y[F++]=R}}}return n.makeTensorInfo([v,f,h,b],i.dtype,y)}};var Sr={kernelName:a.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=t.dy,s=r.alignCorners;p([o,i],"resizeNearestNeighborGrad");for(var u=a.util.computeStrides(i.shape),l=a.util.computeStrides(o.shape),c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=d(o.shape,3),g=k[1],b=k[2],I=new Float32Array(f*h*m*v),y=n.data.get(o.dataId).values,N=[s&&g>1?h-1:h,s&&b>1?m-1:m],x=[s&&g>1?g-1:g,s&&b>1?b-1:b],T=N[0]/x[0],S=N[1]/x[1],F=1/T,M=1/S,A=2*Math.ceil(F)+2,w=2*Math.ceil(M)+2,D=0;D<f;D++)for(var _=D*u[0],E=0;E<h;E++)for(var z=_+E*u[1],W=Math.floor(E*F),C=Math.floor(W-A/2),H=0;H<m;H++)for(var P=z+H*u[2],R=Math.floor(H*M),B=Math.floor(R-w/2),O=0;O<v;O++){for(var G=0,q=0;q<A;q++){var L=q+C;if(!(L<0||L>=g)){var V=_+L*l[1],U=L*T;if(E===Math.min(h-1,s?Math.round(U):Math.floor(U)))for(var j=0;j<w;j++){var Z=j+B;if(!(Z<0||Z>=b)){var K=V+Z*l[2],Y=Z*S;H===Math.min(m-1,s?Math.round(Y):Math.floor(Y))&&(G+=y[K+O])}}}}I[P+O]=G}return n.makeTensorInfo(i.shape,i.dtype,I)}};var Fr={kernelName:a.Reverse,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.dims;p(i,"reverse");var s=i.shape.length,u=a.util.parseAxisParam(o,i.shape);if(0===s)return I({inputs:{x:i},backend:n});for(var d=new a.TensorBuffer(i.shape,i.dtype),c=n.bufferSync(i),f=function(e){var a=d.indexToLoc(e),t=a.slice();u.forEach((function(e){return t[e]=i.shape[e]-1-t[e]})),d.set.apply(d,l([c.get.apply(c,l(t))],a))},h=0;h<d.size;h++)f(h);return n.makeTensorInfo(d.shape,d.dtype,d.values)}},Mr={kernelName:a.RotateWithOffset,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.attrs,r=e.backend,i=t.image,o=n.radians,s=n.fillValue,u=n.center,l=r,p=a.util.getTypedArrayFromDType(i.dtype,a.util.sizeFromShape(i.shape)),c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=d(a.backend_util.getImageCenter(u,h,m),2),g=k[0],b=k[1],I=Math.sin(o),y=Math.cos(o),N=l.data.get(i.dataId).values,x=0;x<f;x++)for(var T=x*m*h*v,S=0;S<h;S++)for(var F=S*(m*v),M=0;M<m;M++)for(var A=M*v,w=0;w<v;w++){var D=[f,S,M,w],_=D[2],E=D[1],z=(_-g)*y-(E-b)*I,W=(_-g)*I+(E-b)*y;z=Math.round(z+g),W=Math.round(W+b);var C=s;if("number"!=typeof s&&(C=3===w?255:s[w]),z>=0&&z<m&&W>=0&&W<h)C=N[T+W*(m*v)+z*v+w];p[T+F+A+w]=C}return{dataId:l.write(p,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},Ar=C(a.Round,(function(e){var a=Math.floor(e);return e-a<.5?Math.floor(e):e-a>.5?Math.ceil(e):a%2==0?a:a+1})),wr={kernelName:a.Round,backendName:"cpu",kernelFunc:Ar};function Dr(e,t,n,r,i,o,s,u,d,l){var p=[r/i,i],c=e.values,f=t.values;if(0===r)return a.buffer(n,t.dtype);var h=a.buffer(p,t.dtype);h.values.fill(d);for(var m=0;m<o;m++){for(var v=[],k=0,g=0;g<s;g++){var b=c[m*s+g];v.push(b),k+=b*u[g]}if(k<0||k>=r/i)throw new Error("Invalid indices: "+v+" does not index into "+n);for(var I=0;I<i;I++)l?h.values[k*i+I]+=f[m*i+I]:h.values[k*i+I]=0===t.rank?f[0]:f[m*i+I]}return h}var _r={kernelName:a.ScatterNd,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.indices,o=t.updates,s=r.shape,u=a.backend_util.calculateShapes(o,i,s),d=u.sliceRank,l=u.numUpdates,p=u.sliceSize,c=u.strides,f=u.outputSize,h=Dr(n.bufferSync(i),n.bufferSync(o),s,f,p,l,d,c,0,!0);return n.makeTensorInfo(s,h.dtype,h.values)}};var Er={kernelName:a.Select,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.condition,i=t.t,o=t.e;p([r,i,o],"select");for(var s=r.shape.length,u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values,c=a.upcastType(i.dtype,o.dtype),f=a.util.makeZerosTypedArray(a.util.sizeFromShape(i.shape),c),h=0,m=0===s||s>1||1===i.shape.length?1:a.util.sizeFromShape(i.shape.slice(1)),v=0;v<u.length;v++)for(var k=0;k<m;k++)1===u[v]?f[h++]=d[v]:f[h++]=l[v];return n.makeTensorInfo(i.shape,c,f)}},zr=a.backend_util.SELU_SCALEALPHA,Wr=a.backend_util.SELU_SCALE,Cr=C(a.Selu,(function(e){return e>=0?Wr*e:zr*(Math.exp(e)-1)})),Hr={kernelName:a.Selu,backendName:"cpu",kernelFunc:Cr},Pr=C(a.Sign,(function(e){return e<0?-1:e>0?1:0})),Rr={kernelName:a.Sign,backendName:"cpu",kernelFunc:Pr},Br=C(a.Sin,(function(e){return Math.sin(e)})),Or={kernelName:a.Sin,backendName:"cpu",kernelFunc:Br},Gr=C(a.Sinh,(function(e){return Math.sinh(e)})),qr={kernelName:a.Sinh,backendName:"cpu",kernelFunc:Gr},Lr=Math.log(1.1920928955078125e-7)+2,Vr=C(a.Softplus,(function(e){var a=e>-Lr,t=e<Lr,n=Math.exp(e);return t?n:a?e:Math.log(1+n)})),Ur={kernelName:a.Softplus,backendName:"cpu",kernelFunc:Vr};var jr={kernelName:a.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.blockShape,s=r.paddings;p([i],"spaceToBatchND");var u=a.util.sizeFromShape(o),d=[[0,0]];d.push.apply(d,l(s));for(var c=1+o.length;c<i.shape.length;++c)d.push([0,0]);var f=mr.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:d,constantValue:0}}),h=a.backend_util.getReshaped(f.shape,o,u,!1),m=a.backend_util.getPermuted(h.length,o.length,!1),v=a.backend_util.getReshapedPermuted(f.shape,o,u,!1),k=_a({inputs:{x:f},backend:n,attrs:{shape:h}}),g=We({inputs:{x:k},backend:n,attrs:{perm:m}}),b=_a({inputs:{x:g},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(g),b}};var Zr={kernelName:a.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.indices,r=a.values,i=a.denseShape,o=a.defaultValue;if(1!==i.shape.length)throw new Error("Dense shape must be a vector, saw:\n        "+i.shape);if(2!==n.shape.length)throw new Error("Indices must be a matrix, saw:\n        "+n.shape);if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        "+r.shape);if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        "+o.shape);var s=t.data.get(n.dataId).values,u=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,p=t.data.get(o.dataId).values[0],c=d(Ke(s,n.shape,n.dtype,u,r.dtype,l,p),5),f=c[0],h=c[1],m=c[2],v=c[3],k=c[4];return[t.makeTensorInfo(h,n.dtype,f),t.makeTensorInfo([h[0]],r.dtype,m),t.makeTensorInfo([v.length],"bool",new Uint8Array(v.map((function(e){return Number(e)})))),t.makeTensorInfo([k.length],n.dtype,new Int32Array(k))]}};var Kr={kernelName:a.SparseReshape,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.inputIndices,r=a.inputShape,i=a.newShape;if(2!==n.shape.length)throw new Error("Input indices should be a matrix but received shape\n        "+n.shape);if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        "+r.shape);if(1!==i.shape.length)throw new Error("Target shape should be a vector but received shape "+i.shape);var o=Array.from(t.data.get(r.dataId).values),s=t.data.get(n.dataId).values,u=Array.from(t.data.get(i.dataId).values),l=d(Ye(s,n.shape,n.dtype,o,u),3),p=l[0],c=l[1],f=l[2];return[t.makeTensorInfo(c,n.dtype,p),t.makeTensorInfo([f.length],i.dtype,new Int32Array(f))]}};var Yr={kernelName:a.SparseSegmentMean,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.data,r=a.indices,i=a.segmentIds;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          "+r.shape);if(1!==i.shape.length)throw new Error("Segment ids should be a vector but received shape\n          "+i.shape);var o=t.data.get(n.dataId).values,s=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,l=d(Je(o,n.shape,n.dtype,s,u,!0),2),p=l[0],c=l[1];return t.makeTensorInfo(c,n.dtype,p)}};var Jr={kernelName:a.SparseSegmentSum,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.data,r=a.indices,i=a.segmentIds;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         "+r.shape);if(1!==i.shape.length)throw new Error("Segment ids should be a vector but received shape\n         "+i.shape);var o=t.data.get(n.dataId).values,s=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,l=d(Je(o,n.shape,n.dtype,s,u),2),p=l[0],c=l[1];return t.makeTensorInfo(c,n.dtype,p)}};var Qr={kernelName:a.SparseToDense,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.sparseIndices,o=t.sparseValues,s=t.defaultValue,u=r.outputShape,d=a.backend_util.calculateShapes(o,i,u),l=d.sliceRank,p=d.numUpdates,c=d.sliceSize,f=d.strides,h=d.outputSize,m=Dr(n.bufferSync(i),n.bufferSync(o),u,h,c,p,l,f,n.data.get(s.dataId).values[0],!1);return n.makeTensorInfo(u,m.dtype,m.values)}};var Xr={kernelName:a.SplitV,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.numOrSizeSplits,s=r.axis,u=a.util.parseAxisParam(s,i.shape)[0],d=a.backend_util.prepareSplitSize(i,o,u),p=new Array(i.shape.length).fill(0),c=i.shape.slice();return d.map((function(e){var a=l(c);a[u]=e;var t=je({inputs:{x:i},backend:n,attrs:{begin:p,size:a}});return p[u]+=e,t}))}},$r={kernelName:a.Square,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.x,r=t;p(n,"square");for(var i=r.data.get(n.dataId).values,o=new Float32Array(i.length),s=0;s<i.length;++s){var u=i[s];o[s]=u*u}return{dataId:r.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},ei=C(a.Step,(function(e,a){var t=a;return isNaN(e)?NaN:e>0?1:t.alpha})),ai={kernelName:a.Step,backendName:"cpu",kernelFunc:ei};var ti={kernelName:a.StridedSlice,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.begin,s=r.end,u=r.strides,d=r.beginMask,l=r.endMask,c=r.ellipsisMask,f=r.newAxisMask,h=r.shrinkAxisMask;p(i,"stridedSlice");var m,v=a.slice_util.sliceInfo(i.shape,o,s,u,d,l,c,f,h),k=v.finalShapeSparse,g=v.finalShape,b=v.isIdentity,I=v.sliceDim0,y=v.isSimpleSlice,N=v.begin,x=v.end,T=v.strides;if(b)m=_a({inputs:{x:i},backend:n,attrs:{shape:g}});else if(I||y){a.util.assert(i.shape.length>=1,(function(){return"Input must have rank at least 1, got: "+i.shape.length}));var S=a.slice_util.computeOutShape(N,x,T),F=je({inputs:{x:i},backend:n,attrs:{begin:N,size:S}});m=_a({inputs:{x:F},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(F)}else{var M=na(k,n.bufferSync(i),T,N);m=n.makeTensorInfo(g,M.dtype,M.values)}return m}};var ni={kernelName:a.StringNGrams,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=n.separator,i=n.nGramWidths,o=n.leftPad,s=n.rightPad,u=n.padWidth,l=n.preserveShortSequences,p=a.data,c=a.dataSplits,f=d(ia(t.data.get(p.dataId).values,t.data.get(c.dataId).values,r,i,o,s,u,l),2),h=f[0],m=f[1];return[t.makeTensorInfo([h.length],"string",h),t.makeTensorInfo(c.shape,"int32",m)]}};var ri={kernelName:a.StringSplit,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs.skipEmpty,r=a.input,i=a.delimiter;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(1!==r.shape.length)throw new Error("Input must be a vector, got shape: "+r.shape);if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: "+i.shape);var o=d(sa(t.data.get(r.dataId).values,t.data.get(i.dataId).values[0],n),3),s=o[0],u=o[1],l=o[2],p=u.length;return[t.makeTensorInfo([p,2],"int32",s),t.makeTensorInfo([p],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(l))]}};var ii={kernelName:a.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs.numBuckets,r=a.input;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(n<=0)throw new Error("Number of buckets must be at least 1");var i=ua(t.data.get(r.dataId).values,n);return t.makeTensorInfo(r.shape,"int32",i)}},oi=C(a.Tan,(function(e){return Math.tan(e)})),si={kernelName:a.Tan,backendName:"cpu",kernelFunc:oi},ui=C(a.Tanh,(function(e){return Math.tanh(e)})),di={kernelName:a.Tanh,backendName:"cpu",kernelFunc:ui};var li={kernelName:a.Tile,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=n.reps;p(r,"tile");var o=fa(t.bufferSync(r),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}};var pi={kernelName:a.TopK,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=n.k,o=n.sorted;p(r,"topk");var s=d(va(t.data.get(r.dataId).values,r.shape,r.dtype,i,o),2),u=s[0],l=s[1];return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}};var ci={kernelName:a.Transform,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,i=t.image,o=t.transforms,s=n.interpolation,u=n.fillMode,l=n.fillValue,p=n.outputShape,c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=d(null!=p?p:[h,m],2),g=k[0],b=k[1],I=[f,g,b,v],y=a.util.computeStrides(i.shape),N=y[0],x=y[1],T=y[2],S=a.util.getTypedArrayFromDType(i.dtype,a.util.sizeFromShape(I));S.fill(l);for(var F=r.data.get(i.dataId).values,M=r.data.get(o.dataId).values,A=0;A<f;++A){for(var w=1===o.shape[0]?M:M.subarray(8*A,8*A+8),D=0;D<g;++D)for(var _=0;_<b;++_)for(var E=0;E<v;++E){var z=void 0,W=w[6]*_+w[7]*D+1;if(0!==W){var C=(w[0]*_+w[1]*D+w[2])/W,H=(w[3]*_+w[4]*D+w[5])/W,P=fi(C,m,u),R=fi(H,h,u);switch(s){case"nearest":z=mi(F,h,m,N,x,T,A,R,P,E,l);break;case"bilinear":z=vi(F,h,m,N,x,T,A,R,P,E,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+s)}S[A*N+D*x+_*T+E]=z}}return r.makeTensorInfo(I,i.dtype,S)}return{dataId:r.write(S,I,i.dtype),shape:i.shape,dtype:i.dtype}}};function fi(e,t,n){switch(n){case"reflect":return function(e,t){var n=e;if(n<0){if(t<=1)n=0;else n<(r=2*t)&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1){var r;if(t<=1)n=0;else(n-=(r=2*t)*Math.trunc(n/r))>=t&&(n=r-n-1)}return a.util.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){var n=e;if(n<0)if(t<=1)n=0;else{var r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{r=t-1;n-=t*Math.trunc(n/r)}return a.util.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return a.util.clamp(0,e,t-1)}(e,t);case"constant":default:return function(e,a){return e}(e)}}function hi(e,a,t,n,r,i,o,s,u,d,l){return 0<=s&&s<a&&0<=u&&u<t?e[o*n+s*r+u*i+d]:l}function mi(e,a,t,n,r,i,o,s,u,d,l){return hi(e,a,t,n,r,i,o,Math.round(s),Math.round(u),d,l)}function vi(e,a,t,n,r,i,o,s,u,d,l){var p=Math.floor(s),c=Math.floor(u),f=p+1,h=c+1;return(f-s)*((h-u)*hi(e,a,t,n,r,i,o,p,c,d,l)+(u-c)*hi(e,a,t,n,r,i,o,p,h,d,l))+(s-p)*((h-u)*hi(e,a,t,n,r,i,o,f,c,d,l)+(u-c)*hi(e,a,t,n,r,i,o,f,h,d,l))}var ki={kernelName:a.Unique,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.attrs,n=e.backend,r=t.axis,i=a.x;p(i,"unique");var o=ka(n.data.get(i.dataId).values,r,i.shape,i.dtype),s=o.outputValues,u=o.outputShape,d=o.indices;return[n.makeTensorInfo(u,i.dtype,s),n.makeTensorInfo([d.length],"int32",d)]}};var gi={kernelName:a.Unpack,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.value,i=n.axis;i<0&&(i+=r.shape.length);for(var o=r.shape.length,s=r.shape[i],u=new Array(o-1),d=0,l=0;l<o;l++)l!==i&&(u[d++]=r.shape[l]);var p=new Array(o).fill(0),c=r.shape.slice();c[i]=1;var f=new Array(s);for(l=0;l<f.length;l++){p[i]=l;var h=je({inputs:{x:r},backend:t,attrs:{begin:p,size:c}});f[l]=_a({inputs:{x:h},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(h)}return f}};var bi,Ii,yi={kernelName:a.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.segmentIds,s=r.numSegments;p(i,"unsortedSegmentSum");for(var u=[],d=[],l=i.shape.length-o.shape.length,c=o,f=0;f<l;++f){var h=an({inputs:{input:c},backend:n,attrs:{dim:f+1}});c=h,d.push(h)}for(f=0;f<s;++f){var m=a.util.createScalarValue(f,"int32"),v=n.makeTensorInfo([],"int32",m),k=q({inputs:{a:v,b:c},backend:n}),g=T({inputs:{x:k},backend:n,attrs:{dtype:"float32"}}),b=Fe({inputs:{a:g,b:i},backend:n}),I=Lt({inputs:{x:b},backend:n,attrs:{axis:0,keepDims:!1}});u.push(I),d.push(v),d.push(k),d.push(g),d.push(b),d.push(I)}var y=fr({inputs:u,backend:n,attrs:{axis:0}});return d.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),y}},Ni=[Ca,m,Pa,Ba,_,Oa,Ga,qa,La,Va,ja,Ka,Ja,$a,at,it,ot,st,ut,Wa,dt,lt,pt,ct,S,B,ht,g,mt,bt,Nt,xt,yt,St,Ft,Tt,At,Dt,_t,Et,zt,Wt,Ht,Pt,Rt,Bt,Ot,qt,Gt,on,Ut,Ia,jt,L,en,j,tn,Y,ln,cn,fn,X,vn,kn,gn,bn,In,ne,oe,y,yn,kt,xn,Sn,Mn,Na,de,ce,An,ve,Dn,zn,Cn,Rn,Bn,On,Ie,Ln,Vn,Un,jn,Zn,qn,Kn,Yn,xe,Jn,$n,tr,Me,we,rr,or,ur,Ee,dr,cr,hr,mr,gr,Sa,Pe,br,x,yr,Ma,wa,Ea,Nr,xr,Tr,Sr,Fr,Mr,wr,Ge,_r,Er,Hr,Ve,Rr,Or,qr,Ze,ar,Ur,jr,Zr,Kr,Yr,Jr,Qr,Xr,$e,$r,ta,ai,ti,ni,ri,ii,ca,Vt,si,di,li,pi,Ce,ci,ki,gi,yi,pr];try{for(var xi=u(Ni),Ti=xi.next();!Ti.done;Ti=xi.next()){var Si=Ti.value;a.registerKernel(Si)}}catch(e){bi={error:e}}finally{try{Ti&&!Ti.done&&(Ii=xi.return)&&Ii.call(xi)}finally{if(bi)throw bi.error}}e.MathBackendCPU=f,e.shared=ga,e.version_cpu="3.11.0",Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-cpu.min.js.map
