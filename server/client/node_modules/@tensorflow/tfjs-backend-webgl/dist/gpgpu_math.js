/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, env, util } from '@tensorflow/tfjs-core';
import * as shader_compiler from './shader_compiler';
export function compileProgram(gpgpu, program, inputs, output) {
    const inputInfos = inputs.map((input, i) => {
        const shapeInfo = {
            logicalShape: input.shape,
            texShape: input.isUniform ? null : input.texData.texShape,
            isUniform: input.isUniform,
            isPacked: input.isUniform ? false : input.texData.isPacked,
            flatOffset: null
        };
        if (input.texData != null && input.texData.slice != null &&
            input.texData.slice.flatOffset > 0) {
            shapeInfo.flatOffset = input.texData.slice.flatOffset;
        }
        return { name: program.variableNames[i], shapeInfo };
    });
    const inShapeInfos = inputInfos.map(x => x.shapeInfo);
    const outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.texData.texShape,
        isUniform: false,
        isPacked: output.texData.isPacked,
        flatOffset: null
    };
    const source = shader_compiler.makeShader(inputInfos, outShapeInfo, program);
    const webGLProgram = gpgpu.createProgram(source);
    // Add special uniforms (NAN, INFINITY)
    let infLoc = null;
    const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);
    if (env().getNumber('WEBGL_VERSION') === 1) {
        infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);
    }
    // Add user-defined uniforms
    const shouldThrow = false;
    const uniformLocations = {};
    const inShapesLocations = {};
    const inTexShapesLocations = {};
    for (let i = 0; i < program.variableNames.length; i++) {
        const varName = program.variableNames[i];
        uniformLocations[varName] =
            gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
        uniformLocations[`offset${varName}`] =
            gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
        if (program.enableShapeUniforms) {
            inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);
            inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);
        }
    }
    let outShapeLocation;
    let outTexShapeLocation;
    let outShapeStridesLocation;
    if (program.enableShapeUniforms) {
        outShapeLocation =
            gpgpu.getUniformLocation(webGLProgram, 'outShape', shouldThrow);
        outShapeStridesLocation =
            gpgpu.getUniformLocation(webGLProgram, 'outShapeStrides', shouldThrow);
        outTexShapeLocation =
            gpgpu.getUniformLocation(webGLProgram, 'outTexShape', shouldThrow);
    }
    const customUniformLocations = [];
    if (program.customUniforms) {
        program.customUniforms.forEach((d, i) => {
            customUniformLocations[i] =
                gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow);
        });
    }
    return {
        program,
        source,
        webGLProgram,
        uniformLocations,
        customUniformLocations,
        inShapeInfos,
        outShapeInfo,
        infLoc,
        nanLoc,
        inShapesLocations,
        inTexShapesLocations,
        outShapeLocation,
        outShapeStridesLocation,
        outTexShapeLocation
    };
}
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` +
            `was executed with ${inputs.length} inputs`);
    }
    shapeInfos.forEach((s, i) => {
        const shapeA = s.logicalShape;
        const input = inputs[i];
        const shapeB = input.shape;
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error(`Binary was compiled with different shapes than ` +
                `the current args. Shapes ${shapeA} and ${shapeB} must match`);
        }
        // The input is uploaded as uniform.
        if (s.isUniform && input.isUniform) {
            return;
        }
        const texShapeA = s.texShape;
        const texShapeB = input.isUniform ? null : input.texData.texShape;
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error(`Binary was compiled with different texture shapes than the` +
                ` current args. Shape ${texShapeA} and ${texShapeB} must match`);
        }
    });
}
export function runProgram(gpgpu, binary, inputs, output, customUniformValues) {
    if (!binary.program.enableShapeUniforms) {
        validateBinaryAndProgram(binary.inShapeInfos, inputs);
        validateBinaryAndProgram([binary.outShapeInfo], [output]);
    }
    const outTex = output.texData.texture;
    const outTexShape = output.texData.texShape;
    if (output.texData.isPacked) {
        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    }
    else {
        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    }
    gpgpu.setProgram(binary.webGLProgram);
    // Set special uniforms (NAN, INFINITY)
    if (env().getNumber('WEBGL_VERSION') === 1) {
        if (binary.infLoc !== null) {
            gpgpu.gl.uniform1f(binary.infLoc, Infinity);
        }
    }
    if (binary.nanLoc !== null) {
        gpgpu.gl.uniform1f(binary.nanLoc, NaN);
    }
    // Set user-defined inputs
    inputs.forEach((input, i) => {
        const varName = binary.program.variableNames[i];
        const varLoc = binary.uniformLocations[varName];
        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
        const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];
        const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];
        if (varShapeLoc) {
            const { uniformShape } = shader_compiler.getUniformInfoFromShape(binary.program.packedInputs, input.shape, input.texData.texShape);
            switch (uniformShape.length) {
                case 1:
                    gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                case 2:
                    gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                case 3:
                    gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                case 4:
                    gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                default:
                    break;
            }
        }
        if (varTexShapeLoc) {
            gpgpu.gl.uniform2i(varTexShapeLoc, input.texData.texShape[0], input.texData.texShape[1]);
        }
        if (varLoc == null) {
            // The compiler inferred that this variable is not used in this shader.
            return;
        }
        if (input.isUniform) {
            // Upload the values of the tensor as uniform.
            if (util.sizeFromShape(input.shape) < 2) {
                gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);
            }
            else {
                let vals = input.uniformValues;
                if (!(vals instanceof Float32Array)) {
                    vals = new Float32Array(vals);
                }
                gpgpu.gl.uniform1fv(varLoc, vals);
            }
            return;
        }
        // If the input was sliced, upload the flat offset index.
        if (input.texData.slice != null && varOffsetLoc != null) {
            gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);
        }
        gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);
    });
    const outShapeLoc = binary.outShapeLocation;
    if (outShapeLoc) {
        switch (output.shape.length) {
            case 1:
                gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));
                break;
            case 2:
                gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));
                break;
            case 3:
                gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));
                break;
            case 4:
                gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));
                break;
            default:
                break;
        }
    }
    if (binary.outShapeStridesLocation) {
        const strides = util.computeStrides(output.shape);
        switch (output.shape.length) {
            case 2:
                gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));
                break;
            case 3:
                gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));
                break;
            case 4:
                gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));
                break;
            default:
                break;
        }
    }
    if (binary.outTexShapeLocation) {
        gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);
    }
    if (binary.program.customUniforms && customUniformValues) {
        binary.program.customUniforms.forEach((d, i) => {
            const customLoc = binary.customUniformLocations[i];
            const customValue = customUniformValues[i];
            if (d.type === 'float') {
                gpgpu.gl.uniform1fv(customLoc, customValue);
            }
            else if (d.type === 'vec2') {
                gpgpu.gl.uniform2fv(customLoc, customValue);
            }
            else if (d.type === 'vec3') {
                gpgpu.gl.uniform3fv(customLoc, customValue);
            }
            else if (d.type === 'vec4') {
                gpgpu.gl.uniform4fv(customLoc, customValue);
            }
            else if (d.type === 'int') {
                gpgpu.gl.uniform1iv(customLoc, customValue);
            }
            else if (d.type === 'ivec2') {
                gpgpu.gl.uniform2iv(customLoc, customValue);
            }
            else if (d.type === 'ivec3') {
                gpgpu.gl.uniform3iv(customLoc, customValue);
            }
            else if (d.type === 'ivec4') {
                gpgpu.gl.uniform4iv(customLoc, customValue);
            }
            else {
                throw Error(`uniform type ${d.type} is not supported yet.`);
            }
        });
    }
    gpgpu.executeProgram();
}
export function makeShaderKey(program, inputs, output) {
    let keyInputs = '';
    inputs.concat(output).forEach(x => {
        const hasOffset = x.texData != null && x.texData.slice != null &&
            x.texData.slice.flatOffset > 0;
        // TODO: Remove the condition of !x.isUniform.
        if (program.enableShapeUniforms && !x.isUniform) {
            const xTexShape = x.texData.texShape;
            const { useSqueezeShape, uniformShape, keptDims } = shader_compiler.getUniformInfoFromShape(program.packedInputs, x.shape, xTexShape);
            let rank1 = '', rank2 = '', rank34 = '';
            if (uniformShape.length === 1 && program.packedInputs) {
                const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];
                rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;
            }
            else if (uniformShape.length === 2 && !program.packedInputs) {
                rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;
            }
            else if (uniformShape.length > 2 && !program.packedInputs) {
                const strides = util.computeStrides(uniformShape);
                rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;
            }
            const xRank = x.shape.length;
            const isLogicalShapTexShapeEqual = uniformShape.length === 2 && util.arraysEqual(x.shape, xTexShape);
            const isScalar = util.sizeFromShape(x.shape) === 1;
            const broadcastDims = backend_util.getBroadcastDims(x.shape, output.shape);
            const isInOutTexShapeEqual = !program.packedInputs &&
                xRank === output.shape.length &&
                util.arraysEqual(xTexShape, output.texData.texShape);
            const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ?
                '' :
                `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;
            // These key components are needed due to shader_compiler is embedding
            // them in the shader.
            // |xRank| is used to determine the coords length. See
            // get[Packed]SamplerAtOutputCoords.
            // |isInOutTexShapeEqual| is used to determine whether going to an
            // optimization path in getSamplerAtOutputCoords.
            // |useSqueezeShape| is extracted from squeezeInputInfo of
            // getSampler[2|3|4]D/getPackedSampler3D.
            // |isScalar| is extracted from isInputScalar/isOutputScalar in
            // getPackedSamplerAtOutputCoords.
            // |broadcastDims| is extracted from get[Packed]SamplerAtOutputCoords.
            // |isLogicalShapTexShapeEqual| is used in
            // getOutput[Packed]2DCoords/get[Packed]Sampler2D.
            // |rank1| is used in getOutputPacked1DCoords.
            // |rank2| is used in getOutput2DCoords.
            // |rank34| is used in getSampler3D/getSampler4D.
            // |isTexShapeGreaterThanOne| are used in
            // getSampler[Scalar|1D|2D]/getOutput1DCoords.
            keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ''}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;
        }
        else {
            const texShape = x.isUniform ? 'uniform' : x.texData.texShape;
            keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
        }
    });
    const keyUserCode = program.userCode;
    let key = program.constructor.name;
    // Fast string concat. See https://jsperf.com/string-concatenation/14.
    key += '_' + keyInputs + '_' + keyUserCode +
        `${env().getNumber('WEBGL_VERSION')}`;
    return key;
}
export function useShapeUniforms(rank) {
    // TODO: Remove the limitaion of rank <= 4.
    return env().getBool('WEBGL_USE_SHAPES_UNIFORMS') && rank <= 4;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3BncHVfbWF0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvZ3BncHVfbWF0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUFFLEdBQUcsRUFBc0IsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHbEYsT0FBTyxLQUFLLGVBQWUsTUFBTSxtQkFBbUIsQ0FBQztBQW9EckQsTUFBTSxVQUFVLGNBQWMsQ0FDMUIsS0FBbUIsRUFBRSxPQUFxQixFQUFFLE1BQW9CLEVBQ2hFLE1BQWtCO0lBQ3BCLE1BQU0sVUFBVSxHQUFnQixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RELE1BQU0sU0FBUyxHQUFjO1lBQzNCLFlBQVksRUFBRSxLQUFLLENBQUMsS0FBSztZQUN6QixRQUFRLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVE7WUFDekQsU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTO1lBQzFCLFFBQVEsRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUTtZQUMxRCxVQUFVLEVBQUUsSUFBSTtTQUNqQixDQUFDO1FBQ0YsSUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJO1lBQ3BELEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUU7WUFDdEMsU0FBUyxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7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MkNBQTJDO0lBQzNDLE9BQU8sR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLDJCQUEyQixDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQztBQUNqRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgZW52LCBUZW5zb3IsIFR5cGVkQXJyYXksIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuaW1wb3J0ICogYXMgc2hhZGVyX2NvbXBpbGVyIGZyb20gJy4vc2hhZGVyX2NvbXBpbGVyJztcbmltcG9ydCB7SW5wdXRJbmZvLCBTaGFwZUluZm8sIFVuaWZvcm1UeXBlfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5pbXBvcnQge1BhY2tpbmdTY2hlbWUsIFRleHR1cmVEYXRhLCBUZXh0dXJlVXNhZ2V9IGZyb20gJy4vdGV4X3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXM6IHN0cmluZ1tdO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIGVuYWJsZVNoYXBlVW5pZm9ybXM/OiBib29sZWFuO1xuICAvKiogSWYgdHJ1ZSwgdGhpcyBwcm9ncmFtIGV4cGVjdHMgcGFja2VkIGlucHV0IHRleHR1cmVzLiBEZWZhdWx0cyB0byBmYWxzZS4gKi9cbiAgcGFja2VkSW5wdXRzPzogYm9vbGVhbjtcbiAgLyoqIElmIHRydWUsIHRoaXMgcHJvZ3JhbSBwcm9kdWNlcyBhIHBhY2tlZCB0ZXh0dXJlLiBEZWZhdWx0cyB0byBmYWxzZS4gKi9cbiAgcGFja2VkT3V0cHV0PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFmZmVjdHMgd2hhdCB0eXBlIG9mIHRleHR1cmUgd2UgYWxsb2NhdGUgZm9yIHRoZSBvdXRwdXQuIERlZmF1bHRzIHRvXG4gICAqIGBUZXh0dXJlVXNhZ2UuUkVOREVSYC5cbiAgICovXG4gIG91dFRleFVzYWdlPzogVGV4dHVyZVVzYWdlO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygc2NoZW1lIHRvIHVzZSB3aGVuIHBhY2tpbmcgdGV4ZWxzIGZvciB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICogU2VlIGBQYWNraW5nU2NoZW1lYCBmb3IgZGV0YWlscy4gRGVmYXVsdHMgdG8gYFBhY2tpbmdTY2hlbWUuU0hBUkVEX0JBVENIYC5cbiAgICovXG4gIG91dFBhY2tpbmdTY2hlbWU/OiBQYWNraW5nU2NoZW1lO1xuICBjdXN0b21Vbmlmb3Jtcz86XG4gICAgICBBcnJheTx7bmFtZTogc3RyaW5nOyBhcnJheUluZGV4PzogbnVtYmVyOyB0eXBlOiBVbmlmb3JtVHlwZTt9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHUEdQVUJpbmFyeSB7XG4gIHdlYkdMUHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICBwcm9ncmFtOiBHUEdQVVByb2dyYW07XG4gIHVuaWZvcm1Mb2NhdGlvbnM6IHtbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb259O1xuICBjdXN0b21Vbmlmb3JtTG9jYXRpb25zPzogV2ViR0xVbmlmb3JtTG9jYXRpb25bXTtcbiAgc291cmNlOiBzdHJpbmc7XG4gIGluU2hhcGVJbmZvczogU2hhcGVJbmZvW107XG4gIG91dFNoYXBlSW5mbzogU2hhcGVJbmZvO1xuICBpbmZMb2M6IFdlYkdMVW5pZm9ybUxvY2F0aW9uO1xuICBuYW5Mb2M6IFdlYkdMVW5pZm9ybUxvY2F0aW9uO1xuICBpblNoYXBlc0xvY2F0aW9ucz86IHtbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb259O1xuICBpblRleFNoYXBlc0xvY2F0aW9ucz86IHtbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb259O1xuICBvdXRTaGFwZUxvY2F0aW9uPzogV2ViR0xVbmlmb3JtTG9jYXRpb247XG4gIG91dFNoYXBlU3RyaWRlc0xvY2F0aW9uPzogV2ViR0xVbmlmb3JtTG9jYXRpb247XG4gIG91dFRleFNoYXBlTG9jYXRpb24/OiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JEYXRhIHtcbiAgc2hhcGU6IG51bWJlcltdO1xuICB0ZXhEYXRhOiBUZXh0dXJlRGF0YTtcbiAgaXNVbmlmb3JtOiBib29sZWFuO1xuICAvLyBBdmFpbGFibGUgd2hlbiB3ZSBkZWNpZGUgdG8gdXBsb2FkIGFzIHVuaWZvcm0gaW5zdGVhZCBvZiB0ZXh0dXJlLlxuICB1bmlmb3JtVmFsdWVzPzogVHlwZWRBcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVQcm9ncmFtPFQgZXh0ZW5kcyBUZW5zb3IsIEsgZXh0ZW5kcyBUZW5zb3I+KFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IEdQR1BVUHJvZ3JhbSwgaW5wdXRzOiBUZW5zb3JEYXRhW10sXG4gICAgb3V0cHV0OiBUZW5zb3JEYXRhKTogR1BHUFVCaW5hcnkge1xuICBjb25zdCBpbnB1dEluZm9zOiBJbnB1dEluZm9bXSA9IGlucHV0cy5tYXAoKGlucHV0LCBpKSA9PiB7XG4gICAgY29uc3Qgc2hhcGVJbmZvOiBTaGFwZUluZm8gPSB7XG4gICAgICBsb2dpY2FsU2hhcGU6IGlucHV0LnNoYXBlLFxuICAgICAgdGV4U2hhcGU6IGlucHV0LmlzVW5pZm9ybSA/IG51bGwgOiBpbnB1dC50ZXhEYXRhLnRleFNoYXBlLFxuICAgICAgaXNVbmlmb3JtOiBpbnB1dC5pc1VuaWZvcm0sXG4gICAgICBpc1BhY2tlZDogaW5wdXQuaXNVbmlmb3JtID8gZmFsc2UgOiBpbnB1dC50ZXhEYXRhLmlzUGFja2VkLFxuICAgICAgZmxhdE9mZnNldDogbnVsbFxuICAgIH07XG4gICAgaWYgKGlucHV0LnRleERhdGEgIT0gbnVsbCAmJiBpbnB1dC50ZXhEYXRhLnNsaWNlICE9IG51bGwgJiZcbiAgICAgICAgaW5wdXQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0ID4gMCkge1xuICAgICAgc2hhcGVJbmZvLmZsYXRPZmZzZXQgPSBpbnB1dC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB7bmFtZTogcHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldLCBzaGFwZUluZm99O1xuICB9KTtcbiAgY29uc3QgaW5TaGFwZUluZm9zID0gaW5wdXRJbmZvcy5tYXAoeCA9PiB4LnNoYXBlSW5mbyk7XG4gIGNvbnN0IG91dFNoYXBlSW5mbzogU2hhcGVJbmZvID0ge1xuICAgIGxvZ2ljYWxTaGFwZTogb3V0cHV0LnNoYXBlLFxuICAgIHRleFNoYXBlOiBvdXRwdXQudGV4RGF0YS50ZXhTaGFwZSxcbiAgICBpc1VuaWZvcm06IGZhbHNlLFxuICAgIGlzUGFja2VkOiBvdXRwdXQudGV4RGF0YS5pc1BhY2tlZCxcbiAgICBmbGF0T2Zmc2V0OiBudWxsXG4gIH07XG4gIGNvbnN0IHNvdXJjZSA9IHNoYWRlcl9jb21waWxlci5tYWtlU2hhZGVyKGlucHV0SW5mb3MsIG91dFNoYXBlSW5mbywgcHJvZ3JhbSk7XG5cbiAgY29uc3Qgd2ViR0xQcm9ncmFtID0gZ3BncHUuY3JlYXRlUHJvZ3JhbShzb3VyY2UpO1xuXG4gIC8vIEFkZCBzcGVjaWFsIHVuaWZvcm1zIChOQU4sIElORklOSVRZKVxuICBsZXQgaW5mTG9jOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IG51bGw7XG4gIGNvbnN0IG5hbkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdOQU4nLCBmYWxzZSk7XG4gIGlmIChlbnYoKS5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMSkge1xuICAgIGluZkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdJTkZJTklUWScsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIEFkZCB1c2VyLWRlZmluZWQgdW5pZm9ybXNcbiAgY29uc3Qgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgY29uc3QgdW5pZm9ybUxvY2F0aW9uczoge1tuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbn0gPSB7fTtcbiAgY29uc3QgaW5TaGFwZXNMb2NhdGlvbnM6IHtbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb259ID0ge307XG4gIGNvbnN0IGluVGV4U2hhcGVzTG9jYXRpb25zOiB7W25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9ufSA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW0udmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhck5hbWUgPSBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgdW5pZm9ybUxvY2F0aW9uc1t2YXJOYW1lXSA9XG4gICAgICAgIGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIHZhck5hbWUsIHNob3VsZFRocm93KTtcbiAgICB1bmlmb3JtTG9jYXRpb25zW2BvZmZzZXQke3Zhck5hbWV9YF0gPVxuICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCBgb2Zmc2V0JHt2YXJOYW1lfWAsIHNob3VsZFRocm93KTtcbiAgICBpZiAocHJvZ3JhbS5lbmFibGVTaGFwZVVuaWZvcm1zKSB7XG4gICAgICBpblNoYXBlc0xvY2F0aW9uc1tgJHt2YXJOYW1lfVNoYXBlYF0gPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24oXG4gICAgICAgICAgd2ViR0xQcm9ncmFtLCBgJHt2YXJOYW1lfVNoYXBlYCwgc2hvdWxkVGhyb3cpO1xuICAgICAgaW5UZXhTaGFwZXNMb2NhdGlvbnNbYCR7dmFyTmFtZX1UZXhTaGFwZWBdID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKFxuICAgICAgICAgIHdlYkdMUHJvZ3JhbSwgYCR7dmFyTmFtZX1UZXhTaGFwZWAsIHNob3VsZFRocm93KTtcbiAgICB9XG4gIH1cblxuICBsZXQgb3V0U2hhcGVMb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb247XG4gIGxldCBvdXRUZXhTaGFwZUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbiAgbGV0IG91dFNoYXBlU3RyaWRlc0xvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbiAgaWYgKHByb2dyYW0uZW5hYmxlU2hhcGVVbmlmb3Jtcykge1xuICAgIG91dFNoYXBlTG9jYXRpb24gPVxuICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnb3V0U2hhcGUnLCBzaG91bGRUaHJvdyk7XG4gICAgb3V0U2hhcGVTdHJpZGVzTG9jYXRpb24gPVxuICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnb3V0U2hhcGVTdHJpZGVzJywgc2hvdWxkVGhyb3cpO1xuICAgIG91dFRleFNoYXBlTG9jYXRpb24gPVxuICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnb3V0VGV4U2hhcGUnLCBzaG91bGRUaHJvdyk7XG4gIH1cblxuICBjb25zdCBjdXN0b21Vbmlmb3JtTG9jYXRpb25zOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbltdID0gW107XG4gIGlmIChwcm9ncmFtLmN1c3RvbVVuaWZvcm1zKSB7XG4gICAgcHJvZ3JhbS5jdXN0b21Vbmlmb3Jtcy5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICBjdXN0b21Vbmlmb3JtTG9jYXRpb25zW2ldID1cbiAgICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCBkLm5hbWUsIHNob3VsZFRocm93KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvZ3JhbSxcbiAgICBzb3VyY2UsXG4gICAgd2ViR0xQcm9ncmFtLFxuICAgIHVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgY3VzdG9tVW5pZm9ybUxvY2F0aW9ucyxcbiAgICBpblNoYXBlSW5mb3MsXG4gICAgb3V0U2hhcGVJbmZvLFxuICAgIGluZkxvYyxcbiAgICBuYW5Mb2MsXG4gICAgaW5TaGFwZXNMb2NhdGlvbnMsXG4gICAgaW5UZXhTaGFwZXNMb2NhdGlvbnMsXG4gICAgb3V0U2hhcGVMb2NhdGlvbixcbiAgICBvdXRTaGFwZVN0cmlkZXNMb2NhdGlvbixcbiAgICBvdXRUZXhTaGFwZUxvY2F0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShcbiAgICBzaGFwZUluZm9zOiBTaGFwZUluZm9bXSwgaW5wdXRzOiBUZW5zb3JEYXRhW10pIHtcbiAgaWYgKHNoYXBlSW5mb3MubGVuZ3RoICE9PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggJHtzaGFwZUluZm9zLmxlbmd0aH0gaW5wdXRzLCBidXQgYCArXG4gICAgICAgIGB3YXMgZXhlY3V0ZWQgd2l0aCAke2lucHV0cy5sZW5ndGh9IGlucHV0c2ApO1xuICB9XG5cbiAgc2hhcGVJbmZvcy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgY29uc3Qgc2hhcGVBID0gcy5sb2dpY2FsU2hhcGU7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dHNbaV07XG4gICAgY29uc3Qgc2hhcGVCID0gaW5wdXQuc2hhcGU7XG5cbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCBzaGFwZXMgdGhhbiBgICtcbiAgICAgICAgICBgdGhlIGN1cnJlbnQgYXJncy4gU2hhcGVzICR7c2hhcGVBfSBhbmQgJHtzaGFwZUJ9IG11c3QgbWF0Y2hgKTtcbiAgICB9XG4gICAgLy8gVGhlIGlucHV0IGlzIHVwbG9hZGVkIGFzIHVuaWZvcm0uXG4gICAgaWYgKHMuaXNVbmlmb3JtICYmIGlucHV0LmlzVW5pZm9ybSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRleFNoYXBlQSA9IHMudGV4U2hhcGU7XG4gICAgY29uc3QgdGV4U2hhcGVCID0gaW5wdXQuaXNVbmlmb3JtID8gbnVsbCA6IGlucHV0LnRleERhdGEudGV4U2hhcGU7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKHRleFNoYXBlQSwgdGV4U2hhcGVCKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYEJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGVgICtcbiAgICAgICAgICBgIGN1cnJlbnQgYXJncy4gU2hhcGUgJHt0ZXhTaGFwZUF9IGFuZCAke3RleFNoYXBlQn0gbXVzdCBtYXRjaGApO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW5Qcm9ncmFtPFQgZXh0ZW5kcyBUZW5zb3IsIEsgZXh0ZW5kcyBUZW5zb3I+KFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIGJpbmFyeTogR1BHUFVCaW5hcnksIGlucHV0czogVGVuc29yRGF0YVtdLFxuICAgIG91dHB1dDogVGVuc29yRGF0YSwgY3VzdG9tVW5pZm9ybVZhbHVlcz86IG51bWJlcltdW10pOiB2b2lkIHtcbiAgaWYgKCFiaW5hcnkucHJvZ3JhbS5lbmFibGVTaGFwZVVuaWZvcm1zKSB7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKGJpbmFyeS5pblNoYXBlSW5mb3MsIGlucHV0cyk7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKFtiaW5hcnkub3V0U2hhcGVJbmZvXSwgW291dHB1dF0pO1xuICB9XG5cbiAgY29uc3Qgb3V0VGV4ID0gb3V0cHV0LnRleERhdGEudGV4dHVyZTtcbiAgY29uc3Qgb3V0VGV4U2hhcGUgPSBvdXRwdXQudGV4RGF0YS50ZXhTaGFwZTtcbiAgaWYgKG91dHB1dC50ZXhEYXRhLmlzUGFja2VkKSB7XG4gICAgZ3BncHUuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gIH0gZWxzZSB7XG4gICAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gIH1cbiAgZ3BncHUuc2V0UHJvZ3JhbShiaW5hcnkud2ViR0xQcm9ncmFtKTtcblxuICAvLyBTZXQgc3BlY2lhbCB1bmlmb3JtcyAoTkFOLCBJTkZJTklUWSlcbiAgaWYgKGVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpID09PSAxKSB7XG4gICAgaWYgKGJpbmFyeS5pbmZMb2MgIT09IG51bGwpIHtcbiAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihiaW5hcnkuaW5mTG9jLCBJbmZpbml0eSk7XG4gICAgfVxuICB9XG4gIGlmIChiaW5hcnkubmFuTG9jICE9PSBudWxsKSB7XG4gICAgZ3BncHUuZ2wudW5pZm9ybTFmKGJpbmFyeS5uYW5Mb2MsIE5hTik7XG4gIH1cblxuICAvLyBTZXQgdXNlci1kZWZpbmVkIGlucHV0c1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICBjb25zdCB2YXJOYW1lID0gYmluYXJ5LnByb2dyYW0udmFyaWFibGVOYW1lc1tpXTtcbiAgICBjb25zdCB2YXJMb2MgPSBiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1t2YXJOYW1lXTtcbiAgICBjb25zdCB2YXJPZmZzZXRMb2MgPSBiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1tgb2Zmc2V0JHt2YXJOYW1lfWBdO1xuICAgIGNvbnN0IHZhclNoYXBlTG9jID0gYmluYXJ5LmluU2hhcGVzTG9jYXRpb25zW2Ake3Zhck5hbWV9U2hhcGVgXTtcbiAgICBjb25zdCB2YXJUZXhTaGFwZUxvYyA9IGJpbmFyeS5pblRleFNoYXBlc0xvY2F0aW9uc1tgJHt2YXJOYW1lfVRleFNoYXBlYF07XG5cbiAgICBpZiAodmFyU2hhcGVMb2MpIHtcbiAgICAgIGNvbnN0IHt1bmlmb3JtU2hhcGV9ID0gc2hhZGVyX2NvbXBpbGVyLmdldFVuaWZvcm1JbmZvRnJvbVNoYXBlKFxuICAgICAgICAgIGJpbmFyeS5wcm9ncmFtLnBhY2tlZElucHV0cywgaW5wdXQuc2hhcGUsIGlucHV0LnRleERhdGEudGV4U2hhcGUpO1xuICAgICAgc3dpdGNoICh1bmlmb3JtU2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWl2KHZhclNoYXBlTG9jLCBuZXcgSW50MzJBcnJheSh1bmlmb3JtU2hhcGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaXYodmFyU2hhcGVMb2MsIG5ldyBJbnQzMkFycmF5KHVuaWZvcm1TaGFwZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTNpdih2YXJTaGFwZUxvYywgbmV3IEludDMyQXJyYXkodW5pZm9ybVNoYXBlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBncGdwdS5nbC51bmlmb3JtNGl2KHZhclNoYXBlTG9jLCBuZXcgSW50MzJBcnJheSh1bmlmb3JtU2hhcGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhclRleFNoYXBlTG9jKSB7XG4gICAgICBncGdwdS5nbC51bmlmb3JtMmkoXG4gICAgICAgICAgdmFyVGV4U2hhcGVMb2MsIGlucHV0LnRleERhdGEudGV4U2hhcGVbMF0sIGlucHV0LnRleERhdGEudGV4U2hhcGVbMV0pO1xuICAgIH1cblxuICAgIGlmICh2YXJMb2MgPT0gbnVsbCkge1xuICAgICAgLy8gVGhlIGNvbXBpbGVyIGluZmVycmVkIHRoYXQgdGhpcyB2YXJpYWJsZSBpcyBub3QgdXNlZCBpbiB0aGlzIHNoYWRlci5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuaXNVbmlmb3JtKSB7XG4gICAgICAvLyBVcGxvYWQgdGhlIHZhbHVlcyBvZiB0aGUgdGVuc29yIGFzIHVuaWZvcm0uXG4gICAgICBpZiAodXRpbC5zaXplRnJvbVNoYXBlKGlucHV0LnNoYXBlKSA8IDIpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKHZhckxvYywgaW5wdXQudW5pZm9ybVZhbHVlc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmFscyA9IGlucHV0LnVuaWZvcm1WYWx1ZXM7XG4gICAgICAgIGlmICghKHZhbHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgdmFscyA9IG5ldyBGbG9hdDMyQXJyYXkodmFscyk7XG4gICAgICAgIH1cbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmdih2YXJMb2MsIHZhbHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBpbnB1dCB3YXMgc2xpY2VkLCB1cGxvYWQgdGhlIGZsYXQgb2Zmc2V0IGluZGV4LlxuICAgIGlmIChpbnB1dC50ZXhEYXRhLnNsaWNlICE9IG51bGwgJiYgdmFyT2Zmc2V0TG9jICE9IG51bGwpIHtcbiAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xaSh2YXJPZmZzZXRMb2MsIGlucHV0LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCk7XG4gICAgfVxuXG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGlucHV0LnRleERhdGEudGV4dHVyZSwgdmFyTG9jLCBpKTtcbiAgfSk7XG5cbiAgY29uc3Qgb3V0U2hhcGVMb2MgPSBiaW5hcnkub3V0U2hhcGVMb2NhdGlvbjtcbiAgaWYgKG91dFNoYXBlTG9jKSB7XG4gICAgc3dpdGNoIChvdXRwdXQuc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xaXYob3V0U2hhcGVMb2MsIG5ldyBJbnQzMkFycmF5KG91dHB1dC5zaGFwZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpdihvdXRTaGFwZUxvYywgbmV3IEludDMyQXJyYXkob3V0cHV0LnNoYXBlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBncGdwdS5nbC51bmlmb3JtM2l2KG91dFNoYXBlTG9jLCBuZXcgSW50MzJBcnJheShvdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm00aXYob3V0U2hhcGVMb2MsIG5ldyBJbnQzMkFycmF5KG91dHB1dC5zaGFwZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoYmluYXJ5Lm91dFNoYXBlU3RyaWRlc0xvY2F0aW9uKSB7XG4gICAgY29uc3Qgc3RyaWRlcyA9IHV0aWwuY29tcHV0ZVN0cmlkZXMob3V0cHV0LnNoYXBlKTtcbiAgICBzd2l0Y2ggKG91dHB1dC5zaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFpdihcbiAgICAgICAgICAgIGJpbmFyeS5vdXRTaGFwZVN0cmlkZXNMb2NhdGlvbiwgbmV3IEludDMyQXJyYXkoc3RyaWRlcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpdihcbiAgICAgICAgICAgIGJpbmFyeS5vdXRTaGFwZVN0cmlkZXNMb2NhdGlvbiwgbmV3IEludDMyQXJyYXkoc3RyaWRlcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTNpdihcbiAgICAgICAgICAgIGJpbmFyeS5vdXRTaGFwZVN0cmlkZXNMb2NhdGlvbiwgbmV3IEludDMyQXJyYXkoc3RyaWRlcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoYmluYXJ5Lm91dFRleFNoYXBlTG9jYXRpb24pIHtcbiAgICBncGdwdS5nbC51bmlmb3JtMmkoXG4gICAgICAgIGJpbmFyeS5vdXRUZXhTaGFwZUxvY2F0aW9uLCBvdXRwdXQudGV4RGF0YS50ZXhTaGFwZVswXSxcbiAgICAgICAgb3V0cHV0LnRleERhdGEudGV4U2hhcGVbMV0pO1xuICB9XG5cbiAgaWYgKGJpbmFyeS5wcm9ncmFtLmN1c3RvbVVuaWZvcm1zICYmIGN1c3RvbVVuaWZvcm1WYWx1ZXMpIHtcbiAgICBiaW5hcnkucHJvZ3JhbS5jdXN0b21Vbmlmb3Jtcy5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21Mb2MgPSBiaW5hcnkuY3VzdG9tVW5pZm9ybUxvY2F0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGN1c3RvbVZhbHVlID0gY3VzdG9tVW5pZm9ybVZhbHVlc1tpXTtcbiAgICAgIGlmIChkLnR5cGUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmdihjdXN0b21Mb2MsIGN1c3RvbVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZC50eXBlID09PSAndmVjMicpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJmdihjdXN0b21Mb2MsIGN1c3RvbVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZC50eXBlID09PSAndmVjMycpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTNmdihjdXN0b21Mb2MsIGN1c3RvbVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZC50eXBlID09PSAndmVjNCcpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTRmdihjdXN0b21Mb2MsIGN1c3RvbVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZC50eXBlID09PSAnaW50Jykge1xuICAgICAgICBncGdwdS5nbC51bmlmb3JtMWl2KGN1c3RvbUxvYywgY3VzdG9tVmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChkLnR5cGUgPT09ICdpdmVjMicpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpdihjdXN0b21Mb2MsIGN1c3RvbVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZC50eXBlID09PSAnaXZlYzMnKSB7XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0zaXYoY3VzdG9tTG9jLCBjdXN0b21WYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGQudHlwZSA9PT0gJ2l2ZWM0Jykge1xuICAgICAgICBncGdwdS5nbC51bmlmb3JtNGl2KGN1c3RvbUxvYywgY3VzdG9tVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHVuaWZvcm0gdHlwZSAke2QudHlwZX0gaXMgbm90IHN1cHBvcnRlZCB5ZXQuYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTaGFkZXJLZXkoXG4gICAgcHJvZ3JhbTogR1BHUFVQcm9ncmFtLCBpbnB1dHM6IFRlbnNvckRhdGFbXSwgb3V0cHV0OiBUZW5zb3JEYXRhKTogc3RyaW5nIHtcbiAgbGV0IGtleUlucHV0cyA9ICcnO1xuICBpbnB1dHMuY29uY2F0KG91dHB1dCkuZm9yRWFjaCh4ID0+IHtcbiAgICBjb25zdCBoYXNPZmZzZXQgPSB4LnRleERhdGEgIT0gbnVsbCAmJiB4LnRleERhdGEuc2xpY2UgIT0gbnVsbCAmJlxuICAgICAgICB4LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCA+IDA7XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoZSBjb25kaXRpb24gb2YgIXguaXNVbmlmb3JtLlxuICAgIGlmIChwcm9ncmFtLmVuYWJsZVNoYXBlVW5pZm9ybXMgJiYgIXguaXNVbmlmb3JtKSB7XG4gICAgICBjb25zdCB4VGV4U2hhcGUgPSB4LnRleERhdGEudGV4U2hhcGU7XG4gICAgICBjb25zdCB7dXNlU3F1ZWV6ZVNoYXBlLCB1bmlmb3JtU2hhcGUsIGtlcHREaW1zfSA9XG4gICAgICAgICAgc2hhZGVyX2NvbXBpbGVyLmdldFVuaWZvcm1JbmZvRnJvbVNoYXBlKFxuICAgICAgICAgICAgICBwcm9ncmFtLnBhY2tlZElucHV0cywgeC5zaGFwZSwgeFRleFNoYXBlKTtcbiAgICAgIGxldCByYW5rMSA9ICcnLCByYW5rMiA9ICcnLCByYW5rMzQgPSAnJztcbiAgICAgIGlmICh1bmlmb3JtU2hhcGUubGVuZ3RoID09PSAxICYmIHByb2dyYW0ucGFja2VkSW5wdXRzKSB7XG4gICAgICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID1cbiAgICAgICAgICAgIFtNYXRoLmNlaWwoeFRleFNoYXBlWzBdIC8gMiksIE1hdGguY2VpbCh4VGV4U2hhcGVbMV0gLyAyKV07XG4gICAgICAgIHJhbmsxID0gYCR7cGFja2VkVGV4U2hhcGVbMF0gPiAxfV8ke3BhY2tlZFRleFNoYXBlWzFdID4gMX1gO1xuICAgICAgfSBlbHNlIGlmICh1bmlmb3JtU2hhcGUubGVuZ3RoID09PSAyICYmICFwcm9ncmFtLnBhY2tlZElucHV0cykge1xuICAgICAgICByYW5rMiA9IGAke3VuaWZvcm1TaGFwZVswXSA+IDF9XyR7dW5pZm9ybVNoYXBlWzFdID4gMX1gO1xuICAgICAgfSBlbHNlIGlmICh1bmlmb3JtU2hhcGUubGVuZ3RoID4gMiAmJiAhcHJvZ3JhbS5wYWNrZWRJbnB1dHMpIHtcbiAgICAgICAgY29uc3Qgc3RyaWRlcyA9IHV0aWwuY29tcHV0ZVN0cmlkZXModW5pZm9ybVNoYXBlKTtcbiAgICAgICAgcmFuazM0ID0gYCR7c3RyaWRlc1swXSA9PT0geFRleFNoYXBlWzFdfV8ke1xuICAgICAgICAgICAgc3RyaWRlc1tzdHJpZGVzLmxlbmd0aCAtIDFdID09PSB4VGV4U2hhcGVbMV19YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBpc0xvZ2ljYWxTaGFwVGV4U2hhcGVFcXVhbCA9XG4gICAgICAgICAgdW5pZm9ybVNoYXBlLmxlbmd0aCA9PT0gMiAmJiB1dGlsLmFycmF5c0VxdWFsKHguc2hhcGUsIHhUZXhTaGFwZSk7XG4gICAgICBjb25zdCBpc1NjYWxhciA9IHV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlKSA9PT0gMTtcbiAgICAgIGNvbnN0IGJyb2FkY2FzdERpbXMgPVxuICAgICAgICAgIGJhY2tlbmRfdXRpbC5nZXRCcm9hZGNhc3REaW1zKHguc2hhcGUsIG91dHB1dC5zaGFwZSk7XG4gICAgICBjb25zdCBpc0luT3V0VGV4U2hhcGVFcXVhbCA9ICFwcm9ncmFtLnBhY2tlZElucHV0cyAmJlxuICAgICAgICAgIHhSYW5rID09PSBvdXRwdXQuc2hhcGUubGVuZ3RoICYmXG4gICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4VGV4U2hhcGUsIG91dHB1dC50ZXhEYXRhLnRleFNoYXBlKTtcbiAgICAgIGNvbnN0IGlzVGV4U2hhcGVHcmVhdGVyVGhhbk9uZSA9XG4gICAgICAgICAgcHJvZ3JhbS5wYWNrZWRJbnB1dHMgfHwgdW5pZm9ybVNoYXBlLmxlbmd0aCA+IDIgP1xuICAgICAgICAgICcnIDpcbiAgICAgICAgICBgJHt4VGV4U2hhcGVbMF0gPiAxfV8ke3hUZXhTaGFwZVsxXSA+IDF9YDtcbiAgICAgIC8vIFRoZXNlIGtleSBjb21wb25lbnRzIGFyZSBuZWVkZWQgZHVlIHRvIHNoYWRlcl9jb21waWxlciBpcyBlbWJlZGRpbmdcbiAgICAgIC8vIHRoZW0gaW4gdGhlIHNoYWRlci5cbiAgICAgIC8vIHx4UmFua3wgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNvb3JkcyBsZW5ndGguIFNlZVxuICAgICAgLy8gZ2V0W1BhY2tlZF1TYW1wbGVyQXRPdXRwdXRDb29yZHMuXG4gICAgICAvLyB8aXNJbk91dFRleFNoYXBlRXF1YWx8IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgZ29pbmcgdG8gYW5cbiAgICAgIC8vIG9wdGltaXphdGlvbiBwYXRoIGluIGdldFNhbXBsZXJBdE91dHB1dENvb3Jkcy5cbiAgICAgIC8vIHx1c2VTcXVlZXplU2hhcGV8IGlzIGV4dHJhY3RlZCBmcm9tIHNxdWVlemVJbnB1dEluZm8gb2ZcbiAgICAgIC8vIGdldFNhbXBsZXJbMnwzfDRdRC9nZXRQYWNrZWRTYW1wbGVyM0QuXG4gICAgICAvLyB8aXNTY2FsYXJ8IGlzIGV4dHJhY3RlZCBmcm9tIGlzSW5wdXRTY2FsYXIvaXNPdXRwdXRTY2FsYXIgaW5cbiAgICAgIC8vIGdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3Jkcy5cbiAgICAgIC8vIHxicm9hZGNhc3REaW1zfCBpcyBleHRyYWN0ZWQgZnJvbSBnZXRbUGFja2VkXVNhbXBsZXJBdE91dHB1dENvb3Jkcy5cbiAgICAgIC8vIHxpc0xvZ2ljYWxTaGFwVGV4U2hhcGVFcXVhbHwgaXMgdXNlZCBpblxuICAgICAgLy8gZ2V0T3V0cHV0W1BhY2tlZF0yRENvb3Jkcy9nZXRbUGFja2VkXVNhbXBsZXIyRC5cbiAgICAgIC8vIHxyYW5rMXwgaXMgdXNlZCBpbiBnZXRPdXRwdXRQYWNrZWQxRENvb3Jkcy5cbiAgICAgIC8vIHxyYW5rMnwgaXMgdXNlZCBpbiBnZXRPdXRwdXQyRENvb3Jkcy5cbiAgICAgIC8vIHxyYW5rMzR8IGlzIHVzZWQgaW4gZ2V0U2FtcGxlcjNEL2dldFNhbXBsZXI0RC5cbiAgICAgIC8vIHxpc1RleFNoYXBlR3JlYXRlclRoYW5PbmV8IGFyZSB1c2VkIGluXG4gICAgICAvLyBnZXRTYW1wbGVyW1NjYWxhcnwxRHwyRF0vZ2V0T3V0cHV0MURDb29yZHMuXG4gICAgICBrZXlJbnB1dHMgKz0gYCR7eFJhbmt9XyR7aXNJbk91dFRleFNoYXBlRXF1YWx9XyR7XG4gICAgICAgICAgdXNlU3F1ZWV6ZVNoYXBlID8ga2VwdERpbXMgOiAnJ31fJHt1bmlmb3JtU2hhcGUubGVuZ3RofV8ke2lzU2NhbGFyfV8ke1xuICAgICAgICAgIGJyb2FkY2FzdERpbXN9XyR7aXNMb2dpY2FsU2hhcFRleFNoYXBlRXF1YWx9XyR7cmFuazF9XyR7cmFuazJ9XyR7XG4gICAgICAgICAgcmFuazM0fV8ke2lzVGV4U2hhcGVHcmVhdGVyVGhhbk9uZX1fJHtoYXNPZmZzZXR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGV4U2hhcGUgPSB4LmlzVW5pZm9ybSA/ICd1bmlmb3JtJyA6IHgudGV4RGF0YS50ZXhTaGFwZTtcbiAgICAgIGtleUlucHV0cyArPSBgJHt4LnNoYXBlfV8ke3RleFNoYXBlfV8ke2hhc09mZnNldH1gO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGtleVVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgbGV0IGtleSA9IHByb2dyYW0uY29uc3RydWN0b3IubmFtZTtcbiAgLy8gRmFzdCBzdHJpbmcgY29uY2F0LiBTZWUgaHR0cHM6Ly9qc3BlcmYuY29tL3N0cmluZy1jb25jYXRlbmF0aW9uLzE0LlxuICBrZXkgKz0gJ18nICsga2V5SW5wdXRzICsgJ18nICsga2V5VXNlckNvZGUgK1xuICAgICAgYCR7ZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9WRVJTSU9OJyl9YDtcbiAgcmV0dXJuIGtleTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNoYXBlVW5pZm9ybXMocmFuazogbnVtYmVyKSB7XG4gIC8vIFRPRE86IFJlbW92ZSB0aGUgbGltaXRhaW9uIG9mIHJhbmsgPD0gNC5cbiAgcmV0dXJuIGVudigpLmdldEJvb2woJ1dFQkdMX1VTRV9TSEFQRVNfVU5JRk9STVMnKSAmJiByYW5rIDw9IDQ7XG59XG4iXX0=