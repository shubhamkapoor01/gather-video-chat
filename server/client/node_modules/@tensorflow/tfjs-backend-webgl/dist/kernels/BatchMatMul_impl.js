/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { upcastType, util } from '@tensorflow/tfjs-core';
import { mapActivationToShaderProgram } from '../kernel_utils/kernel_funcs_utils';
import { MatMulPackedProgram } from '../mulmat_packed_gpu';
import { multiply } from './Multiply';
import { reshape } from './Reshape';
import { sum } from './Sum';
import { transpose } from './Transpose';
// Empirically determined minimal shared dimension in matmul before we forward
// to a.mul(b).sum() in order to take advantage of GPU parallelism. See
// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.
export const MATMUL_SHARED_DIM_THRESHOLD = 1000;
export function batchMatMulImpl({ a, b, transposeA, transposeB, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = util.sizeFromShape(outerDimsA);
    const batchDimB = util.sizeFromShape(outerDimsB);
    const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
    util.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the ` +
        `same or at least one input batch dimension must be 1. Got input ` +
        `batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
    const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` +
        `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +
        `${b.shape} and transposeA=${transposeA}` +
        ` and transposeB=${transposeB} must match.`);
    const a3dShape = transposeA ?
        [batchDimA, innerShapeA, outerShapeA] :
        [batchDimA, outerShapeA, innerShapeA];
    const b3dShape = transposeB ?
        [batchDimB, outerShapeB, innerShapeB] :
        [batchDimB, innerShapeB, outerShapeB];
    // The rest of the implementation is designed to operate on rank-3 tensors
    const a3d = reshape({ inputs: { x: a }, backend, attrs: { shape: a3dShape } });
    const b3d = reshape({ inputs: { x: b }, backend, attrs: { shape: b3dShape } });
    const intermediates = [a3d, b3d];
    const batchDim = Math.max(batchDimA, batchDimB);
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    const fusedActivation = activation != null ?
        mapActivationToShaderProgram(activation, true) :
        null;
    const containsFusedOps = hasBias || hasPreluActivationWeights ||
        hasLeakyreluAlpha || fusedActivation != null;
    let out;
    // Since the matrices are vectors, it is faster to call mul().sum()
    // because sum() is O(sqrt(N)) due to divide-and-conquer.
    if ((outerShapeA === 1 || outerShapeB === 1) &&
        sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
        let aVec = a3d;
        let bVec = b3d;
        if (transposeA) {
            aVec = transpose({ inputs: { x: a3d }, backend, attrs: { perm: [0, 2, 1] } });
            intermediates.push(aVec);
        }
        if (transposeB) {
            bVec = transpose({ inputs: { x: b3d }, backend, attrs: { perm: [0, 2, 1] } });
            intermediates.push(bVec);
        }
        const shouldReshapeA = outerShapeB !== 1;
        const shouldReshapeB = outerShapeB === 1;
        let aVec3d = aVec;
        if (shouldReshapeA) {
            aVec3d = reshape({
                inputs: { x: aVec },
                backend,
                attrs: { shape: [batchDim, sharedDim, 1] }
            });
            intermediates.push(aVec3d);
        }
        const axis = outerShapeB === 1 ? 2 : 1;
        let bVec3d = bVec;
        if (shouldReshapeB) {
            bVec3d = reshape({
                inputs: { x: bVec },
                backend,
                attrs: { shape: [batchDim, 1, sharedDim] }
            });
            intermediates.push(bVec3d);
        }
        const product = multiply({ inputs: { a: aVec3d, b: bVec3d }, backend });
        out = sum({ inputs: { x: product }, backend, attrs: { axis, keepDims: true } });
        intermediates.push(product);
    }
    else {
        const dtype = upcastType(a.dtype, b.dtype);
        const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
        const inputs = [a3d, b3d];
        if (bias != null) {
            inputs.push(bias);
        }
        if (hasPreluActivationWeights) {
            inputs.push(preluActivationWeights);
        }
        if (hasLeakyreluAlpha) {
            const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(leakyreluAlpha, 'float32'));
            inputs.push($leakyreluAlpha);
            intermediates.push($leakyreluAlpha);
        }
        out = backend.runWebGLProgram(program, inputs, dtype);
    }
    const outReshaped = reshape({ inputs: { x: out }, backend, attrs: { shape: outShape } });
    intermediates.push(out);
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return outReshaped;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmF0Y2hNYXRNdWxfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMva2VybmVscy9CYXRjaE1hdE11bF9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBMkIsVUFBVSxFQUFFLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBR2pGLE9BQU8sRUFBQyw0QkFBNEIsRUFBQyxNQUFNLG9DQUFvQyxDQUFDO0FBQ2hGLE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRXpELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDcEMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNsQyxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBQzFCLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFdEMsOEVBQThFO0FBQzlFLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFDcEUsTUFBTSxDQUFDLE1BQU0sMkJBQTJCLEdBQUcsSUFBSSxDQUFDO0FBY2hELE1BQU0sVUFBVSxlQUFlLENBQUMsRUFDOUIsQ0FBQyxFQUNELENBQUMsRUFDRCxVQUFVLEVBQ1YsVUFBVSxFQUNWLE9BQU8sRUFDUCxJQUFJLEdBQUcsSUFBSSxFQUNYLHNCQUFzQixHQUFHLElBQUksRUFDN0IsY0FBYyxHQUFHLENBQUMsRUFDbEIsVUFBVSxHQUFHLElBQUksRUFDQztJQUNsQixNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUM3QixNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUU3QixNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN6RSxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztJQUV6RSxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN6RSxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztJQUV6RSxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4QyxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV4QyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2pELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFakQsTUFBTSxtQkFBbUIsR0FDckIsU0FBUyxLQUFLLFNBQVMsSUFBSSxTQUFTLEtBQUssQ0FBQyxJQUFJLFNBQVMsS0FBSyxDQUFDLENBQUM7SUFFbEUsSUFBSSxDQUFDLE1BQU0sQ0FDUCxLQUFLLElB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QztRQUV2QixNQUFNLE1BQU0sR0FBaUIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEMsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO1lBQ2hCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbkI7UUFDRCxJQUFJLHlCQUF5QixFQUFFO1lBQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztTQUNyQztRQUNELElBQUksaUJBQWlCLEVBQUU7WUFDckIsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FDMUMsRUFBRSxFQUFFLFNBQVMsRUFDYixJQUFJLENBQUMsaUJBQWlCLENBQUMsY0FBaUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQzFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDN0IsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztTQUNyQztRQUVELEdBQUcsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDdkQ7SUFFRCxNQUFNLFdBQVcsR0FDYixPQUFPLENBQUMsRUFBQyxNQUFNLEVBQUUsRUFBQyxDQUFDLEVBQUUsR0FBRyxFQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFDLEtBQUssRUFBRSxRQUFRLEVBQUMsRUFBQyxDQUFDLENBQUM7SUFDbkUsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QixLQUFLLE1BQU0sQ0FBQyxJQUFJLGFBQWEsRUFBRTtRQUM3QixPQUFPLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDMUM7SUFDRCxPQUFPLFdBQVcsQ0FBQztBQUNyQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgVGVuc29ySW5mbywgdXBjYXN0VHlwZSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtNYXRoQmFja2VuZFdlYkdMfSBmcm9tICcuLi9iYWNrZW5kX3dlYmdsJztcbmltcG9ydCB7bWFwQWN0aXZhdGlvblRvU2hhZGVyUHJvZ3JhbX0gZnJvbSAnLi4va2VybmVsX3V0aWxzL2tlcm5lbF9mdW5jc191dGlscyc7XG5pbXBvcnQge01hdE11bFBhY2tlZFByb2dyYW19IGZyb20gJy4uL211bG1hdF9wYWNrZWRfZ3B1JztcblxuaW1wb3J0IHttdWx0aXBseX0gZnJvbSAnLi9NdWx0aXBseSc7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vUmVzaGFwZSc7XG5pbXBvcnQge3N1bX0gZnJvbSAnLi9TdW0nO1xuaW1wb3J0IHt0cmFuc3Bvc2V9IGZyb20gJy4vVHJhbnNwb3NlJztcblxuLy8gRW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBtaW5pbWFsIHNoYXJlZCBkaW1lbnNpb24gaW4gbWF0bXVsIGJlZm9yZSB3ZSBmb3J3YXJkXG4vLyB0byBhLm11bChiKS5zdW0oKSBpbiBvcmRlciB0byB0YWtlIGFkdmFudGFnZSBvZiBHUFUgcGFyYWxsZWxpc20uIFNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy1jb3JlL3B1bGwvMTM3OSBmb3IgYmVuY2htYXJrcy5cbmV4cG9ydCBjb25zdCBNQVRNVUxfU0hBUkVEX0RJTV9USFJFU0hPTEQgPSAxMDAwO1xuXG50eXBlIEJhdGNoTWF0TXVsQ29uZmlnID0ge1xuICBhOiBUZW5zb3JJbmZvLFxuICBiOiBUZW5zb3JJbmZvLFxuICB0cmFuc3Bvc2VBOiBib29sZWFuLFxuICB0cmFuc3Bvc2VCOiBib29sZWFuLFxuICBiYWNrZW5kOiBNYXRoQmFja2VuZFdlYkdMLFxuICBiaWFzPzogVGVuc29ySW5mbyxcbiAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz86IFRlbnNvckluZm8sXG4gIGxlYWt5cmVsdUFscGhhPzogbnVtYmVyLFxuICBhY3RpdmF0aW9uPzogYmFja2VuZF91dGlsLkFjdGl2YXRpb25cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXRjaE1hdE11bEltcGwoe1xuICBhLFxuICBiLFxuICB0cmFuc3Bvc2VBLFxuICB0cmFuc3Bvc2VCLFxuICBiYWNrZW5kLFxuICBiaWFzID0gbnVsbCxcbiAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IG51bGwsXG4gIGxlYWt5cmVsdUFscGhhID0gMCxcbiAgYWN0aXZhdGlvbiA9IG51bGxcbn06IEJhdGNoTWF0TXVsQ29uZmlnKTogVGVuc29ySW5mbyB7XG4gIGNvbnN0IGFSYW5rID0gYS5zaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGJSYW5rID0gYi5zaGFwZS5sZW5ndGg7XG5cbiAgY29uc3QgaW5uZXJTaGFwZUEgPSB0cmFuc3Bvc2VBID8gYS5zaGFwZVthUmFuayAtIDJdIDogYS5zaGFwZVthUmFuayAtIDFdO1xuICBjb25zdCBpbm5lclNoYXBlQiA9IHRyYW5zcG9zZUIgPyBiLnNoYXBlW2JSYW5rIC0gMV0gOiBiLnNoYXBlW2JSYW5rIC0gMl07XG5cbiAgY29uc3Qgb3V0ZXJTaGFwZUEgPSB0cmFuc3Bvc2VBID8gYS5zaGFwZVthUmFuayAtIDFdIDogYS5zaGFwZVthUmFuayAtIDJdO1xuICBjb25zdCBvdXRlclNoYXBlQiA9IHRyYW5zcG9zZUIgPyBiLnNoYXBlW2JSYW5rIC0gMl0gOiBiLnNoYXBlW2JSYW5rIC0gMV07XG5cbiAgY29uc3Qgb3V0ZXJEaW1zQSA9IGEuc2hhcGUuc2xpY2UoMCwgLTIpO1xuICBjb25zdCBvdXRlckRpbXNCID0gYi5zaGFwZS5zbGljZSgwLCAtMik7XG5cbiAgY29uc3QgYmF0Y2hEaW1BID0gdXRpbC5zaXplRnJvbVNoYXBlKG91dGVyRGltc0EpO1xuICBjb25zdCBiYXRjaERpbUIgPSB1dGlsLnNpemVGcm9tU2hhcGUob3V0ZXJEaW1zQik7XG5cbiAgY29uc3QgYmF0Y2hEaW1zQ29tcGF0aWJsZSA9XG4gICAgICBiYXRjaERpbUEgPT09IGJhdGNoRGltQiB8fCBiYXRjaERpbUEgPT09IDEgfHwgYmF0Y2hEaW1CID09PSAxO1xuXG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgYVJhbmsgPj0gMiAmJiBiUmFuayA+PSAyICYmIGJhdGNoRGltc0NvbXBhdGlibGUsXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gbWF0TXVsOiB0aGUgaW5wdXQgYmF0Y2ggZGltZW5zaW9ucyBtdXN0IGVpdGhlciBiZSB0aGUgYCArXG4gICAgICAgICAgYHNhbWUgb3IgYXQgbGVhc3Qgb25lIGlucHV0IGJhdGNoIGRpbWVuc2lvbiBtdXN0IGJlIDEuIEdvdCBpbnB1dCBgICtcbiAgICAgICAgICBgYmF0Y2ggZGltZW5zaW9ucyBvZiAoJHtvdXRlckRpbXNBfSkgYW5kICgke291dGVyRGltc0J9KS5gKTtcblxuICBjb25zdCBvdXRTaGFwZU91dGVyRGltcyA9XG4gICAgICBiYXRjaERpbUEgPiBiYXRjaERpbUIgPyBhLnNoYXBlLnNsaWNlKDAsIC0yKSA6IGIuc2hhcGUuc2xpY2UoMCwgLTIpO1xuICBjb25zdCBvdXRTaGFwZSA9IG91dFNoYXBlT3V0ZXJEaW1zLmNvbmNhdChbb3V0ZXJTaGFwZUEsIG91dGVyU2hhcGVCXSk7XG5cbiAgdXRpbC5hc3NlcnQoXG4gICAgICBpbm5lclNoYXBlQSA9PT0gaW5uZXJTaGFwZUIsXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKCR7aW5uZXJTaGFwZUF9KSBhbmQgKGAgK1xuICAgICAgICAgIGAke2lubmVyU2hhcGVCfSkgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyAke2Euc2hhcGV9IGFuZCBgICtcbiAgICAgICAgICBgJHtiLnNoYXBlfSBhbmQgdHJhbnNwb3NlQT0ke3RyYW5zcG9zZUF9YCArXG4gICAgICAgICAgYCBhbmQgdHJhbnNwb3NlQj0ke3RyYW5zcG9zZUJ9IG11c3QgbWF0Y2guYCk7XG5cbiAgY29uc3QgYTNkU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IHRyYW5zcG9zZUEgP1xuICAgICAgW2JhdGNoRGltQSwgaW5uZXJTaGFwZUEsIG91dGVyU2hhcGVBXSA6XG4gICAgICBbYmF0Y2hEaW1BLCBvdXRlclNoYXBlQSwgaW5uZXJTaGFwZUFdO1xuICBjb25zdCBiM2RTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gdHJhbnNwb3NlQiA/XG4gICAgICBbYmF0Y2hEaW1CLCBvdXRlclNoYXBlQiwgaW5uZXJTaGFwZUJdIDpcbiAgICAgIFtiYXRjaERpbUIsIGlubmVyU2hhcGVCLCBvdXRlclNoYXBlQl07XG5cbiAgLy8gVGhlIHJlc3Qgb2YgdGhlIGltcGxlbWVudGF0aW9uIGlzIGRlc2lnbmVkIHRvIG9wZXJhdGUgb24gcmFuay0zIHRlbnNvcnNcbiAgY29uc3QgYTNkID0gcmVzaGFwZSh7aW5wdXRzOiB7eDogYX0sIGJhY2tlbmQsIGF0dHJzOiB7c2hhcGU6IGEzZFNoYXBlfX0pO1xuICBjb25zdCBiM2QgPSByZXNoYXBlKHtpbnB1dHM6IHt4OiBifSwgYmFja2VuZCwgYXR0cnM6IHtzaGFwZTogYjNkU2hhcGV9fSk7XG5cbiAgY29uc3QgaW50ZXJtZWRpYXRlczogVGVuc29ySW5mb1tdID0gW2EzZCwgYjNkXTtcblxuICBjb25zdCBiYXRjaERpbSA9IE1hdGgubWF4KGJhdGNoRGltQSwgYmF0Y2hEaW1CKTtcbiAgY29uc3Qgc2hhcmVkRGltID0gdHJhbnNwb3NlQSA/IGEzZC5zaGFwZVsxXSA6IGEzZC5zaGFwZVsyXTtcblxuICBjb25zdCBoYXNCaWFzID0gYmlhcyAhPSBudWxsO1xuICBjb25zdCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsO1xuICBjb25zdCBoYXNMZWFreXJlbHVBbHBoYSA9IGFjdGl2YXRpb24gPT09ICdsZWFreXJlbHUnO1xuICBjb25zdCBmdXNlZEFjdGl2YXRpb24gPSBhY3RpdmF0aW9uICE9IG51bGwgP1xuICAgICAgbWFwQWN0aXZhdGlvblRvU2hhZGVyUHJvZ3JhbShhY3RpdmF0aW9uLCB0cnVlKSA6XG4gICAgICBudWxsO1xuICBjb25zdCBjb250YWluc0Z1c2VkT3BzID0gaGFzQmlhcyB8fCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzIHx8XG4gICAgICBoYXNMZWFreXJlbHVBbHBoYSB8fCBmdXNlZEFjdGl2YXRpb24gIT0gbnVsbDtcbiAgbGV0IG91dDogVGVuc29ySW5mbztcblxuICAvLyBTaW5jZSB0aGUgbWF0cmljZXMgYXJlIHZlY3RvcnMsIGl0IGlzIGZhc3RlciB0byBjYWxsIG11bCgpLnN1bSgpXG4gIC8vIGJlY2F1c2Ugc3VtKCkgaXMgTyhzcXJ0KE4pKSBkdWUgdG8gZGl2aWRlLWFuZC1jb25xdWVyLlxuICBpZiAoKG91dGVyU2hhcGVBID09PSAxIHx8IG91dGVyU2hhcGVCID09PSAxKSAmJlxuICAgICAgc2hhcmVkRGltID4gTUFUTVVMX1NIQVJFRF9ESU1fVEhSRVNIT0xEICYmIGNvbnRhaW5zRnVzZWRPcHMgPT09IGZhbHNlKSB7XG4gICAgbGV0IGFWZWMgPSBhM2Q7XG4gICAgbGV0IGJWZWMgPSBiM2Q7XG4gICAgaWYgKHRyYW5zcG9zZUEpIHtcbiAgICAgIGFWZWMgPSB0cmFuc3Bvc2Uoe2lucHV0czoge3g6IGEzZH0sIGJhY2tlbmQsIGF0dHJzOiB7cGVybTogWzAsIDIsIDFdfX0pO1xuICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKGFWZWMpO1xuICAgIH1cbiAgICBpZiAodHJhbnNwb3NlQikge1xuICAgICAgYlZlYyA9IHRyYW5zcG9zZSh7aW5wdXRzOiB7eDogYjNkfSwgYmFja2VuZCwgYXR0cnM6IHtwZXJtOiBbMCwgMiwgMV19fSk7XG4gICAgICBpbnRlcm1lZGlhdGVzLnB1c2goYlZlYyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvdWxkUmVzaGFwZUEgPSBvdXRlclNoYXBlQiAhPT0gMTtcbiAgICBjb25zdCBzaG91bGRSZXNoYXBlQiA9IG91dGVyU2hhcGVCID09PSAxO1xuXG4gICAgbGV0IGFWZWMzZCA9IGFWZWM7XG4gICAgaWYgKHNob3VsZFJlc2hhcGVBKSB7XG4gICAgICBhVmVjM2QgPSByZXNoYXBlKHtcbiAgICAgICAgaW5wdXRzOiB7eDogYVZlY30sXG4gICAgICAgIGJhY2tlbmQsXG4gICAgICAgIGF0dHJzOiB7c2hhcGU6IFtiYXRjaERpbSwgc2hhcmVkRGltLCAxXX1cbiAgICAgIH0pO1xuXG4gICAgICBpbnRlcm1lZGlhdGVzLnB1c2goYVZlYzNkKTtcbiAgICB9XG5cbiAgICBjb25zdCBheGlzID0gb3V0ZXJTaGFwZUIgPT09IDEgPyAyIDogMTtcblxuICAgIGxldCBiVmVjM2QgPSBiVmVjO1xuICAgIGlmIChzaG91bGRSZXNoYXBlQikge1xuICAgICAgYlZlYzNkID0gcmVzaGFwZSh7XG4gICAgICAgIGlucHV0czoge3g6IGJWZWN9LFxuICAgICAgICBiYWNrZW5kLFxuICAgICAgICBhdHRyczoge3NoYXBlOiBbYmF0Y2hEaW0sIDEsIHNoYXJlZERpbV19XG4gICAgICB9KTtcblxuICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKGJWZWMzZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZHVjdCA9IG11bHRpcGx5KHtpbnB1dHM6IHthOiBhVmVjM2QsIGI6IGJWZWMzZH0sIGJhY2tlbmR9KTtcbiAgICBvdXQgPSBzdW0oe2lucHV0czoge3g6IHByb2R1Y3R9LCBiYWNrZW5kLCBhdHRyczoge2F4aXMsIGtlZXBEaW1zOiB0cnVlfX0pO1xuICAgIGludGVybWVkaWF0ZXMucHVzaChwcm9kdWN0KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkdHlwZSA9IHVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSk7XG5cbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IE1hdE11bFBhY2tlZFByb2dyYW0oXG4gICAgICAgIGEzZFNoYXBlLCBiM2RTaGFwZSwgW2JhdGNoRGltLCBvdXRlclNoYXBlQSwgb3V0ZXJTaGFwZUJdLCB0cmFuc3Bvc2VBLFxuICAgICAgICB0cmFuc3Bvc2VCLCBoYXNCaWFzLCBmdXNlZEFjdGl2YXRpb24sIGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMsXG4gICAgICAgIGhhc0xlYWt5cmVsdUFscGhhKTtcblxuICAgIGNvbnN0IGlucHV0czogVGVuc29ySW5mb1tdID0gW2EzZCwgYjNkXTtcbiAgICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgICBpbnB1dHMucHVzaChiaWFzKTtcbiAgICB9XG4gICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICAgIGlucHV0cy5wdXNoKHByZWx1QWN0aXZhdGlvbldlaWdodHMpO1xuICAgIH1cbiAgICBpZiAoaGFzTGVha3lyZWx1QWxwaGEpIHtcbiAgICAgIGNvbnN0ICRsZWFreXJlbHVBbHBoYSA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oXG4gICAgICAgICAgW10sICdmbG9hdDMyJyxcbiAgICAgICAgICB1dGlsLmNyZWF0ZVNjYWxhclZhbHVlKGxlYWt5cmVsdUFscGhhIGFzIHt9IGFzICdmbG9hdDMyJywgJ2Zsb2F0MzInKSk7XG4gICAgICBpbnB1dHMucHVzaCgkbGVha3lyZWx1QWxwaGEpO1xuICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKCRsZWFreXJlbHVBbHBoYSk7XG4gICAgfVxuXG4gICAgb3V0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgaW5wdXRzLCBkdHlwZSk7XG4gIH1cblxuICBjb25zdCBvdXRSZXNoYXBlZCA9XG4gICAgICByZXNoYXBlKHtpbnB1dHM6IHt4OiBvdXR9LCBiYWNrZW5kLCBhdHRyczoge3NoYXBlOiBvdXRTaGFwZX19KTtcbiAgaW50ZXJtZWRpYXRlcy5wdXNoKG91dCk7XG4gIGZvciAoY29uc3QgaSBvZiBpbnRlcm1lZGlhdGVzKSB7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKTtcbiAgfVxuICByZXR1cm4gb3V0UmVzaGFwZWQ7XG59XG4iXX0=