{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length; // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n\n  const outputShape = [];\n  let product = 1;\n  let unknownIndex = -1;\n\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(`only one output dimension may be -1, not both ${unknownIndex} and ${d}`);\n      }\n\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(`size ${d} must be non-negative, not ${size}`);\n      }\n\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error('reshape cannot infer the missing ' + 'input size for an empty tensor unless all ' + 'specified input sizes are non-zero');\n    }\n\n    const missing = Math.trunc(denseSize / product);\n\n    if (product * missing !== denseSize) {\n      throw new Error(`Input to reshape is a SparseTensor with ${denseSize}\n          dense values, but the requested shape requires a multiple of ${product}. inputShape=${inputShape} outputShape= ${outputShape}`);\n    }\n\n    outputShape[unknownIndex] = missing;\n  }\n\n  const outputSize = util.sizeFromShape(outputShape);\n\n  if (outputSize !== denseSize) {\n    throw new Error(`Input to reshape is a tensor with ${denseSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`);\n  }\n\n  const inputRank = inputShape.length;\n  const inputStrides = [];\n\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n\n  const outputStrides = [];\n\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n\n  const newIndices = util.getArrayFromDType(inputDType, nnz * outputRank);\n\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n\n  return [newIndices, [nnz, outputRank], outputShape];\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/SparseReshape_impl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseReshapeImpl(\n    inputIndices: TypedArray, inputIndicesShape: number[], inputDType: DataType,\n    inputShape: number[],\n    targetShape: number[]): [TypedArray, number[], number[]] {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length;\n\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  const outputShape: number[] = [];\n  let product = 1;\n  let unknownIndex = -1;\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(`only one output dimension may be -1, not both ${\n            unknownIndex} and ${d}`);\n      }\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(`size ${d} must be non-negative, not ${size}`);\n      }\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error(\n          'reshape cannot infer the missing ' +\n          'input size for an empty tensor unless all ' +\n          'specified input sizes are non-zero');\n    }\n    const missing = Math.trunc(denseSize / product);\n    if (product * missing !== denseSize) {\n      throw new Error(`Input to reshape is a SparseTensor with ${denseSize}\n          dense values, but the requested shape requires a multiple of ${\n          product}. inputShape=${inputShape} outputShape= ${outputShape}`);\n    }\n\n    outputShape[unknownIndex] = missing;\n  }\n  const outputSize = util.sizeFromShape(outputShape);\n  if (outputSize !== denseSize) {\n    throw new Error(`Input to reshape is a tensor with ${\n        denseSize} dense values, but the requested shape has ${\n        outputSize}. inputShape=${inputShape} outputShape=${outputShape}`);\n  }\n\n  const inputRank = inputShape.length;\n  const inputStrides: number[] = [];\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n\n  const outputStrides: number[] = [];\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n\n  const newIndices =\n      util.getArrayFromDType(inputDType, nnz * outputRank) as TypedArray;\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n  return [newIndices, [nnz, outputRank], outputShape];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}