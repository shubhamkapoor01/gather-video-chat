{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nconst NEW_AXIS = -2;\nconst SHRINK_AXIS = -1;\nexport function assertParamsValid(input, begin, size) {\n  const inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` + `match the rank of the array (${inputRank}).`);\n  util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` + `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` + `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\n\nexport function maskToAxes(mask) {\n  const axes = [];\n  let axis = 0;\n\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n\n    mask /= 2;\n    axis++;\n  }\n\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\n\nexport function computeOutShape(begin, end, strides) {\n  const size = [];\n\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n\n  return size;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\n\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  const newStrides = [...strides];\n\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0\n      /* num elements to delete */\n      , 1\n      /* element to add */\n      );\n      newStrides.pop();\n    }\n  }\n\n  return newStrides;\n}\n\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  const elidedAxes = [];\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n\n  return elidedAxes;\n} // Normalize the start, end and strides.\n\n\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0]; // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\n\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  return newIndices;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\n\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  let stride = strides[axis];\n\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (start < 0) {\n    start += axisSize;\n  } // Clamping\n\n\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (stop < 0) {\n    stop += axisSize;\n  } // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n\n\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\n\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  let begin_;\n  const xRank = x.shape.length;\n\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n\n  begin_.forEach(d => {\n    util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_;\n\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` + `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n} // Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\n\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  let stridesNonNull;\n\n  if (strides == null) {\n    stridesNonNull = new Array(begin.length);\n    stridesNonNull.fill(1);\n  } else {\n    stridesNonNull = strides;\n  } // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n  // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n  // of 2. When i is a power of 2, i & (i - 1) is always 0.\n  // Also ref:\n  // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n\n\n  if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  } // Step 1: Account for ellipsis and new axis.\n  // Check for ellipsis and count how many non-newaxis there are after.\n\n\n  let ellipsisSeen = false;\n  const sparseSpec = {\n    dims: stridesNonNull.length,\n    numAddAxisAfterEllipsis: 0,\n    begin: begin.slice(),\n    end: end.slice(),\n    strides: stridesNonNull.slice(),\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  };\n\n  for (let i = 0; i < sparseSpec.dims; i++) {\n    if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {\n      sparseSpec.numAddAxisAfterEllipsis++;\n    }\n\n    if (1 << i & ellipsisMask) {\n      ellipsisSeen = true;\n    }\n  } // If no ellipsis insert one at the end.\n\n\n  if (!ellipsisSeen) {\n    sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;\n    sparseSpec.dims++; // this effects loop iteration below\n  } // Step 2: Make a sparse spec into a full index spec.\n  //\n  // The sparse spec deos not correspond to the number of dimensions.\n  // Make a dense spec that cooresponds to the number of dimensions.\n  //\n  // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n  // produce the missing beginMask for the first two dimensions i.e. from\n  // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n  // endMask = 7 (111).\n\n\n  const denseSpec = {\n    dims: xShape.length,\n    beginMask: 0,\n    endMask: 0,\n    beginValid: false,\n    endValid: false\n  };\n  buildDenseSpec(sparseSpec, denseSpec); // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n  // and bounds check.\n\n  let isIdentity = true;\n  let sliceDim0 = true;\n  let isSimpleSlice = true;\n  const processingShape = [];\n  const finalShape = [];\n\n  for (let i = 0; i < xShape.length; ++i) {\n    if (denseSpec.strides[i] === 0) {\n      throw Error(`strides[${i}] must be non-zero`);\n    }\n\n    const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i);\n    const dimI = xShape[i];\n\n    if (dimI === -1) {\n      processingShape.push(shrinkI ? 1 : -1);\n      continue;\n    }\n\n    const masks = [denseSpec.beginMask & 1 << i, denseSpec.endMask & 1 << i];\n    const validRange = [denseSpec.strides[i] > 0 ? 0 : -1, denseSpec.strides[i] > 0 ? dimI : dimI - 1];\n\n    if (shrinkI && denseSpec.strides[i] <= 0) {\n      throw Error('only stride 1 allowed on non-range indexing.');\n    }\n\n    isSimpleSlice = isSimpleSlice && denseSpec.strides[i] === 1;\n    const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i && denseSpec.endMask & 1 << i);\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      if (shrinkI) {\n        // If we are shrinking, the end index is now possibly incorrect. In\n        // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n        // and canonical puts these to n-1 and 0, which implies a degenerate\n        // interval. Fortunately, it is now safe to re-create end as begin + 1.\n        const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] : denseSpec.begin[i];\n        denseSpec.begin[i] = xFwd;\n        denseSpec.end[i] = denseSpec.begin[i] + 1;\n\n        if (xFwd < 0 || xFwd >= dimI) {\n          throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);\n        }\n      } else {\n        denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);\n        denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);\n      } // Update optimization values\n\n\n      const takeAllInDimension = denseSpec.strides[i] === 1 && denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;\n      isIdentity = isIdentity && takeAllInDimension;\n      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || takeAllInDimension);\n    } else {\n      isIdentity = isIdentity && denseSpec.strides[i] === 1 && beginAndEndMasked;\n      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || beginAndEndMasked);\n    } // Compute the processing shape (the intermediate Eigen will produce)\n\n\n    let intervalLength;\n    let knownInterval = false;\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      intervalLength = denseSpec.end[i] - denseSpec.begin[i];\n      knownInterval = true;\n    } else if (shrinkI) {\n      // The dimension is still known as 1 for the processingShape, but will be\n      // discarded for the final shape.\n      intervalLength = 1;\n      knownInterval = true;\n    } else if (beginAndEndMasked) {\n      // Even if we don't have values for begin or end, we do know that this\n      // dimension covers the whole interval. If we have shape information for\n      // this dimension, that tells us the interval length.\n      if (dimI >= 0) {\n        if (denseSpec.strides[i] < 0) {\n          intervalLength = -dimI;\n        } else {\n          intervalLength = dimI;\n        }\n\n        knownInterval = true;\n      }\n    }\n\n    if (knownInterval) {\n      let sizeI; // Hold zero if the interval is degenerate, otherwise account for\n      // remainder\n\n      if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i] < 0) {\n        sizeI = 0;\n      } else {\n        sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) + (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);\n      }\n\n      processingShape.push(sizeI);\n    } else {\n      processingShape.push(-1);\n    }\n  } // Step 4: Compute the final shape\n  //\n  // newAxis will increase dimension by 1 (with a one-size dimension)\n  // slices like foo[3, ...] will reduce dimension by 1.\n  // This cannot be done earlier, because it depends on Step 3.\n\n\n  for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {\n    const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n\n    if (gatherIndex >= 0) {\n      finalShape.push(processingShape[gatherIndex]);\n    } else if (gatherIndex === NEW_AXIS) {\n      finalShape.push(1);\n    }\n  }\n\n  const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);\n  return {\n    finalShapeSparse,\n    finalShape,\n    isIdentity,\n    sliceDim0,\n    isSimpleSlice,\n    begin: denseSpec.begin,\n    end: denseSpec.end,\n    strides: denseSpec.strides\n  };\n}\n\nfunction buildDenseSpec(sparse, dense) {\n  dense.beginMask = 0;\n  dense.endMask = 0;\n  dense.shrinkAxisMask = 0;\n  let fullIndex = 0;\n  dense.beginValid = sparse.begin != null;\n  dense.endValid = sparse.end != null;\n  dense.begin = new Array(dense.dims);\n  dense.end = new Array(dense.dims);\n  dense.strides = new Array(dense.dims);\n  dense.finalShapeGatherIndices = [];\n  dense.finalShapeGatherIndicesSparse = [];\n  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n\n  for (let i = 0; i < sparse.dims; i++) {\n    if (1 << i & sparse.ellipsisMask) {\n      // Only the bit that has ellipsis will fall in this condition.\n      // Expand the ellipsis into the appropriate indices\n      // Note: this only works because we guaranteed one ellipsis.\n      const nextIndex = Math.min(dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis, dense.dims);\n\n      for (; fullIndex < nextIndex; fullIndex++) {\n        // newAxis aren't real axis so you have to skip.\n        dense.begin[fullIndex] = 0;\n        dense.end[fullIndex] = 0;\n        dense.strides[fullIndex] = 1;\n        dense.beginMask |= 1 << fullIndex;\n        dense.endMask |= 1 << fullIndex;\n        dense.finalShapeGatherIndices.push(fullIndex);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      }\n    } else if (1 << i & sparse.newAxisMask) {\n      // Only the bit that has newAxis will fall in this condition.\n      dense.finalShapeGatherIndices.push(NEW_AXIS);\n      dense.finalShapeGatherIndicesSparse.push(-1);\n    } else {\n      if (fullIndex === dense.begin.length) {\n        throw Error(`Index out of range using input dim ${fullIndex}; input ` + `has only ${dense.dims} dims, ${dense.begin.length}.`);\n      } // Gather slicing spec into appropriate index.\n\n\n      if (sparse.begin != null) {\n        dense.begin[fullIndex] = sparse.begin[i];\n      }\n\n      if (sparse.end != null) {\n        dense.end[fullIndex] = sparse.end[i];\n      }\n\n      dense.strides[fullIndex] = sparse.strides[i];\n\n      if (sparse.beginMask & 1 << i) {\n        dense.beginMask |= 1 << fullIndex;\n      }\n\n      if (sparse.endMask & 1 << i) {\n        dense.endMask |= 1 << fullIndex;\n      } // If shrink, record where to get the dimensionality from (i.e. newAxis)\n      // creates a fake 1 size dimension. Also remember shrink axis (now in\n      // dense form) so we can ignore dense.end below.\n\n\n      if (sparse.shrinkAxisMask & 1 << i) {\n        dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.shrinkAxisMask |= 1 << fullIndex;\n      } else {\n        dense.finalShapeGatherIndices.push(fullIndex); // Remember that where in the sparse shape the dense dim comes from.\n\n        dense.finalShapeGatherIndicesSparse.push(i);\n      }\n\n      dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      fullIndex++;\n    }\n  }\n}\n\nfunction canonical(x, c, strideI, dimI, masks, validRange) {\n  if (masks[c]) {\n    return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];\n  } else {\n    const xFwd = x < 0 ? dimI + x : x; // make negative indices positive\n\n    return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;\n  }\n}","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/slice_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '../kernel_registry';\nimport * as util from '../util';\n\nconst NEW_AXIS = -2;\nconst SHRINK_AXIS = -1;\n\n// Sparse slicing specification\n// if one does foo[3:5, ..., -3], the begin, end and strides will have length\n// of 3.\ninterface StridedSliceSparseSpec {\n  dims: number;\n  numAddAxisAfterEllipsis: number;\n  begin: number[];\n  end: number[];\n  strides: number[];\n  beginMask: number;\n  endMask: number;\n  ellipsisMask: number;\n  newAxisMask: number;\n  shrinkAxisMask: number;\n}\n\n// Dense slicing specification\n// all ellipses and newaxis are expanded out. So if foo[3:5, ..., -3] where foo\n// is 10 dimensional, each array of begin, end, strides will have 10 entries\n// where as the sparse can have length less than the rank of foo.\ninterface StridedSliceDenseSpec {\n  dims: number;\n  beginMask?: number;\n  endMask?: number;\n  beginValid: boolean;\n  endValid: boolean;\n  begin?: number[];\n  end?: number[];\n  strides?: number[];\n  // This array helps construct the final shape of the slice.\n  // The final tensor is reduced in rank whenever a single index e.g. foo[3]\n  // is called for. The final tensor increases in rank with newAxis entries.\n  // If an index in this array is positive, the size of the dimension is\n  // obtained from canonical end-begin.  Otherwise, if it is a NEW_AXIS, it will\n  // be 1. A shrunk dimension is skipped.\n  finalShapeGatherIndices?: number[];\n  // This array has the same size as finalShapeGatherIndices, but it remembers\n  // the sparse index that a dimension comes from, instead of dense index.\n  // A -1 in this vector means the index is not from the sparse input.\n  finalShapeGatherIndicesSparse?: number[];\n  inputShapeGatherIndicesSparse?: number[];\n  // The dense indexed shrink mask is which processing dimensions should be\n  // shrunk. For example, if foo.shape = [10, 10, 10, 10], foo[3, ..., 5] has\n  // sparseShrinkAxisMask of 5 (0101) and denseShrinkAxisMask of 9 (1001),\n  // yielding a final shape [10, 10].\n  shrinkAxisMask?: number;\n}\n\nexport type SliceInfo = {\n  finalShapeSparse: number[],\n  finalShape: number[],\n  isIdentity: boolean,\n  sliceDim0: boolean,\n  isSimpleSlice: boolean,\n  begin: number[],\n  end: number[],\n  strides: number[]\n};\n\nexport function assertParamsValid(\n    input: TensorInfo, begin: number[], size: number[]): void {\n  const inputRank = input.shape.length;\n  util.assert(\n      inputRank === begin.length,\n      () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n          `match the rank of the array (${inputRank}).`);\n  util.assert(\n      inputRank === size.length,\n      () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n          `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(\n        begin[i] + size[i] <= input.shape[i],\n        () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${\n                  input.shape[i]})`);\n  }\n}\n\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask: number): number[] {\n  const axes = [];\n  let axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(\n    begin: number[], end: number[], strides: number[]): number[] {\n  const size = [];\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(\n    strides: number[], ellipsisInsertionIndex: number, numElidedAxes: number,\n    inputShape: number[]): number[] {\n  const newStrides = [...strides];\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(\n          ellipsisInsertionIndex, 0 /* num elements to delete */,\n          1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\n\nfunction unnormalizeAxis(\n    ellipsisInsertionIndex: number, numElidedAxes: number,\n    normalizedAxis: number): number {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes: number, ellipsisInsertionIndex: number) {\n  const elidedAxes = [];\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(\n    inputShape: number[], ellipsisAxes: number[], numInterpolatedAxes: number,\n    begin: number[], end: number[], strides: number[], beginMask: number,\n    endMask: number,\n    ellipsisMask: number): {begin: number[], end: number[], strides: number[]} {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0];\n\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(\n        beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(\n        endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides =\n        stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(\n          beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] =\n          stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(\n    beginMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalBegin: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(\n    endMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalEnd: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\n\nexport function stridesForAxis(\n    strides: number[], axis: number, ellipsisMask: number): number {\n  let stride = strides[axis];\n  if (ellipsisMask & (1 << axis) || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\n\nexport function startForAxis(\n    beginMask: number, startIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n\n  return start;\n}\n\nexport function stopForAxis(\n    endMask: number, stopIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(\n    shape: number[], begin: number[], size: number[]) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function computeFlatOffset(begin: number[], strides: number[]): number {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\n\nexport function parseSliceParams(\n    x: TensorInfo, begin: number|number[], size?: number|number[]) {\n  // The following logic allows for more ergonomic calls.\n  let begin_: number[];\n  const xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(\n        d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_: number[];\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(\n          d === -1,\n          () => `Negative size values should be exactly -1 but got ` +\n              `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\n\n// Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\nexport function sliceInfo(\n    xShape: number[], begin: number[], end: number[], strides: number[],\n    beginMask: number, endMask: number, ellipsisMask: number,\n    newAxisMask: number, shrinkAxisMask: number): SliceInfo {\n  let stridesNonNull;\n  if (strides == null) {\n    stridesNonNull = new Array(begin.length);\n    stridesNonNull.fill(1);\n  } else {\n    stridesNonNull = strides;\n  }\n\n  // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n  // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n  // of 2. When i is a power of 2, i & (i - 1) is always 0.\n  // Also ref:\n  // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n  if (ellipsisMask != null && (ellipsisMask & (ellipsisMask - 1)) !== 0) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  // Step 1: Account for ellipsis and new axis.\n  // Check for ellipsis and count how many non-newaxis there are after.\n  let ellipsisSeen = false;\n\n  const sparseSpec: StridedSliceSparseSpec = {\n    dims: stridesNonNull.length,\n    numAddAxisAfterEllipsis: 0,\n    begin: begin.slice(),\n    end: end.slice(),\n    strides: stridesNonNull.slice(),\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  };\n\n  for (let i = 0; i < sparseSpec.dims; i++) {\n    if (ellipsisSeen && ((1 << i) & newAxisMask) !== 0) {\n      sparseSpec.numAddAxisAfterEllipsis++;\n    }\n    if ((1 << i) & ellipsisMask) {\n      ellipsisSeen = true;\n    }\n  }\n  // If no ellipsis insert one at the end.\n  if (!ellipsisSeen) {\n    sparseSpec.ellipsisMask |= (1 << sparseSpec.dims);\n    sparseSpec.dims++;  // this effects loop iteration below\n  }\n\n  // Step 2: Make a sparse spec into a full index spec.\n  //\n  // The sparse spec deos not correspond to the number of dimensions.\n  // Make a dense spec that cooresponds to the number of dimensions.\n  //\n  // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n  // produce the missing beginMask for the first two dimensions i.e. from\n  // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n  // endMask = 7 (111).\n  const denseSpec: StridedSliceDenseSpec = {\n    dims: xShape.length,\n    beginMask: 0,\n    endMask: 0,\n    beginValid: false,\n    endValid: false\n  };\n\n  buildDenseSpec(sparseSpec, denseSpec);\n\n  // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n  // and bounds check.\n  let isIdentity = true;\n  let sliceDim0 = true;\n  let isSimpleSlice = true;\n  const processingShape = [];\n  const finalShape = [];\n\n  for (let i = 0; i < xShape.length; ++i) {\n    if (denseSpec.strides[i] === 0) {\n      throw Error(`strides[${i}] must be non-zero`);\n    }\n    const shrinkI = !!(denseSpec.shrinkAxisMask & (1 << i));\n    const dimI = xShape[i];\n    if (dimI === -1) {\n      processingShape.push(shrinkI ? 1 : -1);\n      continue;\n    }\n\n    const masks =\n        [denseSpec.beginMask & (1 << i), denseSpec.endMask & (1 << i)];\n    const validRange = [\n      denseSpec.strides[i] > 0 ? 0 : -1,\n      denseSpec.strides[i] > 0 ? dimI : dimI - 1\n    ];\n\n    if (shrinkI && denseSpec.strides[i] <= 0) {\n      throw Error('only stride 1 allowed on non-range indexing.');\n    }\n\n    isSimpleSlice = isSimpleSlice && (denseSpec.strides[i] === 1);\n\n    const beginAndEndMasked =\n        !!((denseSpec.beginMask & (1 << i)) && (denseSpec.endMask & (1 << i)));\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      if (shrinkI) {\n        // If we are shrinking, the end index is now possibly incorrect. In\n        // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n        // and canonical puts these to n-1 and 0, which implies a degenerate\n        // interval. Fortunately, it is now safe to re-create end as begin + 1.\n        const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] :\n                                              denseSpec.begin[i];\n        denseSpec.begin[i] = xFwd;\n        denseSpec.end[i] = denseSpec.begin[i] + 1;\n        if (xFwd < 0 || xFwd >= dimI) {\n          throw Error(`slice index ${denseSpec.begin[i]} of dimension ${\n              i} out of bounds.`);\n        }\n      } else {\n        denseSpec.begin[i] = canonical(\n            denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks,\n            validRange);\n        denseSpec.end[i] = canonical(\n            denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);\n      }\n      // Update optimization values\n      const takeAllInDimension = denseSpec.strides[i] === 1 &&\n          denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;\n      isIdentity = isIdentity && takeAllInDimension;\n      sliceDim0 = sliceDim0 &&\n          ((i === 0 && denseSpec.strides[i] === 1) || takeAllInDimension);\n    } else {\n      isIdentity =\n          isIdentity && ((denseSpec.strides[i] === 1) && beginAndEndMasked);\n      sliceDim0 = sliceDim0 &&\n          ((i === 0 && denseSpec.strides[i] === 1) || beginAndEndMasked);\n    }\n    // Compute the processing shape (the intermediate Eigen will produce)\n    let intervalLength;\n    let knownInterval = false;\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      intervalLength = denseSpec.end[i] - denseSpec.begin[i];\n      knownInterval = true;\n    } else if (shrinkI) {\n      // The dimension is still known as 1 for the processingShape, but will be\n      // discarded for the final shape.\n      intervalLength = 1;\n      knownInterval = true;\n    } else if (beginAndEndMasked) {\n      // Even if we don't have values for begin or end, we do know that this\n      // dimension covers the whole interval. If we have shape information for\n      // this dimension, that tells us the interval length.\n      if (dimI >= 0) {\n        if (denseSpec.strides[i] < 0) {\n          intervalLength = -dimI;\n        } else {\n          intervalLength = dimI;\n        }\n        knownInterval = true;\n      }\n    }\n    if (knownInterval) {\n      let sizeI;\n      // Hold zero if the interval is degenerate, otherwise account for\n      // remainder\n      if (intervalLength === 0 ||\n          ((intervalLength < 0) !== (denseSpec.strides[i] < 0))) {\n        sizeI = 0;\n      } else {\n        sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) +\n            (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);\n      }\n      processingShape.push(sizeI);\n    } else {\n      processingShape.push(-1);\n    }\n  }\n\n  // Step 4: Compute the final shape\n  //\n  // newAxis will increase dimension by 1 (with a one-size dimension)\n  // slices like foo[3, ...] will reduce dimension by 1.\n  // This cannot be done earlier, because it depends on Step 3.\n  for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length;\n       ++denseDim) {\n    const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n    if (gatherIndex >= 0) {\n      finalShape.push(processingShape[gatherIndex]);\n    } else if (gatherIndex === NEW_AXIS) {\n      finalShape.push(1);\n    }\n  }\n\n  const finalShapeSparse = finalShape.filter(\n      (dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);\n\n  return {\n    finalShapeSparse,\n    finalShape,\n    isIdentity,\n    sliceDim0,\n    isSimpleSlice,\n    begin: denseSpec.begin,\n    end: denseSpec.end,\n    strides: denseSpec.strides\n  };\n}\n\nfunction buildDenseSpec(\n    sparse: StridedSliceSparseSpec, dense: StridedSliceDenseSpec) {\n  dense.beginMask = 0;\n  dense.endMask = 0;\n  dense.shrinkAxisMask = 0;\n\n  let fullIndex = 0;\n  dense.beginValid = sparse.begin != null;\n  dense.endValid = sparse.end != null;\n\n  dense.begin = new Array(dense.dims);\n  dense.end = new Array(dense.dims);\n  dense.strides = new Array(dense.dims);\n  dense.finalShapeGatherIndices = [];\n  dense.finalShapeGatherIndicesSparse = [];\n  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n\n  for (let i = 0; i < sparse.dims; i++) {\n    if ((1 << i) & sparse.ellipsisMask) {\n      // Only the bit that has ellipsis will fall in this condition.\n      // Expand the ellipsis into the appropriate indices\n      // Note: this only works because we guaranteed one ellipsis.\n      const nextIndex = Math.min(\n          dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis,\n          dense.dims);\n      for (; fullIndex < nextIndex; fullIndex++) {\n        // newAxis aren't real axis so you have to skip.\n        dense.begin[fullIndex] = 0;\n        dense.end[fullIndex] = 0;\n        dense.strides[fullIndex] = 1;\n        dense.beginMask |= (1 << fullIndex);\n        dense.endMask |= (1 << fullIndex);\n        dense.finalShapeGatherIndices.push(fullIndex);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      }\n    } else if ((1 << i) & sparse.newAxisMask) {\n      // Only the bit that has newAxis will fall in this condition.\n      dense.finalShapeGatherIndices.push(NEW_AXIS);\n      dense.finalShapeGatherIndicesSparse.push(-1);\n    } else {\n      if (fullIndex === dense.begin.length) {\n        throw Error(\n            `Index out of range using input dim ${fullIndex}; input ` +\n            `has only ${dense.dims} dims, ${dense.begin.length}.`);\n      }\n\n      // Gather slicing spec into appropriate index.\n      if (sparse.begin != null) {\n        dense.begin[fullIndex] = sparse.begin[i];\n      }\n      if (sparse.end != null) {\n        dense.end[fullIndex] = sparse.end[i];\n      }\n      dense.strides[fullIndex] = sparse.strides[i];\n      if (sparse.beginMask & (1 << i)) {\n        dense.beginMask |= (1 << fullIndex);\n      }\n      if (sparse.endMask & (1 << i)) {\n        dense.endMask |= (1 << fullIndex);\n      }\n      // If shrink, record where to get the dimensionality from (i.e. newAxis)\n      // creates a fake 1 size dimension. Also remember shrink axis (now in\n      // dense form) so we can ignore dense.end below.\n      if (sparse.shrinkAxisMask & (1 << i)) {\n        dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.shrinkAxisMask |= (1 << fullIndex);\n      } else {\n        dense.finalShapeGatherIndices.push(fullIndex);\n        // Remember that where in the sparse shape the dense dim comes from.\n        dense.finalShapeGatherIndicesSparse.push(i);\n      }\n      dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      fullIndex++;\n    }\n  }\n}\n\nfunction canonical(\n    x: number, c: number, strideI: number, dimI: number, masks: number[],\n    validRange: number[]) {\n  if (masks[c]) {\n    return strideI > 0 ? validRange[c] : validRange[(c + 1) & 1];\n  } else {\n    const xFwd = x < 0 ? dimI + x : x;  // make negative indices positive\n    return xFwd < validRange[0] ? validRange[0] :\n                                  xFwd > validRange[1] ? validRange[1] : xFwd;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}