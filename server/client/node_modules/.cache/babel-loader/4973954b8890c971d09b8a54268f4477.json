{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\n\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {\n  const strides = util.computeStrides(shape);\n  return strides.map((stride, i) => {\n    const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;\n    return `${line1}; ${line2};`;\n  }).join('');\n}\nexport function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords, shape, index = 'index') {\n  const strides = util.computeStrides(shape);\n  return strides.map((_, i) => {\n    const line1 = `int ${coords[i]} = ${index} / outShapeStrides[${i}]`;\n    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * outShapeStrides[${i}]` : `index -= ${coords[i]} * outShapeStrides[${i}]`;\n    return `${line1}; ${line2};`;\n  }).join('');\n} // Produces GLSL code that computes strides.\n\nfunction symbolicallyComputeStrides(indicesArr, variableName) {\n  const numCoords = indicesArr.length;\n  const shape = indicesArr.map(d => `${variableName}[${d}]`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n\n  return strides;\n}\n\nexport function getLogicalCoordinatesFromFlatIndexByUniform(coords, variableName, index = 'index') {\n  const indicesArray = coords.map((_, i) => i);\n  const strides = symbolicallyComputeStrides(indicesArray, variableName);\n  return strides.map((_, i) => {\n    const line1 = `int ${coords[i]} = ${index} / ${strides[i]}`;\n    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${strides[i]}` : `index -= ${coords[i]} * ${strides[i]}`;\n    return `${line1}; ${line2};`;\n  }).join('');\n}\n\nfunction buildVec(x) {\n  if (x.length === 1) {\n    return `${x[0]}`;\n  }\n\n  return `vec${x.length}(${x.join(',')})`;\n}\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\n\n\nexport function dotify(x, y) {\n  if (x.length !== y.length) {\n    throw new Error(`Vectors to be dotted must be of the same length -` + `got ${x.length} and ${y.length}`);\n  }\n\n  const slices = [];\n  const nearestVec4 = Math.floor(x.length / 4);\n  const nearestVec4Remainder = x.length % 4;\n\n  for (let i = 0; i < nearestVec4; i++) {\n    const xSlice = x.slice(i * 4, i * 4 + 4);\n    const ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    let xSlice = x.slice(nearestVec4 * 4);\n    let ySlice = y.slice(nearestVec4 * 4);\n\n    if (xSlice.length === 1) {\n      xSlice = xSlice.map(d => `float(${d})`);\n      ySlice = ySlice.map(d => `float(${d})`);\n    }\n\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  return slices.map((d, i) => `dot(${d})`).join('+');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\n\nexport function getFlatIndexFrom3D(shape) {\n  const strides = util.computeStrides(shape).map(d => d.toString());\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\nexport function getFlatIndexFrom3DOutput() {\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`;\n}\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;","map":{"version":3,"sources":["../../../../../tfjs-backend-webgl/src/shader_compiler_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,IAAR,QAAmB,uBAAnB;AAEA;;;;AAIG;;AACH,OAAM,SAAU,kCAAV,CACF,MADE,EACgB,KADhB,EACiC,KAAK,GAAG,OADzC,EACgD;AACpD,QAAM,OAAO,GAAG,IAAI,CAAC,cAAL,CAAoB,KAApB,CAAhB;AACA,SAAO,OAAO,CACT,GADE,CACE,CAAC,MAAD,EAAS,CAAT,KAAc;AACjB,UAAM,KAAK,GAAG,OAAO,MAAM,CAAC,CAAD,CAAG,MAAM,KAAK,MAAM,MAAM,EAArD;AACA,UAAM,KAAK,GAAG,CAAC,KAAK,OAAO,CAAC,MAAR,GAAiB,CAAvB,GACV,OAAO,MAAM,CAAC,CAAC,GAAG,CAAL,CAAO,MAAM,KAAK,MAAM,MAAM,CAAC,CAAD,CAAG,MAAM,MAAM,EADhD,GAEV,YAAY,MAAM,CAAC,CAAD,CAAG,MAAM,MAAM,EAFrC;AAGA,WAAO,GAAG,KAAK,KAAK,KAAK,GAAzB;AACD,GAPE,EAQF,IARE,CAQG,EARH,CAAP;AASD;AAED,OAAM,SAAU,iDAAV,CACF,MADE,EACgB,KADhB,EACiC,KAAK,GAAG,OADzC,EACgD;AACpD,QAAM,OAAO,GAAG,IAAI,CAAC,cAAL,CAAoB,KAApB,CAAhB;AACA,SAAO,OAAO,CACT,GADE,CACE,CAAC,CAAD,EAAI,CAAJ,KAAS;AACZ,UAAM,KAAK,GAAG,OAAO,MAAM,CAAC,CAAD,CAAG,MAAM,KAAK,sBAAsB,CAAC,GAAhE;AACA,UAAM,KAAK,GAAG,CAAC,KAAK,OAAO,CAAC,MAAR,GAAiB,CAAvB,GACV,OAAO,MAAM,CAAC,CAAC,GAAG,CAAL,CAAO,MAAM,KAAK,MAAM,MAAM,CAAC,CAAD,CAAG,sBAC1C,CAAC,GAFK,GAGV,YAAY,MAAM,CAAC,CAAD,CAAG,sBAAsB,CAAC,GAHhD;AAIA,WAAO,GAAG,KAAK,KAAK,KAAK,GAAzB;AACD,GARE,EASF,IATE,CASG,EATH,CAAP;AAUD,C,CAED;;AACA,SAAS,0BAAT,CACI,UADJ,EAC0B,YAD1B,EAC8C;AAC5C,QAAM,SAAS,GAAG,UAAU,CAAC,MAA7B;AACA,QAAM,KAAK,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,IAAI,GAAG,YAAY,IAAI,CAAC,GAAxC,CAAd;AACA,QAAM,OAAO,GAAG,IAAI,KAAJ,CAAU,SAAS,GAAG,CAAtB,CAAhB;AACA,EAAA,OAAO,CAAC,SAAS,GAAG,CAAb,CAAP,GAAyB,KAAK,CAAC,SAAS,GAAG,CAAb,CAA9B;;AACA,OAAK,IAAI,CAAC,GAAG,SAAS,GAAG,CAAzB,EAA4B,CAAC,IAAI,CAAjC,EAAoC,EAAE,CAAtC,EAAyC;AACvC,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,IAAI,OAAO,CAAC,CAAC,GAAG,CAAL,CAAO,MAAM,KAAK,CAAC,CAAC,GAAG,CAAL,CAAO,GAAjD;AACD;;AAED,SAAO,OAAP;AACD;;AAED,OAAM,SAAU,2CAAV,CACF,MADE,EACgB,YADhB,EACsC,KAAK,GAAG,OAD9C,EACqD;AACzD,QAAM,YAAY,GAAG,MAAM,CAAC,GAAP,CAAW,CAAC,CAAD,EAAI,CAAJ,KAAU,CAArB,CAArB;AACA,QAAM,OAAO,GAAG,0BAA0B,CAAC,YAAD,EAAe,YAAf,CAA1C;AACA,SAAO,OAAO,CACT,GADE,CACE,CAAC,CAAD,EAAI,CAAJ,KAAS;AACZ,UAAM,KAAK,GAAG,OAAO,MAAM,CAAC,CAAD,CAAG,MAAM,KAAK,MAAM,OAAO,CAAC,CAAD,CAAG,EAAzD;AACA,UAAM,KAAK,GAAG,CAAC,KAAK,OAAO,CAAC,MAAR,GAAiB,CAAvB,GACV,OAAO,MAAM,CAAC,CAAC,GAAG,CAAL,CAAO,MAAM,KAAK,MAAM,MAAM,CAAC,CAAD,CAAG,MAAM,OAAO,CAAC,CAAD,CAAG,EADpD,GAEV,YAAY,MAAM,CAAC,CAAD,CAAG,MAAM,OAAO,CAAC,CAAD,CAAG,EAFzC;AAGA,WAAO,GAAG,KAAK,KAAK,KAAK,GAAzB;AACD,GAPE,EAQF,IARE,CAQG,EARH,CAAP;AASD;;AAED,SAAS,QAAT,CAAkB,CAAlB,EAA6B;AAC3B,MAAI,CAAC,CAAC,MAAF,KAAa,CAAjB,EAAoB;AAClB,WAAO,GAAG,CAAC,CAAC,CAAD,CAAG,EAAd;AACD;;AACD,SAAO,MAAM,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,IAAF,CAAO,GAAP,CAAW,GAApC;AACD;AAED;;;AAGG;;;AACH,OAAM,SAAU,MAAV,CAAiB,CAAjB,EAA8B,CAA9B,EAAyC;AAC7C,MAAI,CAAC,CAAC,MAAF,KAAa,CAAC,CAAC,MAAnB,EAA2B;AACzB,UAAM,IAAI,KAAJ,CACF,mDAAA,GACA,OAAO,CAAC,CAAC,MAAM,QAAQ,CAAC,CAAC,MAAM,EAF7B,CAAN;AAGD;;AAED,QAAM,MAAM,GAAa,EAAzB;AACA,QAAM,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,CAAC,MAAF,GAAW,CAAtB,CAApB;AACA,QAAM,oBAAoB,GAAG,CAAC,CAAC,MAAF,GAAW,CAAxC;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,CAAC,EAAlC,EAAsC;AACpC,UAAM,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAC,GAAG,CAAZ,EAAe,CAAC,GAAG,CAAJ,GAAQ,CAAvB,CAAf;AACA,UAAM,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAC,GAAG,CAAZ,EAAe,CAAC,GAAG,CAAJ,GAAQ,CAAvB,CAAf;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,GAAG,QAAQ,CAAC,MAAD,CAAQ,KAAK,QAAQ,CAAC,MAAD,CAAQ,EAApD;AACD;;AAED,MAAI,oBAAoB,KAAK,CAA7B,EAAgC;AAC9B,QAAI,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,WAAW,GAAG,CAAtB,CAAb;AACA,QAAI,MAAM,GAAG,CAAC,CAAC,KAAF,CAAQ,WAAW,GAAG,CAAtB,CAAb;;AACA,QAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB;AACvB,MAAA,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,CAAC,IAAI,SAAS,CAAC,GAA1B,CAAT;AACA,MAAA,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,CAAC,IAAI,SAAS,CAAC,GAA1B,CAAT;AACD;;AACD,IAAA,MAAM,CAAC,IAAP,CAAY,GAAG,QAAQ,CAAC,MAAD,CAAQ,KAAK,QAAQ,CAAC,MAAD,CAAQ,EAApD;AACD;;AAED,SAAO,MAAM,CAAC,GAAP,CAAW,CAAC,CAAD,EAAI,CAAJ,KAAU,OAAO,CAAC,GAA7B,EAAkC,IAAlC,CAAuC,GAAvC,CAAP;AACD;AAED;;AAEG;;AACH,OAAM,SAAU,kBAAV,CAA6B,KAA7B,EAA4D;AAChE,QAAM,OAAO,GAAG,IAAI,CAAC,cAAL,CAAoB,KAApB,EAA2B,GAA3B,CAA+B,CAAC,IAAI,CAAC,CAAC,QAAF,EAApC,CAAhB;AAEA,SAAO;;wBAEe,OAAO,CAAC,CAAD,CAAG,iBAAiB,OAAO,CAAC,CAAD,CAAG;;AAE5D,CAJC;AAKD;AAED,OAAM,SAAU,wBAAV,GAAkC;AACtC,SAAO;;;;AAIR,CAJC;AAKD;AAED,OAAO,MAAM,oBAAoB,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCnC,CAvCM","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(\n    coords: string[], shape: number[], index = 'index'): string {\n  const strides = util.computeStrides(shape);\n  return strides\n      .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\nexport function getOutputLogicalCoordinatesFromFlatIndexByUniform(\n    coords: string[], shape: number[], index = 'index'): string {\n  const strides = util.computeStrides(shape);\n  return strides\n      .map((_, i) => {\n        const line1 = `int ${coords[i]} = ${index} / outShapeStrides[${i}]`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * outShapeStrides[${\n                i}]` :\n            `index -= ${coords[i]} * outShapeStrides[${i}]`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\n// Produces GLSL code that computes strides.\nfunction symbolicallyComputeStrides(\n    indicesArr: number[], variableName: string): string[] {\n  const numCoords = indicesArr.length;\n  const shape = indicesArr.map(d => `${variableName}[${d}]`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n\n  return strides;\n}\n\nexport function getLogicalCoordinatesFromFlatIndexByUniform(\n    coords: string[], variableName: string, index = 'index'): string {\n  const indicesArray = coords.map((_, i) => i);\n  const strides = symbolicallyComputeStrides(indicesArray, variableName);\n  return strides\n      .map((_, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${strides[i]}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${strides[i]}` :\n            `index -= ${coords[i]} * ${strides[i]}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\nfunction buildVec(x: string[]): string {\n  if (x.length === 1) {\n    return `${x[0]}`;\n  }\n  return `vec${x.length}(${x.join(',')})`;\n}\n\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x: string[], y: string[]): string {\n  if (x.length !== y.length) {\n    throw new Error(\n        `Vectors to be dotted must be of the same length -` +\n        `got ${x.length} and ${y.length}`);\n  }\n\n  const slices: string[] = [];\n  const nearestVec4 = Math.floor(x.length / 4);\n  const nearestVec4Remainder = x.length % 4;\n\n  for (let i = 0; i < nearestVec4; i++) {\n    const xSlice = x.slice(i * 4, i * 4 + 4);\n    const ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    let xSlice = x.slice(nearestVec4 * 4);\n    let ySlice = y.slice(nearestVec4 * 4);\n    if (xSlice.length === 1) {\n      xSlice = xSlice.map(d => `float(${d})`);\n      ySlice = ySlice.map(d => `float(${d})`);\n    }\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  return slices.map((d, i) => `dot(${d})`).join('+');\n}\n\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape: [number, number, number]): string {\n  const strides = util.computeStrides(shape).map(d => d.toString());\n\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\n\nexport function getFlatIndexFrom3DOutput(): string {\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`;\n}\n\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}