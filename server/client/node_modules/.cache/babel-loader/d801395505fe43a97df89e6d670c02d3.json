{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {\n  const numIndices = indices.length;\n\n  if (numIndices !== segmentIds.length) {\n    throw new Error(`segmentIds and indices should have same size.`);\n  } // Flatten the array to two dimensions\n\n\n  const inputFlat = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1]; // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n\n  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n  const outputLength = outputShape.reduce((product, value) => product * value, 1); // Output array is initialized with the value 0 by default.\n\n  const output = util.getArrayFromDType(inputDType, outputLength); // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  let start = 0,\n      end = 1; // Index from which the output is not initialized.\n\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      } // We have a new segment here.  Verify that the segment ids are growing.\n\n\n      if (outIndex >= nextIndex) {\n        throw new Error(`segment ids are not increasing`);\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(`Segment id ${outIndex} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`);\n    } // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n\n\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(`Bad: indices[${i}] == ${indices[i]} out of range [0, ${inputFlat[0]})`);\n      }\n\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n\n    if (end > numIndices) {\n      break;\n    }\n  } // Fill the gap at the end with the default value.\n\n\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/SparseSegmentReduction_impl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseSegmentReductionImpl(\n    input: TypedArray, inputShape: number[], inputDType: DataType,\n    indices: TypedArray, segmentIds: TypedArray, isMean = false,\n    defaultValue = 0): [TypedArray, number[]] {\n  const numIndices = indices.length;\n  if (numIndices !== segmentIds.length) {\n    throw new Error(`segmentIds and indices should have same size.`);\n  }\n\n  // Flatten the array to two dimensions\n  const inputFlat: number[] = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne =\n      numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n\n  const outputLength =\n      outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength) as TypedArray;\n\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  let start = 0, end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(`segment ids are not increasing`);\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(`Segment id ${outIndex} out of range [0, ${\n          outputRows}), possibly because segmentIds input is not sorted.`);\n    }\n\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(`Bad: indices[${i}] == ${indices[i]} out of range [0, ${\n            inputFlat[0]})`);\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}