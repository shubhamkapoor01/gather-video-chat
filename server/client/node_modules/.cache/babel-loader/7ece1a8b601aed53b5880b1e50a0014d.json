{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n  const {\n    inputs,\n    attrs,\n    backend\n  } = args;\n  const {\n    image,\n    transforms\n  } = inputs;\n  const {\n    interpolation,\n    fillMode,\n    fillValue,\n    outputShape\n  } = attrs;\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape = [batch, outHeight, outWidth, numChannels];\n  const strides = util.computeStrides(image.shape);\n  const batchStride = strides[0];\n  const rowStride = strides[1];\n  const colStride = strides[2];\n  const outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n  outVals.fill(fillValue);\n  const imageVals = backend.data.get(image.dataId).values;\n  const transformVals = backend.data.get(transforms.dataId).values; // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n\n  for (let b = 0; b < batch; ++b) {\n    const transform = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);\n\n    for (let outY = 0; outY < outHeight; ++outY) {\n      for (let outX = 0; outX < outWidth; ++outX) {\n        for (let channel = 0; channel < numChannels; ++channel) {\n          let val;\n          const projection = transform[6] * outX + transform[7] * outY + 1;\n\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n\n          const inX = (transform[0] * outX + transform[1] * outY + transform[2]) / projection;\n          const inY = (transform[3] * outX + transform[4] * outY + transform[5]) / projection;\n          const x = mapCoord(inX, imageWidth, fillMode);\n          const y = mapCoord(inY, imageHeight, fillMode);\n\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n              break;\n\n            case 'bilinear':\n              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n              break;\n\n            default:\n              throw new Error(`Error in Transform: Expect 'nearest' or ` + `'bilinear', but got ${interpolation}`);\n          }\n\n          const ind = b * batchStride + outY * rowStride + outX * colStride + channel;\n          outVals[ind] = val;\n        }\n      }\n    }\n\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n\n  const dataId = backend.write(outVals, outShape, image.dtype);\n  return {\n    dataId,\n    shape: image.shape,\n    dtype: image.dtype\n  };\n}\nexport const transformConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform\n};\n\nfunction mapCoord(outCoord, len, mode) {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\n\nfunction mapCoordReflect(outCoord, len) {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      inCoord -= sz2 * Math.trunc(inCoord / sz2);\n\n      if (inCoord >= len) {\n        inCoord = sz2 - inCoord - 1;\n      }\n    }\n  } // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordWrap(outCoord, len) {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord -= len * Math.trunc(inCoord / sz);\n    }\n  } // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordConstant(outCoord, len) {\n  return outCoord;\n}\n\nfunction mapCoordNearest(outCoord, len) {\n  return util.clamp(0, outCoord, len - 1);\n}\n\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\n\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const $y = Math.round(y);\n  const $x = Math.round(x);\n  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\n\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const yFloor = Math.floor(y);\n  const xFloor = Math.floor(x);\n  const yCeil = yFloor + 1;\n  const xCeil = xFloor + 1; // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n\n  const valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue); // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n\n  const valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue); // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/Transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, NumericDataType, TensorInfo, Transform, TransformAttrs, TransformInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function transform(args: {\n  inputs: TransformInputs,\n  attrs: TransformAttrs,\n  backend: MathBackendCPU\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {image, transforms} = inputs;\n  const {interpolation, fillMode, fillValue, outputShape} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] =\n      outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape = [batch, outHeight, outWidth, numChannels];\n\n  const strides = util.computeStrides(image.shape);\n  const batchStride = strides[0];\n  const rowStride = strides[1];\n  const colStride = strides[2];\n\n  const outVals = util.getTypedArrayFromDType(\n      image.dtype as NumericDataType, util.sizeFromShape(outShape));\n\n  outVals.fill(fillValue);\n\n  const imageVals = backend.data.get(image.dataId).values as TypedArray;\n  const transformVals =\n      backend.data.get(transforms.dataId).values as TypedArray;\n\n  // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n  for (let b = 0; b < batch; ++b) {\n    const transform = transforms.shape[0] === 1 ?\n        transformVals :\n        transformVals.subarray(b * 8, b * 8 + 8);\n\n    for (let outY = 0; outY < outHeight; ++outY) {\n      for (let outX = 0; outX < outWidth; ++outX) {\n        for (let channel = 0; channel < numChannels; ++channel) {\n          let val;\n\n          const projection = transform[6] * outX + transform[7] * outY + 1;\n\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n\n          const inX =\n              (transform[0] * outX + transform[1] * outY + transform[2]) /\n              projection;\n          const inY =\n              (transform[3] * outX + transform[4] * outY + transform[5]) /\n              projection;\n\n          const x = mapCoord(inX, imageWidth, fillMode);\n          const y = mapCoord(inY, imageHeight, fillMode);\n\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(\n                  imageVals, imageHeight, imageWidth, batchStride, rowStride,\n                  colStride, b, y, x, channel, fillValue);\n              break;\n            case 'bilinear':\n              val = bilinearInterpolation(\n                  imageVals, imageHeight, imageWidth, batchStride, rowStride,\n                  colStride, b, y, x, channel, fillValue);\n              break;\n            default:\n              throw new Error(\n                  `Error in Transform: Expect 'nearest' or ` +\n                  `'bilinear', but got ${interpolation}`);\n          }\n\n          const ind =\n              b * batchStride + outY * rowStride + outX * colStride + channel;\n\n          outVals[ind] = val;\n        }\n      }\n    }\n\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n\n  const dataId = backend.write(outVals, outShape, image.dtype);\n  return {dataId, shape: image.shape, dtype: image.dtype};\n}\n\nexport const transformConfig: KernelConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform as {} as KernelFunc\n};\n\nfunction mapCoord(\n    outCoord: number, len: number,\n    mode: 'constant'|'reflect'|'wrap'|'nearest') {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\n\nfunction mapCoordReflect(outCoord: number, len: number): number {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  let inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      inCoord -= sz2 * Math.trunc(inCoord / sz2);\n      if (inCoord >= len) {\n        inCoord = sz2 - inCoord - 1;\n      }\n    }\n  }\n  // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordWrap(outCoord: number, len: number): number {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  let inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord -= len * Math.trunc(inCoord / sz);\n    }\n  }\n  // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordConstant(outCoord: number, len: number): number {\n  return outCoord;\n}\n\nfunction mapCoordNearest(outCoord: number, len: number): number {\n  return util.clamp(0, outCoord, len - 1);\n}\n\nfunction readWithFillValue(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number): number {\n  const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\n\nfunction nearestInterpolation(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number): number {\n  const $y = Math.round(y);\n  const $x = Math.round(x);\n\n  return readWithFillValue(\n      imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride,\n      batch, $y, $x, channel, fillValue);\n}\n\nfunction bilinearInterpolation(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number) {\n  const yFloor = Math.floor(y);\n  const xFloor = Math.floor(x);\n  const yCeil = yFloor + 1;\n  const xCeil = xFloor + 1;\n  // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n  const valueYFloor =\n      (xCeil - x) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yFloor, xFloor, channel, fillValue) +\n      (x - xFloor) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yFloor, xCeil, channel, fillValue);\n  // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n  const valueYCeil =\n      (xCeil - x) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yCeil, xFloor, channel, fillValue) +\n      (x - xFloor) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yCeil, xCeil, channel, fillValue);\n  // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}