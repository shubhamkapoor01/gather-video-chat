{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Math utility functions.\n *\n * This file contains some frequently used math function that operates on\n * number[] or Float32Array and return a number. Many of these functions are\n * not-so-thick wrappers around TF.js Core functions. But they offer the\n * convenience of\n * 1) not having to convert the inputs into Tensors,\n * 2) not having to convert the returned Tensors to numbers.\n */\nimport { ValueError } from '../errors';\n/**\n * Determine if a number is an integer.\n */\n\nexport function isInteger(x) {\n  return x === parseInt(x.toString(), 10);\n}\n/**\n * Calculate the product of an array of numbers.\n * @param array The array to calculate the product over.\n * @param begin Beginning index, inclusive.\n * @param end Ending index, exclusive.\n * @return The product.\n */\n\nexport function arrayProd(array, begin, end) {\n  if (begin == null) {\n    begin = 0;\n  }\n\n  if (end == null) {\n    end = array.length;\n  }\n\n  let prod = 1;\n\n  for (let i = begin; i < end; ++i) {\n    prod *= array[i];\n  }\n\n  return prod;\n}\n/**\n * Compute minimum value.\n * @param array\n * @return minimum value.\n */\n\nexport function min(array) {\n  // same behavior as tf.min()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n\n  let min = Number.POSITIVE_INFINITY;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n\n    if (value < min) {\n      min = value;\n    }\n  }\n\n  return min;\n}\n/**\n * Compute maximum value.\n * @param array\n * @return maximum value\n */\n\nexport function max(array) {\n  // same behavior as tf.max()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n\n  let max = Number.NEGATIVE_INFINITY;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n\n    if (value > max) {\n      max = value;\n    }\n  }\n\n  return max;\n}\n/**\n * Compute sum of array.\n * @param array\n * @return The sum.\n */\n\nexport function sum(array) {\n  let sum = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    sum += value;\n  }\n\n  return sum;\n}\n/**\n * Compute mean of array.\n * @param array\n * @return The mean.\n */\n\nexport function mean(array) {\n  return sum(array) / array.length;\n}\n/**\n * Compute variance of array.\n * @param array\n * @return The variance.\n */\n\nexport function variance(array) {\n  const meanValue = mean(array);\n  const demeaned = array.map(value => value - meanValue);\n  let sumSquare = 0;\n\n  for (let i = 0; i < demeaned.length; i++) {\n    const value = demeaned[i];\n    sumSquare += value * value;\n  }\n\n  return sumSquare / array.length;\n}\n/**\n * Compute median of array.\n * @param array\n * @return The median value.\n */\n\nexport function median(array) {\n  const arraySorted = array.slice().sort((a, b) => a - b);\n  const lowIdx = Math.floor((arraySorted.length - 1) / 2);\n  const highIdx = Math.ceil((arraySorted.length - 1) / 2);\n\n  if (lowIdx === highIdx) {\n    return arraySorted[lowIdx];\n  }\n\n  return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n/**\n * Generate an array of integers in [begin, end).\n * @param begin Beginning integer, inclusive.\n * @param end Ending integer, exclusive.\n * @returns Range array.\n * @throws ValueError, iff `end` < `begin`.\n */\n\nexport function range(begin, end) {\n  if (end < begin) {\n    throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);\n  }\n\n  const out = [];\n\n  for (let i = begin; i < end; ++i) {\n    out.push(i);\n  }\n\n  return out;\n}","map":{"version":3,"sources":["../../../../../../tfjs-layers/src/utils/math_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Math utility functions.\n *\n * This file contains some frequently used math function that operates on\n * number[] or Float32Array and return a number. Many of these functions are\n * not-so-thick wrappers around TF.js Core functions. But they offer the\n * convenience of\n * 1) not having to convert the inputs into Tensors,\n * 2) not having to convert the returned Tensors to numbers.\n */\n\nimport {ValueError} from '../errors';\n\nexport type ArrayTypes = Uint8Array|Int32Array|Float32Array;\n\n/**\n * Determine if a number is an integer.\n */\nexport function isInteger(x: number): boolean {\n  return x === parseInt(x.toString(), 10);\n}\n\n/**\n * Calculate the product of an array of numbers.\n * @param array The array to calculate the product over.\n * @param begin Beginning index, inclusive.\n * @param end Ending index, exclusive.\n * @return The product.\n */\nexport function arrayProd(\n    array: number[]|ArrayTypes, begin?: number, end?: number): number {\n  if (begin == null) {\n    begin = 0;\n  }\n  if (end == null) {\n    end = array.length;\n  }\n\n  let prod = 1;\n  for (let i = begin; i < end; ++i) {\n    prod *= array[i];\n  }\n  return prod;\n}\n\n/**\n * Compute minimum value.\n * @param array\n * @return minimum value.\n */\nexport function min(array: number[]|Float32Array): number {\n  // same behavior as tf.min()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n  let min = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    if (value < min) {\n      min = value;\n    }\n  }\n  return min;\n}\n\n/**\n * Compute maximum value.\n * @param array\n * @return maximum value\n */\nexport function max(array: number[]|Float32Array): number {\n  // same behavior as tf.max()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n  let max = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    if (value > max) {\n      max = value;\n    }\n  }\n  return max;\n}\n\n/**\n * Compute sum of array.\n * @param array\n * @return The sum.\n */\nexport function sum(array: number[]|Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    sum += value;\n  }\n  return sum;\n}\n\n/**\n * Compute mean of array.\n * @param array\n * @return The mean.\n */\nexport function mean(array: number[]|Float32Array): number {\n  return sum(array) / array.length;\n}\n\n/**\n * Compute variance of array.\n * @param array\n * @return The variance.\n */\nexport function variance(array: number[]|Float32Array): number {\n  const meanValue = mean(array);\n  const demeaned = array.map((value: number) => value - meanValue);\n  let sumSquare = 0;\n  for (let i = 0; i < demeaned.length; i++) {\n    const value = demeaned[i];\n    sumSquare += value * value;\n  }\n  return sumSquare / array.length;\n}\n\n/**\n * Compute median of array.\n * @param array\n * @return The median value.\n */\nexport function median(array: number[]|Float32Array): number {\n  const arraySorted = array.slice().sort((a, b) => a - b);\n  const lowIdx = Math.floor((arraySorted.length - 1) / 2);\n  const highIdx = Math.ceil((arraySorted.length - 1) / 2);\n  if (lowIdx === highIdx) {\n    return arraySorted[lowIdx];\n  }\n  return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n\n/**\n * Generate an array of integers in [begin, end).\n * @param begin Beginning integer, inclusive.\n * @param end Ending integer, exclusive.\n * @returns Range array.\n * @throws ValueError, iff `end` < `begin`.\n */\nexport function range(begin: number, end: number): number[] {\n  if (end < begin) {\n    throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);\n  }\n  const out: number[] = [];\n  for (let i = begin; i < end; ++i) {\n    out.push(i);\n  }\n  return out;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}