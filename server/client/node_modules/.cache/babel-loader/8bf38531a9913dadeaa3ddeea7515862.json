{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\n\nfunction broadcastArgs_(s0, s1) {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n\n  if (shape1Input.rank !== 1) {\n    throw new Error('broadcastArgs(): first input must be a vector (rank=1). ' + `Has rank ${shape1Input.rank}`);\n  }\n\n  if (shape2Input.rank !== 1) {\n    throw new Error('broadcastArgs(): second input must be a vector (rank=1). ' + `Has rank ${shape2Input.rank}`);\n  }\n\n  const inputs = {\n    s0: shape1Input,\n    s1: shape2Input\n  };\n  return ENGINE.runKernel(BroadcastArgs, inputs);\n}\n\nexport const broadcastArgs = op({\n  broadcastArgs_\n});","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/broadcast_args.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAS,MAAT,QAAuB,WAAvB;AACA,SAAS,aAAT,QAAmD,iBAAnD;AAEA,SAAS,eAAT,QAAgC,oBAAhC;AAGA,SAAS,EAAT,QAAmB,aAAnB;AAEA;;;;;;;;;;;;;AAaG;;AACH,SAAS,cAAT,CACE,EADF,EAC2B,EAD3B,EACkD;AAChD,QAAM,WAAW,GAAG,eAAe,CAAC,EAAD,EAAK,IAAL,EAAW,eAAX,EAA4B,OAA5B,CAAnC;AACA,QAAM,WAAW,GAAG,eAAe,CAAC,EAAD,EAAK,IAAL,EAAW,eAAX,EAA4B,OAA5B,CAAnC;;AAEA,MAAI,WAAW,CAAC,IAAZ,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAI,KAAJ,CACJ,6DACA,YAAY,WAAW,CAAC,IAAI,EAFxB,CAAN;AAGD;;AAED,MAAI,WAAW,CAAC,IAAZ,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAI,KAAJ,CACJ,8DACA,YAAY,WAAW,CAAC,IAAI,EAFxB,CAAN;AAGD;;AAED,QAAM,MAAM,GAAwB;AAAE,IAAA,EAAE,EAAE,WAAN;AAAmB,IAAA,EAAE,EAAE;AAAvB,GAApC;AACA,SAAO,MAAM,CAAC,SAAP,CAAiB,aAAjB,EAAgC,MAAhC,CAAP;AACD;;AAED,OAAO,MAAM,aAAa,GAAG,EAAE,CAAC;AAAE,EAAA;AAAF,CAAD,CAAxB","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { NamedTensorMap } from '../tensor_types';\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs, BroadcastArgsInputs } from '../kernel_names';\nimport { Tensor } from '../tensor';\nimport { convertToTensor } from '../tensor_util_env';\nimport { Rank, TensorLike } from '../types';\n\nimport { op } from './operation';\n\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastArgs_<R extends Rank>(\n  s0: Tensor | TensorLike, s1: Tensor | TensorLike): Tensor<R> {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n\n  if (shape1Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): first input must be a vector (rank=1). ' +\n      `Has rank ${shape1Input.rank}`);\n  }\n\n  if (shape2Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): second input must be a vector (rank=1). ' +\n      `Has rank ${shape2Input.rank}`);\n  }\n\n  const inputs: BroadcastArgsInputs = { s0: shape1Input, s1: shape2Input };\n  return ENGINE.runKernel(BroadcastArgs, inputs as {} as NamedTensorMap);\n}\n\nexport const broadcastArgs = op({ broadcastArgs_ });\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}